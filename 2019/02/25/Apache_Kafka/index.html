<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Kafka简介Kafka是一款由美国领英公司（LinkedIn）开源出来的高性能消息引擎系统（Messaging system）,其核心功能是——高性能的消息发送与高性能的消息消费。但随着Kafka的不断演进，在Kafka 0.10.0.0版本正式推出了Kafka Streams，即流式处理组件。自此Kafka正式成为了一个流式处理框架。  前置知识背景消息引擎系统消息引擎，又叫消息队列，消息中间">
<meta name="keywords" content="Kafka">
<meta property="og:type" content="article">
<meta property="og:title" content="消息队列Kafka学习笔记">
<meta property="og:url" content="http://yoursite.com/2019/02/25/Apache_Kafka/index.html">
<meta property="og:site_name" content="Utur的个人博客">
<meta property="og:description" content="Kafka简介Kafka是一款由美国领英公司（LinkedIn）开源出来的高性能消息引擎系统（Messaging system）,其核心功能是——高性能的消息发送与高性能的消息消费。但随着Kafka的不断演进，在Kafka 0.10.0.0版本正式推出了Kafka Streams，即流式处理组件。自此Kafka正式成为了一个流式处理框架。  前置知识背景消息引擎系统消息引擎，又叫消息队列，消息中间">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/消息引擎架构.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/队列消息引擎模型.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/发布订阅消息模型.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/topic和partition.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/消费者位移.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/leadr-follower.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/V2版本消息格式.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/V2版本消息batch格式.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/副本位置信息.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/副本同步流程.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/Kafka备份原理.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/clients端处理流程.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/broker端请求处理流程.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/controller架构.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/副本状态机.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/分区状态机.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/Reactor模式.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/broker请求处理流程.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/producer端的工作原理.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/producer序列化.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/consumer%20group状态机.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/幂等性producer消息去重.png">
<meta property="og:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/跨分区事务提交与读取.png">
<meta property="og:updated_time" content="2019-07-06T08:50:18.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="消息队列Kafka学习笔记">
<meta name="twitter:description" content="Kafka简介Kafka是一款由美国领英公司（LinkedIn）开源出来的高性能消息引擎系统（Messaging system）,其核心功能是——高性能的消息发送与高性能的消息消费。但随着Kafka的不断演进，在Kafka 0.10.0.0版本正式推出了Kafka Streams，即流式处理组件。自此Kafka正式成为了一个流式处理框架。  前置知识背景消息引擎系统消息引擎，又叫消息队列，消息中间">
<meta name="twitter:image" content="http://yoursite.com/home/utur/图片/picture_for_note/Apache_Kafka/消息引擎架构.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/02/25/Apache_Kafka/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>消息队列Kafka学习笔记 | Utur的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Utur的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">天天学习，好好向上</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Apache_Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">消息队列Kafka学习笔记

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 16:50:18" itemprop="dateModified" datetime="2019-07-06T16:50:18+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p>Kafka是一款由美国领英公司（LinkedIn）开源出来的<strong>高性能消息引擎系统（Messaging system）</strong>,其核心功能是——<em>高性能的消息发送与高性能的消息消费</em>。但随着Kafka的不断演进，在Kafka 0.10.0.0版本正式推出了Kafka Streams，即流式处理组件。自此Kafka正式成为了一个流式处理框架。</p>
<hr>
<h2 id="前置知识背景"><a href="#前置知识背景" class="headerlink" title="前置知识背景"></a>前置知识背景</h2><h3 id="消息引擎系统"><a href="#消息引擎系统" class="headerlink" title="消息引擎系统"></a>消息引擎系统</h3><p>消息引擎，又叫消息队列，消息中间件等。</p>
<p>根据维基百科的定义，企业消息引擎系统（EMS）是企业发布的一组规范。公司使用这组规范实现在不同系统之间传递语义准确的消息。在实际使用场景中，消息引擎系统通常以软件接口为主要形式，实现了松耦合的异步式数据传递语义。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/消息引擎架构.png" alt="消息引擎"></p>
<hr>
<h3 id="消息引擎范型"><a href="#消息引擎范型" class="headerlink" title="消息引擎范型"></a>消息引擎范型</h3><p>根据维基百科定义，一个消息引擎范型是一个基于网络的架构范型，描述了消息引擎系统的两个不同的子部分是如何互连且交互的。如果把消息引擎系统的这两个子系统比喻成两座城市，那么传输协议就是需要铺设的沥青公路，而引擎范型决定了来往穿梭与这两座城市的路线。</p>
<p>最常见的两种消息引擎范型是<strong><em>消息队列模型</em></strong>和<strong><em>发布/订阅模型</em></strong>。</p>
<ul>
<li><p>消息队列（message queue）模型是基于队列提供消息传输服务的，多用于进程间通信以及线程间通信。该模型定义了消息队列、发送者和接收者，提供了一种点对点的消息传递方式，即发送者发送每条消息到队列的指定位置，接收者从指定位置获取消息。每条消息由一个发送者生产出来，且只被一个消费者处理。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/队列消息引擎模型.png" alt="消息队列模型"></p>
</li>
<li><p>发布/订阅模型(publish/subscribe),它有主题（topic）的概念：一个topic可以理解为逻辑语义相近的消息的容器。这种模型定义了类似于生产者/消费者这样的角色，即发布者和订阅者。发布者将消息生产出来发送到指定的topic中，所有订阅了该topic的订阅者都可以接收到该topic下的所有消息。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/发布订阅消息模型.png" alt="发布订阅"></p>
</li>
</ul>
<hr>
<h2 id="Kafka术语"><a href="#Kafka术语" class="headerlink" title="Kafka术语"></a>Kafka术语</h2><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>既然Kafka的核心功能就是消息引擎，那么对消息的设计日然是首当其冲的事情。Kafka在消息设计时特意避开了繁重的Java堆上内存分配，直接使用紧凑二进制字节数组ByteBuffer而不是独立的对象，因此至少能够访问多一倍的可用内存。</p>
<p>省去padding，java对对象保存的大开销以及可能的页缓存。</p>
<h3 id="topic和partiiton"><a href="#topic和partiiton" class="headerlink" title="topic和partiiton"></a>topic和partiiton</h3><p>从概念上来说，topic只是一个逻辑概念，代表了一类消息，也可以认为是消息被发送到的地方。通常可以使用topic来区分实际业务，比如业务A使用一个topic，业务B使用另一个topic。</p>
<p>Kafka中的topic通常都会被多个消费者订阅，出于性能的考量，Kafka并不是topic-message的两级结构，而是采取了topic-partition-message的三级结构来分散负载。从本质上来说，每个Kafka topic都由若干个partition组成。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/topic和partition.png" alt="topic和partition"></p>
<p>topic是由多个partition组成的，而Kafka的partition是不可修改的有序消息队列，也可以说是有序的消息日志。每个partition都有自己专属的partition号。用户对partition唯一能做的操作就是在消息序列的尾部追加写入消息。<strong>partition上的每条消息都会被分配一个唯一的序列号-该序列号被称为位移（offset）。位移信息可以唯一定位到某partition下的一条消息</strong></p>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>实际上，Kafka消费者也有位移（offset）的概念，但这两个offset属于不同的概念。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/消费者位移.png" alt="消费者位移"></p>
<p>每条消息在某个partition的位移是固定的，但消费该partition的消费者的位移会随着消费进度不断前移，但不能超过该分区最新一条消息的位移。</p>
<p><strong>从本质上看，Kafka中的一条消息其实就是一个&lt;topic,partition,offset&gt;三元组（tuple），通过该元组，可以在Kafka集群中找到位移对应的那条消息。</strong></p>
<h3 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h3><p>为了实现高可靠性，通过冗余机制——备份多份日志。这些备份日志在Kafka中被称为副本（replica），它们存在的唯一目的就是防止数据丢失。</p>
<p><strong>副本分为两类：领导者副本（leader replica）和追随者副本（follower replica）</strong>。follower replica是不能提供服务给客户端的，它只是被动地向领导者副本（leader replica）获取数据，一旦leader replica所在的broker宕机，Kafka会从剩余的replica中选举出新的leader继续提供服务。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/leadr-follower.png" alt="leader-follower"></p>
<h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p><strong>ISR的全称是 in-sync replica，就是与leader replica保持同步的replica集合。</strong></p>
<p>Kafka为partition动态维护一个replica集合。该集合中的所有replica保存的消息日志都与leader replica保护同步状态。<em>只有这个集合中的replica才能被选举为leader，也只有该集合中所有replica都接收到了同一条消息，Kafka才会将该消息置于“已提交”状态，即认为这条消息发送成功</em>。<strong>Kafka承诺只要这个集合中至少存在一个replica，那些”已提交“状态的消息就不会丢失。</strong></p>
<hr>
<h2 id="Kafka使用场景"><a href="#Kafka使用场景" class="headerlink" title="Kafka使用场景"></a>Kafka使用场景</h2><ul>
<li>消息传输</li>
<li>网站行为日志追踪</li>
<li>审计数据收集</li>
<li>日志收集</li>
<li>Event Sourcing</li>
<li>流式处理</li>
</ul>
<hr>
<h2 id="Kafka设计原理"><a href="#Kafka设计原理" class="headerlink" title="Kafka设计原理"></a>Kafka设计原理</h2><h3 id="broker端设计架构"><a href="#broker端设计架构" class="headerlink" title="broker端设计架构"></a>broker端设计架构</h3><p>broker是Apache Kafka最重要的组件，本质上它是一个功能载体（或服务载体），承载了绝大多数的Kafka服务。事实上，大多数的消息队列框架都有broker或已知类似的角色。一个broker通常是以服务器的形式出现的。</p>
<h4 id="消息设计"><a href="#消息设计" class="headerlink" title="消息设计"></a>消息设计</h4><ol>
<li><p><strong>消息格式</strong></p>
<p>V2版本分为<strong>消息</strong>和<strong>消息集合</strong>两个维度，不过消息集合的提法被消息批次所取代。V2版本中，它有一个专门的属于：RecordBatch。</p>
<p>V2版本消息格式</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/V2版本消息格式.png" alt="消息格式"></p>
<p>“可变长度”表示Kafka会根据具体的值来确定到底需要几字节保存。为了在序列化时降低使用的字节数，V2版本借鉴了Google ProtoBuffer中的Zig-zag编码方式，使得绝对值较小的整数占用字节数较少的字节。</p>
</li>
<li><p><strong>消息batch</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/V2版本消息batch格式.png" alt="消息batch"></p>
<ul>
<li>CRC值从消息层面被移除，放入batch这一层</li>
<li>PID、producer epoch和序列号等消息都是0.11.0.0版本为了实现幂等性producer和支持事务而一如的。</li>
</ul>
<p>通过使用mirco-batch，批次地发送消息，能大幅度地提高Kafka的吞吐量。</p>
</li>
</ol>
<hr>
<h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h4><p>Kafka是分布式的消息引擎集群环境，支持自动化的服务发现与成员管理。依赖于Apache Zookeeper实现，每当一个broker启动，它会将自己注册到Zookeeper下的一个节点。</p>
<ul>
<li><p>首先，每个broker在Zookeper下注册节点的路径是chroot/brokers/ids/&lt;broker.id&gt;。如果没有配置chroot，则路径是/broker/ids/&lt;broker.id&gt;。</p>
</li>
<li><p>其次，broker向Zookeeper中的注册消息以JSON格式保存。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"loacalhost"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">9092</span>,</span><br><span class="line">    <span class="attr">"jmx_port"</span>: <span class="number">9999</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="number">1499737197</span>,</span><br><span class="line">    <span class="attr">"endpoints"</span>: [</span><br><span class="line">        <span class="string">"CLIENT"</span>://host1:<span class="number">9092</span><span class="string">",</span></span><br><span class="line"><span class="string">        "</span>REPLICATION://HOST1:<span class="number">9093</span><span class="string">"</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    "</span>listener_security_protocol_map<span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>CLIENT<span class="string">": "</span>SSL<span class="string">",</span></span><br><span class="line"><span class="string">        "</span>REPLICATION<span class="string">": "</span>PLAINTEXT<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "</span>rack<span class="string">": "</span>dc1<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，Zookeeper临时节点的生命周期和客户端会话绑定。如果客户端会话失效，该临时节点就会自动被清除掉。Kafka正是利用Zookeeper临时节点来管理broker生命周期的。broker启动时在Zookeeper中创建对应的临时节点，同时还会创建一个监听器（listener）监听该临时节点的状态；一旦broker启动后，监听器会自动同步整个集群消息到该broker上；而一旦broker崩溃，它与Zookeeper的会话就会失效，导致临时节点被删除，监听器被触发，然后处理broker崩溃的后续事宜。这就是Kafka管理集群及其成员的主要流程。</p>
</li>
</ul>
<hr>
<h4 id="副本与ISR设计"><a href="#副本与ISR设计" class="headerlink" title="副本与ISR设计"></a>副本与ISR设计</h4><p>一个Kafka分区本质上就是一个备份日志，即利用多份相同的备份共同提供冗余机制来保持系统高可用性。这些备份在Kafka中被称为副本（replica）。</p>
<ul>
<li><p><strong>follower副本同步</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/副本位置信息.png" alt="副本位置信息"></p>
<ol>
<li><p>起始位移（base offset）：表示该副本当前所含第一条消息的位移</p>
</li>
<li><p><strong>高水印值（high watermark，HW</strong>）：副本高水印值。它保存了该副本最新一条已提交消息的位移。leader分区的HW值决定了副本中已提交消息的范围，也确定了consumer能够获取消息的消息上限。任何一个副本对象的HW值一定不大于其LEO值。Kafka对leader副本和follower副本的HW值更新机制是不同的。</p>
</li>
<li><p><strong>日志末端位移（log end offset，LEO）</strong>：副本日志中下一条待写入消息的offset。所有副本都需要维护自己的LEO信息。只有ISR中的所有副本都更新了对应的LEO之后，leader副本才会向右移动HW值表明消息写入成功。Kafka对leader副本和follower副本的LEO值更新机制也是不同的。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/副本同步流程.png" alt="副本同步流程"></p>
</li>
</ol>
</li>
<li><p><strong>水印（watermark）和leader epoch</strong></p>
<p>水印被称为高水印或高水位，通常被用在流水式处理领域，以表征元素或时间在基于时间层面上的进度。在Kafka中，水印的概念与时间无关，而与位置信息相关。严格来说，它表示的就是位置信息，即位移（offset）。</p>
<ul>
<li><p><strong>LEO更新机制</strong></p>
<ul>
<li><p><strong>follower</strong></p>
<p>follower副本不停地向leader副本所在broker发送FETCH请求，一旦获取消息，便写入自己的日志中进行备份。</p>
<p>Kafka设计了两套follower副本LEO属性：一套LEO属性保存在follower副本所在broker的缓存上；另一套LEO值保存在leader副本所在broker的缓存上。换句话说，leader副本所在broker的缓存上保存了该分区下所有follower副本的LEO属性值。</p>
<ol>
<li><p>follower副本端LEO更新</p>
<p>每当在底层日志新写入一条消息，其LEO值就会加1.</p>
</li>
<li><p>leader副本端的follower副本LEO更新</p>
<p>一旦leader接收到follower发送的FETCH请求，它首先会从自己的log中读取相应的数据，但是在给follower返回数据之前它先去更新follower的LEO。</p>
</li>
</ol>
</li>
<li><p><strong>leader</strong></p>
<p>每当在底层日志新写入一条消息，其LEO值就会加1.</p>
</li>
</ul>
</li>
<li><p><strong>HW更新机制</strong></p>
<p>前面说过，leader broker上保存了一套follower副本的LEO以及它自己的LEO。当尝试确定分区HW时，它会选出所有满足条件的副本，比较它们的LEO，并选择最小的LEO值作为HW值。</p>
</li>
<li><p><strong>图解Kafka备份原理</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/Kafka备份原理.png" alt="Kafka备份原理"></p>
</li>
<li><p><strong>基于水印机制的缺陷</strong></p>
<ul>
<li><strong>数据丢失</strong>：使用HW值来确定备份进度时其值的更新是在下一轮RPC中完成的。延迟一轮FETCH请求更新HW的值的设计使得followerHW值是异步延迟更新的，若在这个过程中leader发生变更，那么称为新leader的follower的HW值就有可能是过期的，使得clients端认为成功提交的消息被删除了。</li>
<li><strong>数据不一致/数据离散</strong>：leader端log和follower端的log数据不一致</li>
</ul>
</li>
<li><p><strong>leader epoch</strong></p>
<p><strong>上述两个问题的根本原因在于HW值被用于衡量副本备份的成功与否，以及在出现崩溃时作为日志截断的依据，但HW值的更新是异步延迟的，特别是需要额外的FETCH请求处理流程才能更新，这中间发生的任何崩溃都可能导致HW值的过期</strong></p>
<p>leader epoch，实际上是一对值(epoch，offset)。epoch表示leader的版本号，从0开始，当leader变更过1次时，epoch就会+1，而offset则对应于该epoch版本的leadre写入第一条消息的位移。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><ul>
<li><p><strong>协议设计</strong></p>
<p>所谓通信协议，就是实现client-server间或server-server间数据传输的一套规范。Kafka通信协议是基于TCP之上的二进制协议，这套协议提供的API表现为服务于不同功能的多种请求类型以及对应的相应。所有类型的请求和响应都是结构化的，有不同的初始类型构成。</p>
</li>
<li><p><strong>常见请求类型</strong></p>
<ol>
<li>PRODUCE请求</li>
<li>FETCH请求</li>
<li>METADATA请求</li>
</ol>
</li>
<li><p><strong>请求处理流程</strong></p>
<ul>
<li><p><strong>clients端</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/clients端处理流程.png" alt="cliens请求处理"></p>
</li>
<li><p><strong>broker端</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/broker端请求处理流程.png" alt="broker端请求处理"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="controller设计"><a href="#controller设计" class="headerlink" title="controller设计"></a>controller设计</h4><ul>
<li><p><strong>controller概览</strong></p>
<p>在一个Kafka集群中，某一个broker会被选举出来承担特殊的角色，即控制器。一如controller就是用来管理和协调Kafka集群的。具体来说，就是管理集群中所有分区的状态并执行相应的管理操作。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/controller架构.png" alt="controller架构"></p>
</li>
<li><p><strong>controller管理状态</strong></p>
<p>controller维护的状态分为两类：每台broker上的分区副本和每个分区的leader副本信息。从维度上看，这些状态可分为副本状态和分区状态。</p>
<ul>
<li><p><strong>副本状态机</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/副本状态机.png" alt="副本状态机"></p>
</li>
<li><p><strong>分区状态机</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/分区状态机.png" alt="分区状态机"></p>
</li>
</ul>
</li>
<li><p><strong>controller职责</strong></p>
<ol>
<li>更新集群元数据信息</li>
<li>创建topic</li>
<li>删除topic</li>
<li>分区重分配</li>
<li>preferred leader副本选举</li>
<li>topic分区扩展</li>
<li>broker加入集群</li>
<li>broker崩溃</li>
<li>受控关闭</li>
<li>controller leader选举</li>
</ol>
</li>
</ul>
<hr>
<h4 id="broker请求处理"><a href="#broker请求处理" class="headerlink" title="broker请求处理"></a>broker请求处理</h4><ul>
<li><strong>Reactor模式</strong></li>
</ul>
<p>Kafka broker处理请求的模式就是Reactor设计模式。Reactor设计模式是一种事件处理模式，旨在处理多个输入源同时发送过来的请求。Reactor模式中的服务处理器或分发器将入站请求按照多路复用的方式分发到对应的请求处理器。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/Reactor模式.png" alt="Reactor模式"></p>
<ul>
<li><p><strong>Kafka broker请求处理</strong></p>
<p>Kafka broker请求处理实现了Reactor模式。在Kafka中，每个broker都有一个acceptor线程和若干个processor线程。processor线程的数量是可以配置的。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/broker请求处理流程.png" alt="broker请求处理流程"></p>
</li>
</ul>
<hr>
<h3 id="producer端设计架构"><a href="#producer端设计架构" class="headerlink" title="producer端设计架构"></a>producer端设计架构</h3><h4 id="producer端基本数据结构"><a href="#producer端基本数据结构" class="headerlink" title="producer端基本数据结构"></a>producer端基本数据结构</h4><ul>
<li><p><strong>ProducerRecord</strong></p>
<p>一个ProducerRecord封装了一条待发送的消息（或称为记录）。</p>
<p>ProducerRecord由5个字段构成:</p>
<ol>
<li>topic：该消息所属的topic</li>
<li>partition：该消息所属的分区</li>
<li>key：消息key</li>
<li>value：消息体</li>
<li>timestamp：消息时间戳</li>
</ol>
</li>
<li><p><strong>RecordMetadata</strong></p>
<p>该数据结构表示Kafka服务器端返回给客户端的消息的元数据</p>
<ol>
<li>offset：消息在 分区日志中的位移信息</li>
<li>timesstamp：消息时间戳</li>
<li>topic/partition</li>
<li>checksum：消息CRC32码</li>
<li>serializedKeySize：序列化后消息的key字节数</li>
<li>serializedValueSize：序列化后消息value字节数</li>
</ol>
</li>
</ul>
<hr>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>如果把producer统一看成一个盒子，那么整个producer端的工作原理便如图所示。大体来说，用户首先构建待发送的消息对象ProducerRecord，然后调用KafkaProducer#send方法进行发送。KafkaProducer接收到消息后首先对其进行序列化，然后结合本地缓存的元数据信息一起发送给partitioner去确定目标分区，最后追加写入内存中的消息缓冲池。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/producer端的工作原理.png" alt="producer端的工作原理"></p>
<p>调用KafkaProducer.send执行的操作：</p>
<ol>
<li><p><strong>序列化+计算目标分区</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/producer序列化.png" alt="序列化"></p>
</li>
<li><p><strong>追加写入消息缓冲区</strong></p>
</li>
<li><p><strong>Sender线程预处理及消息发送</strong></p>
</li>
</ol>
<hr>
<h3 id="consumer端设计架构"><a href="#consumer端设计架构" class="headerlink" title="consumer端设计架构"></a>consumer端设计架构</h3><h4 id="consumer-group-状态机"><a href="#consumer-group-状态机" class="headerlink" title="consumer group 状态机"></a>consumer group 状态机</h4><p>新版本consumer依赖于broker端的组协调者coordinator来管理组内的所有consumer实例并负责把分配方案发到每个consumer上。分配方案由组内的leader consumer根据指定的分区分配策略指定的。</p>
<p>分区分配的操作在consumer端执行而非broker端的好处：</p>
<ol>
<li>便于维护与升级：如果在broker端实现，那么分配策略的变动势必要重启整个Kafka集群。生产环境中重启服务器的代价是很高的。</li>
<li>便于实现自定义策略：不同的策略由不同的逻辑实现。coordinator端代码不容易实现灵活可定制的分配逻辑</li>
<li>解耦了组管理与分区分配，coordinator负责组管理工作，而consumer程序负责分区分配。</li>
</ol>
<p>Kafka为每个consumer group定义了5个状态：</p>
<ul>
<li><strong>Empty</strong>：表明group下没有任何active consumer，但可能包含位移信息。</li>
<li><strong>PreparingRebalance</strong>：该状态表明group正在准备进行group rebalance。</li>
<li><strong>AwaitingSync</strong>：该状态表明所有成员都已经加入组并等待leader consumer发送分区分配方案。</li>
<li><strong>Stable</strong>：该状态表明group开始正常消费。此时group必须响应clients发送过来的任何请求。</li>
<li><strong>Dead</strong>：该状态表明group已经彻底废弃，group内没有任何成员并且group的所有元数据都已被删除。</li>
</ul>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/consumer group状态机.png" alt="consumer group状态机"></p>
<hr>
<h3 id="实现精确一次处理语义-exactly-once-semanties-EOS"><a href="#实现精确一次处理语义-exactly-once-semanties-EOS" class="headerlink" title="实现精确一次处理语义(exactly-once semanties, EOS)"></a>实现精确一次处理语义(exactly-once semanties, EOS)</h3><p>clients端常见的3种消息交付语义：</p>
<ol>
<li><strong>最多一次（ai most once）</strong>：消息可能丢失也可能被处理，但最多只会被处理一次</li>
<li><strong>至少一次（at last once）</strong>：消息不会丢失，但可能被多次处理</li>
<li><strong>精确一次（exactly once）</strong>：消息被处理且只会被处理一次。</li>
</ol>
<h4 id="幂等性producer（idempotent-producer）"><a href="#幂等性producer（idempotent-producer）" class="headerlink" title="幂等性producer（idempotent producer）"></a>幂等性producer（idempotent producer）</h4><p>幂等性producer是Apache Kafka 0.11.0.0版本用于实现EOS的一个利器。若一个操作执行多次的结果与只运行一次的结果是相同的，那么称该操作为幂等操作。引入幂等producer表示它的发送操作是幂等。瞬时的发送错可能导致produecer端出现重试，同一个消息被producer发送多次，但在broker端这条消息只会被写入日志一次。</p>
<p>幂等性producer的设计思路类似于TCP的工作方式。发送到broker端的每批消息都会被赋予一个序列号（sequence number）用于消息去重。但是和TCP不同的是，这个序列号不会被丢弃，相反Kafka会把它们保存在底层日志中，这样即使分区的leader副本挂掉，新选出来的leader broker也能执行消息去重工作。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/幂等性producer消息去重.png" alt="幂等性producer消息去重"></p>
<hr>
<h4 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h4><p>对事务的支持是Kafka实现EOS的第二个利器。引入事务使得clients端程序（无论是producer还是consumer）能够将一组消息放入一个原子性单元中统一处理。</p>
<p>处于事务中的这组消息能够从多个分区中消费，也可以发送到多个分区中。重要的是不论是发送还是消费，Kafka都能保证它们是原子性，即所有的写入操作幺妹全部成功，要么全部失败。</p>
<p>Kafka为实现事务要求应用程序必须提供一个唯一的id来表征事务。这个id被称为事务id，它必须在应用程序所有的会话上是唯一的。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/跨分区事务提交与读取.png" alt="跨分区事务提交与读取"></p>
<p>PS：未完待续，后续深入学习再做补充</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/Kafka/" rel="tag"># Kafka</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/25/Linux内核（学习笔记）/" rel="next" title="深入理解Linux内核">
                <i class="fa fa-chevron-left"></i> 深入理解Linux内核
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/25/django_web_开发错误整理/" rel="prev" title="django开发问题整理">
                django开发问题整理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Utur</p>
              <div class="site-description motion-element" itemprop="description">木龟想做一个哈皮程序猿。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Turtle-knight" title="GitHub &rarr; https://github.com/Turtle-knight" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:turtle.mugui@gmail.com" title="E-Mail &rarr; mailto:turtle.mugui@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://plus.google.com/木龟" title="Google &rarr; https://plus.google.com/木龟" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka简介"><span class="nav-number">1.</span> <span class="nav-text">Kafka简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前置知识背景"><span class="nav-number">2.</span> <span class="nav-text">前置知识背景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#消息引擎系统"><span class="nav-number">2.1.</span> <span class="nav-text">消息引擎系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息引擎范型"><span class="nav-number">2.2.</span> <span class="nav-text">消息引擎范型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka术语"><span class="nav-number">3.</span> <span class="nav-text">Kafka术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#消息"><span class="nav-number">3.1.</span> <span class="nav-text">消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#topic和partiiton"><span class="nav-number">3.2.</span> <span class="nav-text">topic和partiiton</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offset"><span class="nav-number">3.3.</span> <span class="nav-text">offset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replica"><span class="nav-number">3.4.</span> <span class="nav-text">replica</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ISR"><span class="nav-number">3.5.</span> <span class="nav-text">ISR</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka使用场景"><span class="nav-number">4.</span> <span class="nav-text">Kafka使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka设计原理"><span class="nav-number">5.</span> <span class="nav-text">Kafka设计原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#broker端设计架构"><span class="nav-number">5.1.</span> <span class="nav-text">broker端设计架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消息设计"><span class="nav-number">5.1.1.</span> <span class="nav-text">消息设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群管理"><span class="nav-number">5.1.2.</span> <span class="nav-text">集群管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#副本与ISR设计"><span class="nav-number">5.1.3.</span> <span class="nav-text">副本与ISR设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通信协议"><span class="nav-number">5.1.4.</span> <span class="nav-text">通信协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#controller设计"><span class="nav-number">5.1.5.</span> <span class="nav-text">controller设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#broker请求处理"><span class="nav-number">5.1.6.</span> <span class="nav-text">broker请求处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#producer端设计架构"><span class="nav-number">5.2.</span> <span class="nav-text">producer端设计架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#producer端基本数据结构"><span class="nav-number">5.2.1.</span> <span class="nav-text">producer端基本数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作流程"><span class="nav-number">5.2.2.</span> <span class="nav-text">工作流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#consumer端设计架构"><span class="nav-number">5.3.</span> <span class="nav-text">consumer端设计架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#consumer-group-状态机"><span class="nav-number">5.3.1.</span> <span class="nav-text">consumer group 状态机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现精确一次处理语义-exactly-once-semanties-EOS"><span class="nav-number">5.4.</span> <span class="nav-text">实现精确一次处理语义(exactly-once semanties, EOS)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#幂等性producer（idempotent-producer）"><span class="nav-number">5.4.1.</span> <span class="nav-text">幂等性producer（idempotent producer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事务（transaction）"><span class="nav-number">5.4.2.</span> <span class="nav-text">事务（transaction）</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Utur</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
