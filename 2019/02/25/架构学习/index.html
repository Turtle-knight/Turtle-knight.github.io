<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="定义架构软件架构指软件系统的顶层结构 相关概念  系统是一群关联个体组成，这些“个体”可以是“子系统”、”模块“、”组件“等；架构需要明确系统包含哪些”个体“。 系统中的个体需要根据某种规则运作，架构需要明确个体运作和协作的规则。  架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。 架构设计的真正目的整个软件技术发展">
<meta name="keywords" content="架构">
<meta property="og:type" content="article">
<meta property="og:title" content="架构学习">
<meta property="og:url" content="http://yoursite.com/2019/02/25/架构学习/index.html">
<meta property="og:site_name" content="Utur的个人博客">
<meta property="og:description" content="定义架构软件架构指软件系统的顶层结构 相关概念  系统是一群关联个体组成，这些“个体”可以是“子系统”、”模块“、”组件“等；架构需要明确系统包含哪些”个体“。 系统中的个体需要根据某种规则运作，架构需要明确个体运作和协作的规则。  架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。 架构设计的真正目的整个软件技术发展">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-07-06T09:31:05.005Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="架构学习">
<meta name="twitter:description" content="定义架构软件架构指软件系统的顶层结构 相关概念  系统是一群关联个体组成，这些“个体”可以是“子系统”、”模块“、”组件“等；架构需要明确系统包含哪些”个体“。 系统中的个体需要根据某种规则运作，架构需要明确个体运作和协作的规则。  架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。 架构设计的真正目的整个软件技术发展">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/02/25/架构学习/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>架构学习 | Utur的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Utur的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">天天学习，好好向上</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/架构学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">架构学习

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:31:05" itemprop="dateModified" datetime="2019-07-06T17:31:05+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="定义架构"><a href="#定义架构" class="headerlink" title="定义架构"></a>定义架构</h2><p><strong>软件架构指软件系统的顶层结构</strong></p>
<p><em>相关概念</em></p>
<ol>
<li>系统是一群关联个体组成，这些“个体”可以是“子系统”、”模块“、”组件“等；架构需要明确系统包含哪些”个体“。</li>
<li>系统中的个体需要根据某种规则运作，架构需要明确个体运作和协作的规则。</li>
</ol>
<p>架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。</p>
<h2 id="架构设计的真正目的"><a href="#架构设计的真正目的" class="headerlink" title="架构设计的真正目的"></a>架构设计的真正目的</h2><p>整个软件技术发展的历史，其实就是一部与”复杂度“斗争的历史，架构的出现也不例外。简而言之，架构是为了应对软件系统负责度而提出的一个解决方案。<strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题。</strong></p>
<p>架构是为了应对软件系统复杂度而提出的一个解决方案。架构即（重要）决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体（人、财、物、时间、事情等）。架构各有千秋，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。</p>
<p>需求驱动架构。在分析设计阶段，需要考虑一定的人力与时间去”跳出代码，总揽全局“，为业务和IT技术之间搭建一座”桥梁”。</p>
<p>架构设计处于软件研制的前期，一方面，越是前期，就越早发现问题，修改的代价也就越低；另一方面，软件实施后期若有架构上的修改，也需要付出更多的代价。</p>
<h2 id="复杂度的来源"><a href="#复杂度的来源" class="headerlink" title="复杂度的来源"></a>复杂度的来源</h2><p>复杂度的来源主要有6个。</p>
<ul>
<li><p><strong>高性能</strong></p>
<p>对性能孜孜不倦的追求是整个人类技术不断发展的根本驱动力。软件系统中高性能带来的复杂度主要体现在两个方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多态计算机集群为了高性能带来的复杂度。</p>
<ul>
<li><p><strong>单机复杂度</strong></p>
<p>计算机内部复杂度最关键的地方就是操作系统，操作系统是软件系统的运行环境，操作系统的复杂度决定了软件系统的复杂度。</p>
<p>操作系统和性能最相关的是进程和线程。</p>
</li>
<li><p><strong>集群的复杂度</strong></p>
<p>通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器配合起来达到高性能的目的，是一个复杂的任务。</p>
<ol>
<li><p>任务分配</p>
<p>任务分配的意思是指每台机器都可以处理完成的业务任务，不同的任务分配到不同的机器上执行。</p>
<ul>
<li>需要增加任务分配器</li>
<li>任务分配器和真正的业务服务器之间有连接和交互</li>
<li>任务分配器需要增加分配算法。例如，轮询算法、按权重分配、或按照负载进行分配。</li>
</ul>
</li>
<li><p>任务分解</p>
<ul>
<li>简单的系统更加容易做到高性能</li>
<li>可以针对单个任务进行扩展</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>高可用</strong></p>
<p>维基百科的定义</p>
<blockquote>
<p>系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</p>
</blockquote>
<p>这个定义的关键在于“无中断”，但恰好难点也在“无中断”上面，因为无论是单个硬件还是单个软件，都不可能做到无中断，硬件会出故障，软件会老化；硬件会逐渐老化，软件会越来越复杂的庞大。</p>
<p>除了硬件和软件本质上无法做到”无中断“，外部环境导致的不可用更加不可避免、不受控制。例如、断点、水灾、的证。</p>
<p>系统的高可用方案五花八门，但万变不离其宗，<strong>本质上都是通过“ 冗余 ”来实现高可用。</strong>通俗点来讲，就是一台机器不够就两台，两台不够就四台;一个机房可能断电，那就部<br>署两个机房;一条通道可能故障，那就用两条，两条不够那就用三条(移动、电信、联通一起上)。高可用的 “ 冗余 ” 解决方案，单纯从形式上来看，和之前的高性能是一样的，都<br>是通过增加更多机器来达到目的，但其实本质上是有根本区别的: <strong>高性能增加机器目的在于“扩展”处理性能;高可用增加机器目的在于“冗余”处理单元 。</strong></p>
<p>通过冗余增强了可用性，但同事也带来了复杂性。</p>
<ul>
<li><p><strong>计算高可用</strong></p>
</li>
<li><p><strong>存储高可用</strong></p>
<p>对于需要存储数据的系统来说，整个系统的高可用设计关键点和难点就在于“存储高可用”。存储与计算相比，有一个本质上的区别: 将数据从一台机器搬到到另一台机器，需要经过线路<br>进行传输 。线路传输的速度是毫秒级别，同一机房内部能够做到几毫秒;分布在不同地方的机房，传输耗时需要几十甚至上百毫秒。例如，从广州机房到北京机房，稳定情况<br>下 ping 延时大约是 50ms ，不稳定情况下可能达到 1s 甚至更多。</p>
<p>综合分析，无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题;但如果完全<br>不做冗余，系统的整体高可用又无法保证，所以<strong>存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响 。</strong></p>
</li>
<li><p>高可用状态决策</p>
<p>无论是计算高可用还是存储高可用，其基础都是“ 状态决策 ”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。如果状态决策本身都是有错误或者有偏差的，那么后续的任何行动和处理无论多么完美也都没有意义和价值。但在具体实践的过程中，恰好存在一个本质的矛盾: 通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。</p>
<ol>
<li>独裁式</li>
<li>协商式</li>
<li>民主式</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>可扩展性</strong></p>
<p>可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。<br>由于软件系统固有的多变性，新的需求总会不断提出来，因此可扩展性显得尤其重要。在软件开发领域，面向对象思想的提出，就是为了解决可扩展性带来的问题;后来的设计模<br>式，更是将可扩展性做到了极致。得益于设计模式的巨大影响力，几乎所有的技术人员对于可扩展性都特别重视。<br>设计具备良好可扩展性的系统，有两个基本条件: 正确预测变化 、 完美封装变化 。但要达成这两个条件，本身也是一件复杂的事情。</p>
<ol>
<li><strong>预测变化</strong><ul>
<li>不能对每个设计点都考虑可扩展性</li>
<li>不能完全不考虑可扩展性</li>
<li>所有的预测都存在出错的可能性</li>
</ul>
</li>
<li><p><strong>应对变化</strong></p>
<p>将”变化“封装在一个”变化层”，将不变的部分封装在一个独立的“稳定层”。无论是变化层依赖稳定层，还是稳定层依赖变化层都是可以的，需要根据具体业务情况来设计。</p>
<ul>
<li>系统需要拆分出变化层和稳定层</li>
<li>需要设计变化层和稳定层之间的接口</li>
</ul>
</li>
</ol>
<p>设计模式的核心就是，封装变化，隔离可变性。</p>
</li>
<li><p><strong>低成本</strong></p>
<p>低成本给架构设计带来的复杂度主要体现在，往往只有“创新”才能达到低成本的目标。。这里的“创新”既包括开创一个全新的技术领域(这个要求对绝大部分公司太高)，也包括引入新技术，如果没有找到能够解决自己问题的新技术，那么就真的需要自己创造新技术了。</p>
</li>
<li><p><strong>安全</strong></p>
<p>安全本身是一个庞大而又复杂的技术领域，并且一旦出问题，对业务和企业形象影响非常大。</p>
<ul>
<li><p>功能安全</p>
<p>从实现的角度来看，功能安全更多地是和具体的编码相关，与架构关系不大。</p>
</li>
<li><p>架构安全</p>
<p>如果说功能安全是“防小偷”，那么 架构安全就是“防强盗” 。强盗会直接用大锤将门砸开，或者用炸药将围墙炸倒;小偷是偷东西，而强盗很多时候就是故意搞破坏，对系统的影响也大得多。因此架构设计时需要特别关注架构安全，尤其是互联网时代，理论上来说系统部署在互联网上时，全球任何地方都可以发起攻击。</p>
</li>
</ul>
</li>
<li><p><strong>规模</strong></p>
<p>规模带来复杂度的主要原因就是“量变引起质变” ，当数量超过一定的阈值后，复杂度会发生质的变化。</p>
<ol>
<li>功能越来越多，导致复杂度指数级上升</li>
<li>数据越来越多，系统复杂度发生质变</li>
</ol>
</li>
</ul>
<h2 id="架构设计三原则"><a href="#架构设计三原则" class="headerlink" title="架构设计三原则"></a>架构设计三原则</h2><ol>
<li><p><strong>合适原则</strong></p>
<p>合适原则宣言：“合适优于业界领先”。</p>
<p>真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。这也是很多 BAT 出来的架构师到了小公司或者创业团队反而做不出成绩的原因，因为没有了大公司的平台、资源、积累，只是生搬硬套大公司的做法，失败的概率非常高。</p>
</li>
<li><p><strong>简单原则</strong></p>
<p>简单原则宣言：“简单优于复杂”。</p>
<p>软件领域的复杂性体现在两个方面：</p>
<ul>
<li><p>结构的复杂性</p>
<p>结构复杂的系统几乎毫无例外具备两个特点：</p>
<p>1）组成复杂系统的组件数量更多</p>
<p>2）同时这些组件之间的关系也更加复杂</p>
</li>
<li><p>逻辑的复杂性</p>
</li>
</ul>
</li>
<li><p><strong>演化原则</strong></p>
<p>演化原则宣言：“演化优于一步到位”。</p>
<ul>
<li>首先 ，设计出来的架构要满足当时的业务需要。</li>
<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐晚上。</li>
<li>第三，当业务发生变化时，架构需要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等却可以在新架构中延续。</li>
</ul>
<p>架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全，或者盲目照搬大公司的做法。应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架<br>构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。<br>即使是大公司的团队，在设计一个新系统的架构时，也需要遵循演化的原则，而不应该认为团队人员多、资源多，不管什么系统上来就要一步到位，因为业务的发展和变化是很快<br>的，不管多牛的团队，也不可能完美预测所有的业务发展和变化路径。</p>
<p>合适优于先进&gt;演化优于一步到位&gt;简单优于复杂。</p>
</li>
</ol>
<h2 id="架构设计流程"><a href="#架构设计流程" class="headerlink" title="架构设计流程"></a>架构设计流程</h2><ol>
<li>识别复杂度</li>
<li>设计备选方案</li>
<li>评估和选择备选方案</li>
<li>详细方案设计</li>
</ol>
<h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><p>在具体的实践过程中，为了更快、更好地设计出优秀的架构，除了掌握这些基础知识外，还需要掌握业界已经成熟的各种架构模式。大部分情况下，我们做架构设计主要都是基于已有的成熟模式，结合业务和团队的具体情况，进行一定的优化或者调整;即使少部分情况我们需要进行较大的创新，前提也是需要对已有的各种架构模式和技术非常熟悉。</p>
<h3 id="高性能架构模式"><a href="#高性能架构模式" class="headerlink" title="高性能架构模式"></a>高性能架构模式</h3><h4 id="高性能数据库集群"><a href="#高性能数据库集群" class="headerlink" title="高性能数据库集群"></a>高性能数据库集群</h4><p>高性能数据库集群的第一种方式是 “ 读写分离 ” ，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力;第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。</p>
<h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>读写分离原理</p>
<p>读写分离的基本原理是将数据库读写操作分散到不同的节点上 ，下面是其基本架构图。</p>
<p>读写分离的基本实现是：</p>
<ul>
<li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li>
<li>数据库主机负责读写操作，从机只负责读操作</li>
<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</li>
<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li>
</ul>
<p>读写分离的实现逻辑并不复杂，但有两个细节点将引入设计复杂度: 主从复制延迟和分配机制 。</p>
<p><strong>复制延迟</strong></p>
<p>主从复制延迟会带来一个问题:如果业务服务器将数据写入到数据库主服务器后立刻( 1 秒内)进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。</p>
<p>解决主从复制延迟的集中常见的方法：</p>
<ol>
<li>写操作后的读操作指定发给数据库主服务器</li>
<li>读从机失败后再读一次主机</li>
<li>关键业务读写操作全部指向主机，非关键业务采用读写分离。</li>
</ol>
<p><strong>分配机制</strong></p>
<p>将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：程序代码封装和中间件封装。</p>
<ol>
<li><p>程序代码封装</p>
<p>程序代码封装指在代码中抽象一个数据访问层，实现读写操作分离和数据库服务器连接的管理</p>
</li>
<li><p>中间件封装</p>
<p>中间件封装指的是独立一套系统出来，实现读写操作和数据库服务器连接的管理。中间件对业务服务器提供SQL兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。</p>
</li>
</ol>
<p>读写分离分散了数据库读写操作的压力，但没有分散存储压力，当数据量达到千万甚至上亿条的时候，单台数据库服务器的存储能力会成为系统的瓶颈，主要体现在以下几个方面：</p>
<ul>
<li>数据量太大，读写的性能会下降，即使有索引，索引也会变得恨到，性能同样会下将。</li>
<li>数据文件会变得很大，数据库备份和恢复费需要耗费很长时间。</li>
<li>数据文件越大，极端情况下丢失数的风险越高。</li>
</ul>
<h5 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h5><p><strong>业务分库</strong></p>
<p>业务分库指的是按照业务模块将数据分散到不同的数据库服务器。 例如，一个简单的电商网站，包括用户、商品、订单三个业务模块，我们可以将用户数据、商品数据、订单数据分开放到三台不同的数据库服务器上，而不是将所有数据都放在一台数据库服务器上。</p>
<p>虽然业务分库能够分散存储和访问压力，但同时也带来了新的问题。</p>
<ol>
<li><p>join操作问题</p>
<p>业务分库后，原本在同一个数据库中的表分散到不同的数据库表中，导致无法使用SQL的join查询。</p>
</li>
<li><p>事务问题</p>
<p>原本在同一个数据库中不同的表可以在用一个事务中修改，业务分库后，表分散到不同的数据库中，无法通过事务统一修改。虽然数据库厂商提供了一些分布式事务的解决方案，但性能实在太低，与高性能存储的目标是相违背的。</p>
</li>
<li><p>成本问题</p>
<p>业务分库同时也带来了成本的代价，本来 1 台服务器搞定的事情，现在要 3 台，如果考虑备份，那就是 2 台变成了 6 台。</p>
</li>
</ol>
<p><strong>分表</strong></p>
<p>将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。</p>
<p>单表数据拆分有两种方式：<strong>垂直分表和水平分表</strong></p>
<h4 id="高性能NoSQL"><a href="#高性能NoSQL" class="headerlink" title="高性能NoSQL"></a>高性能NoSQL</h4><p>关系数据库存在以下缺点：</p>
<ul>
<li>关系数据库存储的是行为记录，无法存储数据结构</li>
<li>关系数据库的schema扩展很不方便</li>
<li>关系数据库在大数据场景下I/O较高</li>
<li>关系数据库的全文搜索功能较弱</li>
</ul>
<p>针对上述问题，分别</p>
<p>针对上述问题，分别诞生了不同的 NoSQL 解决方案，这些方案与关系数据库相比，在某些应用场景下表现更好。但世上没有免费的午餐， NoSQL 方案带来的优势，本质上是牺牲ACID中的某个或者某几个特性， 因此我们不能盲目地迷信NoSQL是银弹，而应该将NoSQL作为SQL的一个有力补充 ，NoSQL != No SQL，而是NoSQL = Not Only SQL。<br>常见的 NoSQL 方案分为 4 类。</p>
<ul>
<li>K-V存储:解决关系数据库无法存储数据结构的问题，以Redis为代表。</li>
<li>文档数据库:解决关系数据库强schema约束的问题，以MongoDB为代表。</li>
<li>列式数据库:解决关系数据库大数据场景下的I/O问题，以HBase为代表。</li>
<li>全文搜索引擎:解决关系数据库的全文搜索性能问题，以Elasticsearch为代表。</li>
</ul>
<h4 id="高性能缓存架构"><a href="#高性能缓存架构" class="headerlink" title="高性能缓存架构"></a>高性能缓存架构</h4><p>缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。</p>
<p>缓存的架构设计要点：</p>
<ul>
<li><p>缓存穿透</p>
<p>缓存穿透是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。</p>
</li>
<li><p>缓存雪崩</p>
<p>缓存雪崩是指当缓存失效（过期）后引起系统性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算,这个处理步骤<br>耗时几十毫秒甚至上百毫秒。而对于一个高并发的业务系统来说,几百毫秒内可能会接到几百上千个请求。由于旧的缓存已经被清除,新的缓存还未生成,并且处理这些请求的线程都不知道另外有一个线程正在生成缓存,因此所有的请求都会去重新生成缓存,都会去访问存储系统,从而对存储系统造成巨大的性能压力。这些压力又会拖慢整个系统,严重的会造成数据库宕机,从而形成一系列连锁反应,造成整个系统崩溃。</p>
</li>
<li><p>缓存热点</p>
<p>虽然缓存系统本身的性能比较高,但对于一些特别热点的数据,如果大部分甚至所有的业务请求都命中同一份缓存数据,则这份数据所在的缓存服务器的压力也很大。例如,某明星微博发布 “ 我们 ” 来宣告恋爱了,短时间内上千万的用户都会来观。<br>缓存热点的解决方案就是复制多份缓存副本,将请求分散到多个缓存服务器上,减轻缓存热点导致的单台缓存服务器压力 。</p>
</li>
</ul>
<h4 id="单服务器高性能模式"><a href="#单服务器高性能模式" class="headerlink" title="单服务器高性能模式"></a>单服务器高性能模式</h4><p>站在架构师的角度，需要特别关注高性能架构的设计。高性能架构设计主要集中在两方面：</p>
<ul>
<li>尽量提升单服务器的性能，将单服务器的性能发挥到极致</li>
<li>如果单服务器无法支撑性能，设计服务器集群方案</li>
</ul>
<p>除了以上两点，最终系统能否实现高性能，还和具体的实现及编码相关。但架构设计是高性能的基础，如果架构设计没有做到高性能，则后面的具体实现和编码能提升的空间是有限的。形象地说，架构设计决定了系统性能的上限，实现细节决定了系统性能的下限。</p>
<p>单服务器高性能的关键之一就是服务器采取的并发模型，并发模型有如下两个关键设计点：</p>
<ul>
<li>服务器如何管理连接</li>
<li>服务器如何处理请求。</li>
</ul>
<p>以上两个设计点最终都和操作系统的I/O模型及进程模型相关。</p>
<ul>
<li>I/O模型：阻塞、非阻塞、同步、异步</li>
<li>进程模型：单进程、多进程、多线程</li>
</ul>
<h5 id="PPC与TPC"><a href="#PPC与TPC" class="headerlink" title="PPC与TPC"></a>PPC与TPC</h5><p>PPC是Process Per Connection的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的UNIX网络服务器所采用的模型。基本的流程图是：</p>
<p>TPC 是 Thread Per Connection 的缩写,其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比,线程更轻量级,创建线程的消耗比进程要少得多;同时多线程是共享进程内存空间的,线程通信相比进程通信更简单。因此, TPC 实际上是解决或者弱化了 PPC fork 代价高的问题和父子进程通信复杂的问题。</p>
<h5 id="Reactor与Proactor"><a href="#Reactor与Proactor" class="headerlink" title="Reactor与Proactor"></a>Reactor与Proactor</h5><p>单服务器高性能的PPC和TPC模式，它们的优点是实现简单，缺点是都无法支撑高并发的场景。</p>
<p><strong>Reactor</strong></p>
<p>PPC 模式最主要的问题就是每个连接都要创建进程(为了描述简洁,这里只以 PPC 和进程为例,实际上换成 TPC 和线程,原理是一样的),连接结束后进程就销毁了,这样做其实是很大的浪费。为了解决这个问题,一个自然而然的想法就是资源复用,即不再单独为每个连接创建进程,而是创建一个进程池,将连接分配给进程,一个进程可以处理多个连接的业务。<br>引入资源池的处理方式后,会引出一个新的问题:进程如何才能高效地处理多个连接的业务?当一个连接一个进程时,进程可以采用 “read -&gt; 业务处理 -&gt; write” 的处理流程,如果当前连接没有数据可以读,则进程就阻塞在 read 操作上。这种阻塞的方式在一个连接一个进程的场景下没有问题,但如果一个进程处理多个连接,进程阻塞在某个连接的 read 操作上,此时即使其他连接有数据可读,进程也无法去处理,很显然这样是无法做到高性能的。<br>解决这个问题的最简单的方式是将 read 操作改为非阻塞,然后进程不断地轮询多个连接。这种方式能够解决阻塞的问题,但解决的方式并不优雅。首先,轮询是要消耗 CPU 的;其次,如果一个进程处理几千上万的连接,则轮询的效率是很低的。<br>为了能够更好地解决上述问题,很容易可以想到,只有当连接上有数据的时候进程才去处理,这就是 I/O 多路复用技术的来源。</p>
<p>I/O多路复用技术归纳起来有两个关键实现点：</p>
<ul>
<li>当多条链接共用一个阻塞对象后，进程只需要在一个是阻塞对象上等待，而无序再轮询所连接，常见的实现方式有select、epoll、kqueue等。</li>
<li>当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。</li>
</ul>
<p>I/O 多路复用结合线程池,完美地解决了 PPC 和 TPC 的问题,而且 “ 大神们 ” 给它取了一个很牛的名字: Reactor ,中文是 “ 反应堆 ” 。联想到 “ 核反应堆 ” ,听起来就很吓人,实际上这里<br>的“反应”不是聚变、裂变反应的意思,而是“ 事件反应 ”的意思,可以通俗地理解为“ 来了一个事件我就有相应的反应 ”,这里的“我”就是Reactor,具体的反应就是我们写的代码, Reactor 会根据事件类型来调用相应的代码进行处理。 Reactor 模式也叫 Dispatcher 模式(在很多开源的系统里面会看到这个名称的类,其实就是实现 Reactor 模式的),更加贴近模式本身的含义,即 I/O 多路复用统一监听事件,收到事件后分配( Dispatch )给某个进程。<br>Reactor 模式的核心组成部分包括 Reactor 和处理资源池(进程池或线程池),其中 Reactor 负责监听和分配事件,处理资源池负责处理事件。</p>
<p><strong>Proactor</strong></p>
<p>Reactor 是非阻塞同步网络模型,因为真正的 read 和 send 操作都需要用户进程同步操作。这里的 “ 同步 ” 指用户进程在执行 read 和 send 这类 I/O 操作的时候是同步的,如果把 I/O 操作改为异步就能够进一步提升性能,这就是异步网络模型 Proactor 。<br>Proactor 中文翻译为 “ 前摄器 ” 比较难理解,与其类似的单词是 proactive ,含义为 “ 主动的 ” ,因此我们照猫画虎翻译为 “ 主动器 ” 反而更好理解。 Reactor 可以理解为 “ 来了事件我通知你,你来处理”,而Proactor可以理解为“ 来了事件我来处理,处理完了我通知你 ”。这里的“我”就是操作系统内核,“事件”就是有新连接、有数据可读、有数据可写的这些I/O事件, “ 你 ” 就是我们的程序代码。</p>
<h4 id="高性能负载均衡"><a href="#高性能负载均衡" class="headerlink" title="高性能负载均衡"></a>高性能负载均衡</h4><p>单服务器无论如何优化,无论采用多好的硬件,总会有一个性能天花板,当单服务器的性能无法满足业务需求时,就需要设计高性能集群来提升系统整体的处理性能。<br>高性能集群的本质很简单,通过增加更多的服务器来提升系统整体的计算能力。由于计算本身存在一个特点:同样的输入数据和逻辑,无论在哪台服务器上执行,都应该得到相同的<br>输出。因此高性能集群设计的复杂度主要体现在任务分配这部分,需要设计合理的任务分配策略,将计算任务分配到多台服务器上执行。<br>高性能集群的复杂性主要体现在需要增加一个任务分配器,以及为任务选择一个合适的任务分配算法 。对于任务分配器,现在更流行的通用叫法是“负载均衡器”。但这个名称有一定的误导<br>性,会让人潜意识里认为任务分配的目的是要保持各个计算单元的负载达到均衡状态。而实际上任务分配并不只是考虑计算单元的负载均衡,不同的任务分配算法目标是不一样的,<br>有的基于负载考虑,有的基于性能(吞吐量、响应时间)考虑,有的基于业务考虑。考虑到 “ 负载均衡 ” 已经成为了事实上的标准术语,这里我也用 “ 负载均衡 ” 来代替 “ 任务分配 ” ,但请你时刻记住, 负载均衡不只是为了计算单元的负载达到均衡状态 。</p>
<h5 id="分类及架构"><a href="#分类及架构" class="headerlink" title="分类及架构"></a>分类及架构</h5><p>常见的负载均衡系统包括3种：DNS负载均衡、硬件负载均衡和软件负载均衡。</p>
<p><strong>DNS负载均衡</strong></p>
<p>DNS 是最简单也是最常见的负载均衡方式,一般用来实现地理级别的均衡。例如,北方的用户访问北京的机房,南方的用户访问深圳的机房。 DNS 负载均衡的本质是 DNS 解析同一个域名可以返回不同的 IP 地址。例如,同样是 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ,北方用户解析后获取的地址是 61.135.165.224 (这是北京机房的 IP ),南方用户解析后获取的地址是 14.215.177.38 (这是深圳机房的 IP )。</p>
<p><strong>硬件负载均衡</strong></p>
<p>硬件负载均衡是通过单独的硬件设备来实现负载均衡功能,这类设备和路由器、交换机类似,可以理解为一个用于负载均衡的基础网络设备。目前业界典型的硬件负载均衡设备有两款: F5 和 A10 。这类设备性能强劲、功能强大,但价格都不便宜,一般只有 “ 土豪 ” 公司才会考虑使用此类设备。普通业务量级的公司一是负担不起,二是业务量没那么大,用这些设备也是浪费。</p>
<p><strong>软件负载均衡</strong></p>
<p>软件负载均衡通过负载均衡软件来实现负载均衡功能,常见的有Nginx和LVS,其中Nginx是软件的7层负载均衡,LVS是Linux内核的4层负载均衡。4层和7层的区别就在于 协议 和 灵活性 ,Nginx支持HTTP、E-mail协议;而LVS是4层负载均衡,和协议无关,几乎所有应用都可以做,例如,聊天、数据库等。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>负载均衡算法数量较多,而且可以根据一些业务特性进行定制开发,抛开细节上的差异,根据算法期望达到的目的,大体上可以分为下面几类。</p>
<ul>
<li>任务平分类：负载均衡系统将收到的任务平均分配给服务器进行处理,这里的“平均”可以是绝对数量的平均,也可以是比例或者权重上的平均。<ul>
<li>轮询</li>
<li>加权轮询</li>
</ul>
</li>
<li>负载均衡类：负载均衡系统根据服务器的负载来进行分配,这里的负载并不一定是通常意义上我们说的“CPU负载”,而是系统当前的压力,可以用CPU负载来衡量,也可以用连接数、 I/O 使用率、网卡吞吐量等来衡量系统的压力。<ul>
<li>负载最低优先</li>
</ul>
</li>
<li>性能最优类：负载最低优先类算法是站在服务器的角度来进行分配的,而性能最优优先类算法则是站在客户端的角度来进行分配的,优先将任务分配给处理速度最快的服务器,通过这种方式达到最快响应客户端的目的。</li>
<li>Hash类：负载均衡系统根据任务中的某些关键信息进行 Hash 运算,将相同 Hash 值的请求分配到同一台服务器上,这样做的目的主要是为了满足特定的业务需求。<ul>
<li>源地址Hash</li>
<li>ID Hash</li>
</ul>
</li>
</ul>
<h3 id="高可用架构模式"><a href="#高可用架构模式" class="headerlink" title="高可用架构模式"></a>高可用架构模式</h3><h4 id="高可用存储架构"><a href="#高可用存储架构" class="headerlink" title="高可用存储架构"></a>高可用存储架构</h4><p>存储高可用方案的本质都是通过将数据复制到多个存储设备,通过数据冗余的方式来实现高可用,其复杂性主要体现在如何应对复制延迟和中断导致的数据不一致问题。</p>
<h5 id="双机架构"><a href="#双机架构" class="headerlink" title="双机架构"></a>双机架构</h5><p>常见的高可用存储架构有主备、主从、主主、集群、分区,每一种又可以根据业务的需求进行一些特殊的定制化功能,由此衍生出更多的变种。</p>
<ul>
<li><p>主备复制</p>
<p>主备复制是最常见也是最简单的一种存储高可用方案,几乎所有的存储系统都提供了主备复制的功能,例如 MySQL 、Redis 、 MongoDB 等。</p>
</li>
<li><p>主从复制</p>
<p>主从复制和主备复制只有一字之差, “ 从 ” 意思是 “ 随从、仆从 ” , “ 备 ” 的意思是备份。我们可以理解为仆从是要帮主人干活的,这里的干活就是承担 “ 读 ” 的操作。也就是说,主机负责读写操作,从机只负责读操作,不负责写操作。</p>
</li>
<li><p>双机切换</p>
<p>主备复制和主从复制方案存在两个共性的问题：</p>
<ul>
<li>主机故障后，无法进行写操作</li>
<li>如果主机无法恢复，需要人工指定新的主机角色</li>
</ul>
<p>双机切换就是为了解决这两个问题而产生的,包括主备切换和主从切换两种方案。简单来说,这两个方案就是在原有方案的基础上增加 “ 切换 ” 功能,即系统自动决定主机角色,并完<br>成角色切换。</p>
</li>
<li><p>主主复制</p>
<p>主主复制指的是两台机器都是主机,互相将数据复制给对方,客户端可以任意挑选其中一台机器进行读写操作,</p>
</li>
</ul>
<h5 id="集群和分区"><a href="#集群和分区" class="headerlink" title="集群和分区"></a>集群和分区</h5><p><strong>数据集群</strong></p>
<p>主备、主从、主主架构本质上都有一个隐含的假设:主机能够存储所有数据,但主机本身的存储和处理能力肯定是有极限的。</p>
<p>简单来说,集群就是多台机器组合在一起形成一个统一的系统,这里的 “ 多台 ” ,数量上至少是 3 台;相比而言,主备、主从都是 2 台机器。根据集群中机器承担的不同角色来划分,集群可以分为两类:数据集中集群、数据分散集群。</p>
<ol>
<li><p>数据集中集群</p>
<p>数据集中集群与主备、主从这类架构相似,我们也可以称数据集中集群为 1 主多备或者 1 主多从。无论是 1 主 1 从、 1 主 1 备,还是 1 主多备、 1 主多从,数据都只能往主机中写,而读操作可以参考主备、主从架构进行灵活多变。</p>
</li>
<li><p>数据分散集群</p>
<p>数据分散集群指多个服务器组成一个集群,每台服务器都会负责存储一部分数据;同时,为了提升硬件利用率,每台服务器又会备份一部分数据。</p>
</li>
</ol>
<p><strong>数据分区</strong></p>
<p>前面我们讨论的存储高可用架构都是基于硬件故障的场景去考虑和设计的,主要考虑当部分硬件可能损坏的情况下系统应该如何处理,但对于一些影响非常大的灾难或者事故来说,有可能所有的硬件全部故障。例如,新奥尔良水灾、美加大停电、洛杉矶大地震等这些极端灾害或者事故,可能会导致一个城市甚至一个地区的所有基础设施瘫痪,这种情况下基于硬件故障而设计的高可用架构不再适用,我们需要基于地理级别的故障来设计高可用架构,这就是数据分区架构产生的背景。</p>
<p>数据分区指将数据按照一定的规则进行分区,不同分区分布在不同的地理位置上,每个分区存储一部分数据,通过这种方式来规避地理级别的故障所造成的巨大影响。采用了数据分区的架构后,即使某个地区发生严重的自然灾害或者事故,受影响的也只是一部分数据,而不是全部数据都不可用;当故障恢复后,其他地区备份的数据也可以帮助故障地区快速恢复业务。</p>
<p>设计一个良好的数据分区架构，需要从多个方面去考虑。</p>
<ol>
<li>数据量</li>
<li>分区规则</li>
<li>复制规则</li>
</ol>
<h4 id="业务高可用的保障：异地多活架构"><a href="#业务高可用的保障：异地多活架构" class="headerlink" title="业务高可用的保障：异地多活架构"></a>业务高可用的保障：异地多活架构</h4><p>无论是高可用计算架构,还是高可用存储架构,其本质的设计目的都是为了解决部分服务器故障的场景下,如何保证系统能够继续提供服务。但在一些极端场景下,有可能所有服务器都出现故障。例如,典型的有机房断电、机房火灾、地震、水灾 …… 这些极端情况会导致某个系统所有服务器都故障,或者业务整体瘫痪,而且即使有其他地区的备份,把备份业务系统全部恢复到能够正常提供业务,花费的时间也比较长,可能是半小时,也可能是 12 小时。因为备份系统平时不对外提供服务,可能会存在很多隐藏的问题没有发现。如果业务期望达到即使在此类灾难性故障的情况下,业务也不受影响,或者在几分钟内就能够很快恢复,那么就需要设计异地多活架构。</p>
<p><strong>应用场景</strong></p>
<p>顾名思义,异地多活架构的关键点就是异地、多活,其中异地就是指地理位置上不同的地方,类似于 “ 不要把鸡蛋都放在同一篮子里 ” ;多活就是指不同地理位置上的系统都能够提供业务服务,这里的 “ 活 ” 是活动、活跃的意思。判断一个系统是否符合异地多活,需要满足两个标准:</p>
<ul>
<li>正常情况下，用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务。</li>
<li>某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务。</li>
</ul>
<p><strong>架构模式</strong></p>
<ul>
<li>同城异区</li>
<li>跨城异地</li>
<li>跨国异地</li>
</ul>
<h3 id="可扩展架构模式"><a href="#可扩展架构模式" class="headerlink" title="可扩展架构模式"></a>可扩展架构模式</h3><p>软件系统与硬件和建筑系统最大的差异在于软件是可扩展的,一个硬件生产出来后就不会再进行改变、一个建筑完工后也不会再改变其整体结构。例如,一颗 CPU 生产出来后装到一台 PC 机上,不会再返回工厂进行加工以增加新的功能;金字塔矗立千年历经风吹雨打,但其现在的结构和当时建成完工时的结构并无两样。相比之下,软件系统就完全相反,如果一个软件系统开发出来后,再也没有任何更新和调整,反而说明了这套软件系统没有发展、没有生命力。真正有生命力的软件系统,都是在不断迭代和发展的,典型的如 Windows 操作系统,从 Windows 3.0 到 Windows 95 到 Windows XP ,直到现在的 Windows 10 ,一直在跟着技术的发展而不断地发展。</p>
<h4 id="可扩展架构的基本思想和模式"><a href="#可扩展架构的基本思想和模式" class="headerlink" title="可扩展架构的基本思想和模式"></a>可扩展架构的基本思想和模式</h4><p><strong>可扩展的基本思想</strong></p>
<p>可扩展性架构的设计方法很多，但万变不离其宗，所有的可扩展性架构设计，背后的基本思想都可以总结为一个字：<strong>拆</strong></p>
<p>拆，就是将原来大一统的系统拆分成多个规模小的部分，扩展时只修改其中一个部分即可，无须整个系统到处都改，通过这种方式来减少改动范围，降低改动风险。</p>
<p>按照不同的思路来拆分软件系统，就会得到不同的架构。常见的拆分思路有如下三种：</p>
<ul>
<li>面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分</li>
<li>面向服务拆分：将系统提供的服务拆分，每个服务作为一部分</li>
<li>面向功能拆分：将系统提供的功能拆分，每个功能作为一部分</li>
</ul>
<p>理解这三种思路的关键就在于如何理解“流程”、“服务”、“功能”三者的联系和区别。从范围上来看，从大到小依次为：流程&gt;服务&gt;功能。</p>
<p>不同的拆分方式，本质上决定了系统的扩展方式。不同的拆分方式，将得到不同的系统架构，典型的可扩展系统架构有：</p>
<ul>
<li>面向流程拆分：分层架构</li>
<li>面向服务拆分：SOA、微服务</li>
<li>面向功能拆分：微内核架构</li>
</ul>
<h4 id="传统的可扩展架构模式：分层架构和SOA"><a href="#传统的可扩展架构模式：分层架构和SOA" class="headerlink" title="传统的可扩展架构模式：分层架构和SOA"></a>传统的可扩展架构模式：分层架构和SOA</h4><p><strong>分层架构</strong></p>
<p>分层架构是很常见的架构模式，也加N层架构，通常情况下，N至少是2层。例如，C/S架构、B/S脚骨。常见的是3层架构（例如，MVC、MVP架构），4层架构，5层脚骨的比较少见，一般是比较复杂的系统才会达到或者超过5层，比如操作系统内核架构。</p>
<p>按照分层架构进行设计时，根据不同的划分维度和对象，可以得到多种不同的分层架构。</p>
<ol>
<li><p>C/S架构、B/S架构</p>
<p>划分的对象是整个业务系统,划分的维度是用户交互,即将和用户交互的部分独立为一层,支撑用户交互的后台作为另外一层</p>
</li>
<li><p>MVC架构、MVP架构</p>
<p>划分的对象是单个业务子系统,划分的维度是职责,将不同的职责划分到独立层,但各层的依赖关系比较灵活。</p>
</li>
<li><p>逻辑分层架构</p>
<p>划分的对象可以是单个业务子系统,也可以是整个业务系统,划分的维度也是职责。虽然都是基于职责划分,但逻辑分层架构和 MVC 架构、 MVP 架构的不同点在于,逻辑分层架构中的层是自定向下依赖的。典型的有操作系统内核架构、TCP/IP架构。</p>
</li>
</ol>
<p>无论采取何种分层维度，分层架构设计最核心的一点就是需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构，这也是分层不能太多的原因。</p>
<p>分层架构之所以能够较好地支撑系统扩展，本质在于隔离关注点，即每个层中的组件只会处理本层的逻辑。但是，分层时要保证层与层之间的依赖是稳定的，才能真正支撑快速扩展。</p>
<p>分层结构的另外一个特点就是层层传递，也就是说一旦分层确定，整个业务流程是按照层进行依次传递的，不能 在层之间进行跳跃。这种约束的好处在于强制将分层依赖限定为两两依赖，降低了整体系统复杂度，但代价就是冗余，也就是说，不管这个业务多么简单，每层都必须要参与处理。langfei</p>
<p>分层架构另外一个典型的缺点就是性能，因为每一次l业务请求都需要穿越所有的架构分层，有一些事情是多余的，多少都会有一些性能的浪费。</p>
<p><strong>SOA</strong></p>
<p>SOA的全称是 Service Oriented Architecture，中文翻译为“面向服务的架构”。</p>
<p>SOA提出了3个关键概念</p>
<ul>
<li><p>服务</p>
<p>所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。</p>
</li>
<li><p>ESB</p>
<p>ESB的全称是 Enterprise Service Bus，中文翻译为“企业服务总线”。从名字就可以看出，ESB参考了计算机总线的概念。ESB将企业中各个不同的服务连接在一起。</p>
</li>
<li><p>松耦合</p>
<p>松耦合的目的是减少各个服务间的依赖和互相影响。</p>
</li>
</ul>
<h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>微服务是一种和SOA相似但本质上不同架构理念。</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>SOA</th>
<th>微服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务粒度</td>
<td>粗</td>
<td>细</td>
</tr>
<tr>
<td>服务通信</td>
<td>重量级，ESB</td>
<td>轻量级，例如，HTTP RESTful RPC</td>
</tr>
<tr>
<td>服务交付</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>应用场景</td>
<td>企业级</td>
<td>互联网</td>
</tr>
</tbody>
</table>
<p>Martin Fowle在他的微服务文章中，做了很好地提炼</p>
<blockquote>
<p>In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery.</p>
</blockquote>
<p><strong>微服务的陷阱</strong></p>
<ol>
<li>服务划分过膝，服务间关系复杂</li>
<li>服务数量太多，团队效率急剧下降</li>
<li>调用链太长，性能下降</li>
<li>调用链太长，问题定位困难</li>
<li>没有自动化支撑，无法快速交付</li>
<li>没有服务治理，微服务数量多了后台管理混乱</li>
</ol>
<h4 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h4><p>微内核脚骨（Microkernel Architecture），也被称为插件化架构（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品的应用。例如Eclipse这类IDE软件、UNIX这类操作系统、淘宝APP这类客户端软件。</p>
<p><strong>基本架构</strong></p>
<p>微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑。</p>
<p>微内核的基本架构示意图如下：</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/架构/" rel="tag"># 架构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/25/编程范式/" rel="next" title="编程范式">
                <i class="fa fa-chevron-left"></i> 编程范式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/25/Linux内核（学习笔记）/" rel="prev" title="深入理解Linux内核">
                深入理解Linux内核 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Utur</p>
              <div class="site-description motion-element" itemprop="description">木龟想做一个哈皮程序猿。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Turtle-knight" title="GitHub &rarr; https://github.com/Turtle-knight" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:turtle.mugui@gmail.com" title="E-Mail &rarr; mailto:turtle.mugui@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://plus.google.com/木龟" title="Google &rarr; https://plus.google.com/木龟" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义架构"><span class="nav-number">1.</span> <span class="nav-text">定义架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构设计的真正目的"><span class="nav-number">2.</span> <span class="nav-text">架构设计的真正目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂度的来源"><span class="nav-number">3.</span> <span class="nav-text">复杂度的来源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构设计三原则"><span class="nav-number">4.</span> <span class="nav-text">架构设计三原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构设计流程"><span class="nav-number">5.</span> <span class="nav-text">架构设计流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构模式"><span class="nav-number">6.</span> <span class="nav-text">架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高性能架构模式"><span class="nav-number">6.1.</span> <span class="nav-text">高性能架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高性能数据库集群"><span class="nav-number">6.1.1.</span> <span class="nav-text">高性能数据库集群</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#读写分离"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">读写分离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分库分表"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">分库分表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高性能NoSQL"><span class="nav-number">6.1.2.</span> <span class="nav-text">高性能NoSQL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高性能缓存架构"><span class="nav-number">6.1.3.</span> <span class="nav-text">高性能缓存架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单服务器高性能模式"><span class="nav-number">6.1.4.</span> <span class="nav-text">单服务器高性能模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PPC与TPC"><span class="nav-number">6.1.4.1.</span> <span class="nav-text">PPC与TPC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Reactor与Proactor"><span class="nav-number">6.1.4.2.</span> <span class="nav-text">Reactor与Proactor</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高性能负载均衡"><span class="nav-number">6.1.5.</span> <span class="nav-text">高性能负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分类及架构"><span class="nav-number">6.1.5.1.</span> <span class="nav-text">分类及架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算法"><span class="nav-number">6.1.5.2.</span> <span class="nav-text">算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高可用架构模式"><span class="nav-number">6.2.</span> <span class="nav-text">高可用架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高可用存储架构"><span class="nav-number">6.2.1.</span> <span class="nav-text">高可用存储架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#双机架构"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">双机架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#集群和分区"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">集群和分区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#业务高可用的保障：异地多活架构"><span class="nav-number">6.2.2.</span> <span class="nav-text">业务高可用的保障：异地多活架构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可扩展架构模式"><span class="nav-number">6.3.</span> <span class="nav-text">可扩展架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可扩展架构的基本思想和模式"><span class="nav-number">6.3.1.</span> <span class="nav-text">可扩展架构的基本思想和模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传统的可扩展架构模式：分层架构和SOA"><span class="nav-number">6.3.2.</span> <span class="nav-text">传统的可扩展架构模式：分层架构和SOA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#微服务架构"><span class="nav-number">6.3.3.</span> <span class="nav-text">微服务架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#微内核架构"><span class="nav-number">6.3.4.</span> <span class="nav-text">微内核架构</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Utur</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
