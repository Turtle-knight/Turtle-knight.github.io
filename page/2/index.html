<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="木龟想做一个哈皮程序猿。">
<meta property="og:type" content="website">
<meta property="og:title" content="Utur的个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Utur的个人博客">
<meta property="og:description" content="木龟想做一个哈皮程序猿。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Utur的个人博客">
<meta name="twitter:description" content="木龟想做一个哈皮程序猿。">





  
  
  <link rel="canonical" href="http://yoursite.com/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Utur的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Utur的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">天天学习，好好向上</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Ubuntu快速配置工作环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Ubuntu快速配置工作环境/" class="post-title-link" itemprop="url">Ubuntu环境</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 16:42:11" itemprop="dateModified" datetime="2019-07-06T16:42:11+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Ubuntu/" itemprop="url" rel="index"><span itemprop="name">Ubuntu</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Ubuntu工作环境快速配置"><a href="#Ubuntu工作环境快速配置" class="headerlink" title="Ubuntu工作环境快速配置"></a>Ubuntu工作环境快速配置</h1><p>首先更新一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br></pre></td></tr></table></figure>
<h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><p>详情<a href="https://blog.csdn.net/JRRRJ/article/details/81082444" target="_blank" rel="noopener">https://blog.csdn.net/JRRRJ/article/details/81082444</a></p>
<p>将阿里源添加到<strong>sources.list</strong>中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure>
<p>保存退出，然后更新。</p>
<h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><p>在「软件和更新」-「附加驱动」选项卡中进行选择</p>
<h2 id="基础软件安装"><a href="#基础软件安装" class="headerlink" title="基础软件安装"></a>基础软件安装</h2><h3 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure>
<h4 id="vim-个人配置"><a href="#vim-个人配置" class="headerlink" title="vim 个人配置"></a>vim 个人配置</h4><p>.vimrc (保存在个人百度网盘快速配置Ubuntu环境文件夹)</p>
<h3 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h3><p><a href="https://blog.csdn.net/fx_yzjy101/article/details/80243710" target="_blank" rel="noopener">https://blog.csdn.net/fx_yzjy101/article/details/80243710</a></p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>
<h3 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h3><p><a href="https://blog.csdn.net/qq_15192373/article/details/81091278" target="_blank" rel="noopener">https://blog.csdn.net/qq_15192373/article/details/81091278</a></p>
<h3 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a>ipython</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ipython3</span><br></pre></td></tr></table></figure>
<h3 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h3><p>安装详情见<a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">flask官网</a></p>
<h3 id="Typora-Markdown编辑"><a href="#Typora-Markdown编辑" class="headerlink" title="Typora(Markdown编辑)"></a>Typora(Markdown编辑)</h3><p>安装详情见<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora官网</a></p>
<h3 id="Shutter-截图软件"><a href="#Shutter-截图软件" class="headerlink" title="Shutter(截图软件)"></a>Shutter(截图软件)</h3><p>详情见<a href="https://blog.csdn.net/qq_19339041/article/details/80058892" target="_blank" rel="noopener">https://blog.csdn.net/qq_19339041/article/details/80058892</a></p>
<h3 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h3><p>先卸载LibreOffice</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge libreoffice*</span><br></pre></td></tr></table></figure>
<p>下载安装访问<a href="http://www.wps.cn/product/wpslinux/" target="_blank" rel="noopener">WPS官网</a></p>
<h3 id="MySQL-amp-amp-Redis"><a href="#MySQL-amp-amp-Redis" class="headerlink" title="MySQL &amp;&amp; Redis"></a>MySQL &amp;&amp; Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure>
<h3 id="Wechat"><a href="#Wechat" class="headerlink" title="Wechat"></a>Wechat</h3><p><a href="https://www.cnblogs.com/dotnetcrazy/p/9124658.html" target="_blank" rel="noopener">Ubuntu 18.04 安装微信（Linux通用）</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Redis设计与实现（笔记）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Redis设计与实现（笔记）/" class="post-title-link" itemprop="url">Redis设计与实现（笔记）</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:21:00" itemprop="dateModified" datetime="2019-07-06T17:21:00+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis总体认识"><a href="#Redis总体认识" class="headerlink" title="Redis总体认识"></a>Redis总体认识</h2><p>Redis是一个速度非常快的非关系远程内存数据库，它不仅性能强劲，而且具有复制特性以及为解决问题而省的独一无二的数据模型。</p>
<hr>
<h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><h3 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h3><p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。</p>
<h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><p>每个sds.h/shshdr结构表示一个SDS值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">//等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/SDS.png" alt="SDS"></p>
<p>SDS遵循C字符串以空字符结尾的惯例，保存空字符串的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。<em>遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字函数库里面的函数</em></p>
<h4 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与Ｃ字符串的区别"></a>SDS与Ｃ字符串的区别</h4><ul>
<li><p><strong>常数复杂度获取字符串长度</strong></p>
<p>获取一个Ｃ字符串的长度，操作复杂度为Ｏ(N)。</p>
<p>获取一个SDS的长度复杂度为O(1)，因为SDS在len属性中记录了SDS本身的长度。</p>
<p>通过使用SDS而不是C字符串，<strong><em>确保了获取字符串长度的工作不会成为Redis的性能瓶颈。</em></strong></p>
</li>
<li><p><strong>杜绝缓冲区溢出</strong></p>
<p>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改的需求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。</p>
</li>
<li><p><strong>减少修改字符串时带来的内存重新分配次数</strong></p>
<ul>
<li><strong><em>空间预分配</em></strong>，用于优化SDS的字符串增长操作：当需要进行空间扩展时，程序不仅会为SDS分配修改时所必须要的空间，还会为SDS分配额外的未使用空间。<ul>
<li>如果对SDS进行修改之后，SDS的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性将和free属性的值相同。</li>
<li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间.。</li>
</ul>
</li>
<li><strong><em>惰性空间释放</em></strong>，用于优化SDS的字符串缩短操作：当API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。与此同时，SDS也提供了相应的API，可以在有需要时真正地释放SDS的未使用空间。所以不用担心惰性空间释放策略会造成内存浪费。通过使用惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</li>
</ul>
</li>
<li><p><strong>二进制安全</strong></p>
<p>所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。</p>
<p>通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。</p>
</li>
<li><p><strong>兼容部分C字符串</strong></p>
</li>
</ul>
<hr>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。Redis构建了自己的链表实现。链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用了链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p>
<h4 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h4><p>每个链表节点使用一个adlist.h/listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure>
<p>多个listNode可以通过prev和next指针组成双端链表。</p>
<p>使用adlist.h/list来持有链表的话，操作起来会更方便：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/链表.png" alt="链表"></p>
<p>Redis的链表实现的特性可以总结如下；</p>
<ul>
<li>双端</li>
<li>无环</li>
<li>带表头指针和表尾指针</li>
<li>带链表长度计数器</li>
<li>多态：链表节点使用void *指针来保存节点值，并且可以通过list结构的dup、match、free三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li>
</ul>
<hr>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。</p>
<p>字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。除了用来表示数据库之外，字典还是哈希键的底层实现之一。</p>
<h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>Redis字典使用的哈希表有dict.h/dictht结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size；</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>
<h5 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h5><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>(</span><br><span class="line">    	<span class="keyword">void</span> *val;</span><br><span class="line">    	<span class="keyword">uint64_t</span> u64;</span><br><span class="line">    	<span class="keyword">int64_t</span> s64;</span><br><span class="line">    )v;</span><br><span class="line">    <span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
<h5 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h5><p>Redis中的字典由dict.h/dict结构来表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx; <span class="comment">/*rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>
<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p>
<ul>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数。</li>
<li>privdata属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈细致的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(keyDup)（<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(valueDup)（<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)（<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)（<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)（<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure>
<p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/字典.png" alt="字典"></p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用<strong>MurmurHash2</strong>算法来计算键的哈希值。</p>
<h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接骑起来，这就要解决了键冲突的问题。</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/链地址.png" alt="链地址法"></p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成。<em>最终结果是将ht[0]包含所有键值对都迁移到ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</em></p>
<p>但是为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。</p>
<p>渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作摊到对字典的每个添加、删除、查找和更新操作之上，从而避免了集中式rehash而带来的庞大计算量。</p>
<hr>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表（skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O(logN)，最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树媲美，并且因为跳跃表的实现比平衡树更为简单，所以有不少程序都用跳跃表来代替平衡树。</p>
<ul>
<li><p>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</p>
</li>
<li><p>每个跳跃表节点的层高都是1至32之间的随机数</p>
</li>
<li><p>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</p>
</li>
<li><p>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</p>
</li>
</ul>
<hr>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>
<p>每个intset.h/inttset结构表示一个整数集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</em></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/整数集合.png" alt="整数集合"></p>
<p><strong>contents数组的真正类型取决于encoding属性的值</strong></p>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>当新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要进行升级（upgrade)，然后才能将新元素添加到整数集合里面。</p>
<p>升级分为三部进行：</p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的孔家你大小，并为新元素分配空间</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素继续放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>升级的好处：</p>
<ul>
<li><p>提升整数集合的灵活性，因为C语言是静态类型语言，为了避免类型错误，通常不会将两种不同类型的值放在同一个数据结构里面。</p>
</li>
<li><p>尽可能地节约内存，只在有需要的时候进行升级。</p>
</li>
</ul>
<hr>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是是小整数值，要么就是长度比较长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<p><strong>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构</strong>。一个压缩列表可以包含 任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p>
<p>压缩列表和压缩列表节点的构成</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/压缩链表及节点.png" alt="压缩列表和节点"></p>
<hr>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每个对象都用到了至少一种数据结构。</p>
<p><strong>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，可以针对不同的使用场景，为对像设置多种不同的数据结构实现，从而优化对象在不同场景的使用效率。</strong></p>
<p><strong>Redis的对象系统还实现了基于引用技术技术的内存回收机制</strong>，当程序不再使用某个对象的时候，这个对象所占用的内存就会被释放；另外，<em>Redis还通过引用技术技术实现了对象共享机制</em>，在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p>
<p><em>Redis的对象带有访问时间记录信息。</em></p>
<p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据结构有关的三个属性分别是type属性、encoding属性和ptr属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4'</span></span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><ol>
<li><p><strong>字符串对象</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/字符串对象编码转换.png" alt="字符串对象转换"></p>
</li>
</ol>
<ol start="2">
<li><p><strong>列表对象</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/列表对象编码转换.png" alt="列表对象编码转换"></p>
</li>
</ol>
<ol start="3">
<li><p><strong>哈希对象</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/哈希对象编码转换.png" alt="哈希对象编码转换"></p>
</li>
</ol>
<ol start="4">
<li><p><strong>集合对象</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/集合对象编码转换.png" alt="集合对象编码转换"></p>
</li>
</ol>
<ol start="5">
<li><p><strong>有序集合对象</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/有序集合编码对象转换.png" alt="有序集合对象编码转换"></p>
</li>
</ol>
<hr>
<h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以 通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>
<hr>
<h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>对象的引用计数属性还带有对象共享的作用。目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象 包含了从0到9999的所有整数值，当需要用到这些字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。</p>
<hr>
<h2 id="单机数据库的实现"><a href="#单机数据库的实现" class="headerlink" title="单机数据库的实现"></a>单机数据库的实现</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">    //..</span><br><span class="line">    //服务器的数据库数量</span><br><span class="line">    int dbnum；</span><br><span class="line">    //一个数组，保存着服务器中的所有数据库</span><br><span class="line">    redisDb *Db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录客户端当前正在使用的数据库</span></span><br><span class="line">    redisDb *db；</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisClient</span><br></pre></td></tr></table></figure>
<p>redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/客户端与服务器.png" alt="客户端与服务器数据库关联"></p>
<hr>
<h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中redisDb结构中的dict字典保存了数据库中的所有键值对，这个字典被称为键空间（key space）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">//过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expores;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redicDb;</span><br></pre></td></tr></table></figure>
<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种对象。</li>
<li>所有针对数据库的操作，增删改查，实际上都是对键空间字典进行操作来实现的。</li>
<li>其他键空间操作<ul>
<li>维护操作<ul>
<li>读取键之后，服务器会更新键空间的命中（hit）次数或键空间不命中（miss）次数。</li>
<li>更新键的LRU（最后一次使用）时间。</li>
<li>键过期，删除</li>
<li>键被WATCH命令监视，修改后将键标记为脏（dirty），进行通知</li>
<li>键修改后，按配置发送相应的数据库通知</li>
</ul>
</li>
<li>设置键的生存时间或过期时间</li>
</ul>
</li>
</ul>
<hr>
<h4 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h4><p>惰性删除+定期删除</p>
<h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>惰性删除策略对CPU时间来说是友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行 ，并且删除的目标仅限与当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</p>
<p>惰性删除的缺点是：它对内存是最不友好的，如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会被释放。有内存泄露的危险。</p>
<h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>定期删除策略每隔一段时间执行一次过期键操作，并通过限制删除键执行的时长和频率来减少删除操作对CPU时间的影响。</p>
<h5 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h5><p>过期键的惰性删除策略由db.c/expirIfNeeded函数实现。</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/惰性删除键.png" alt="惰性删除"></p>
<h5 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h5><p>过期键的定期删除策略由<strong><em>redis.c/activeExpireCycle函数</em></strong>实现，每当Redis服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle就会被调用，它在规定时间内，分多次遍历服务器中的多个数据库，从数据库的expires字典中随机检查一部分建的过期时间，并删除其中的过期键。</p>
<h5 id="其余重点"><a href="#其余重点" class="headerlink" title="其余重点"></a>其余重点</h5><ul>
<li>执 行SAVE命令或者BGSAVE命令所产生的新RDB未见不会包含已经过期的键</li>
<li>执行BGREWRITEAOF命令所产生的重写AOF未见不会包含已经过期的键</li>
<li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾</li>
<li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键</li>
<li>从服务器及时发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li>
<li>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li>
</ul>
<hr>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p>
<p>为了解决这个为题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p>
<p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行。</p>
<h4 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h4><ul>
<li><p>SAVE命令：阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SAVE  //等待直到RDB文件创建完毕</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>BGSAVE命令：派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> BGSAVE  //派生子进程，并由子进程创建RDB文件</span></span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/载入文件判断流程.png" alt="载入文件判断流程"></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/创建和载入RDB文件.png" alt="RDB"></p>
<ul>
<li>RDB文件是一个经过压缩的二进制文件，由多个部分组成</li>
<li>对不同类型的键值对，RDB文件会使用不同的方式来保存它们</li>
</ul>
<hr>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only FIle）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据状态的。</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/AOF.png" alt="AOF"></p>
<p>####　AOF持久化的实现分为三步</p>
<ul>
<li><p><strong>命令追加</strong></p>
<p>当AOF持久化功能处于打开时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾</p>
</li>
<li><p><strong>AOF文件的写入与同步</strong></p>
<p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件时间负责接收客户端的命令请求，以及客户端发送命令回复，而时间事件则负责执行serverCron函数这样需要定时运行的函数。</p>
<p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲去里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。</p>
</li>
</ul>
<h4 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h4><p>因为AOF文件里包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的命令，就可以还原服务器关闭之前的数据库状态。</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/AOF载入.png" alt="AOFload"></p>
<h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/AOF后台重写.png" alt="AOF后台重写"></p>
<hr>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p>
<ul>
<li>文件事件（fileevent）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p><strong><em>Redis基于Reactor模式开发了自己的网络事件处理其器</em></strong>：这个处理器被称为文件事件处理器（flie event handler）：</p>
<ul>
<li><em>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字</em>，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应到（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作像相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/文件事件处理器及IO多路.png" alt="文件事件处理器及I/O多路复用"></p>
<hr>
<h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p>Redis的时间事件分为以下两类：</p>
<ul>
<li><em>定时事件</em>：让一段程序在指定的时间之后执行一次。</li>
<li><em>周期性事件</em>：让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>服务器将所有时间事件都放在一个无序链表（不按when属性的大小排序）中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<hr>
<h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度。</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/事件处理流程.png" alt="事件处理流程"></p>
<hr>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li>服务器状态结构使用clients链表链接多个客户端状态，新添加的客户端状态会被放到链表的末尾</li>
<li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态</li>
<li>输入缓冲区记录了客户端发送的命令请求，这个缓冲去的大小不能超过1GB</li>
<li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数</li>
<li>客户端有固定大小缓冲和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲去的最大大小不能超过服务器设置的硬性限制值。</li>
<li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性设置，那么客户端会被立即关闭；除此之外，客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭</li>
<li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭</li>
<li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭</li>
<li>载入AOF文件时使用的为2客户端在载入工作开始时动态创建，载入工作完毕之后关闭</li>
</ul>
<hr>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ul>
<li>一个命令请求从发送到完成主要包括以下步骤：<ol>
<li>客户端将命令请求发送给服务器；</li>
<li>服务器读取命令请求，并分析出命令参数</li>
<li>命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复</li>
<li>服务器将命令回复返回给客户端</li>
</ol>
</li>
<li>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERN信号，管理客户端资源和数据库状态，检查并执行持久化操作等等</li>
<li>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：<ol>
<li>初始化服务器状态</li>
<li>载入服务器配置</li>
<li>初始化服务器数据结构</li>
<li>还原数据库状态</li>
<li>执行事件循环</li>
</ol>
</li>
</ul>
<hr>
<h2 id="多机数据库的实现"><a href="#多机数据库的实现" class="headerlink" title="多机数据库的实现"></a>多机数据库的实现</h2><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system)可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/服务器与Sentinel系统.png" alt="服务器与Sentinel系统"></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/主服务器下线.png" alt="主服务器下线"></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/故障转移.png" alt="故障转移"></p>
<p><img src="/home/utur/图片/picture_for_note/Redis设计与实现/主服务器降级.png" alt="原主服务器降级"></p>
<hr>
<p>后续深入学习再作补充     </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/关于《python源码剖析》笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/关于《python源码剖析》笔记/" class="post-title-link" itemprop="url">关于《python源码剖析》笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:46:59" itemprop="dateModified" datetime="2019-07-06T17:46:59+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近学习python，时不时会感叹这门语言的简洁和实用，不由得会好奇python的底层实现。偶然得知有《python源码剖析》这本书，便想从中窥视一二，囫囵吞枣一翻，虽谈不上洞彻肺腑，但着实获益不少。正所谓“好记性不如烂笔头”，故作此笔记。</p>
<p>这里带着几个问题：</p>
<ul>
<li>python是用C实现的（虽然现在还有用JPython，Pypy），那么C是怎么实现python的面向对象的特性的呢？</li>
<li>什么叫<em>“<strong>python里的东西都是对象</strong>“</em>，这个对象又是什么？</li>
<li>python是门解释型语言，那么python是怎么执行代码的呢？</li>
</ul>
<p>(ps：《python源码剖析》里剖析的是python2.5版本，与目前最新的版本存在不少差异》）</p>
<h2 id="Python的总体架构"><a href="#Python的总体架构" class="headerlink" title="Python的总体架构"></a>Python的总体架构</h2><p>但凡认识一个事物，总得先有一个感性的认识，才能进而深入了解。python也如此，先看看python的总体架构。</p>
<p><img src="https://image.littlechao.top/20180924130852000006.jpg" alt="Architecture"></p>
<p>内核模块、库、用户模块 + Interpreter = Python 。通过加载一些模块，库，然后对源代码进行编译，最后再执行编译得到的字节码 ，python便完成了一次运行。</p>
<p>不难看出，python的核心便是他的解释器，而核心中的核心便是它的Code Evealuator（字节码执行器）。</p>
<h2 id="Python对象"><a href="#Python对象" class="headerlink" title="Python对象"></a>Python对象</h2><p>对象是python中最核心的一个概念，在python的世界中，一切都是对象，一个整数是一个对象，一个字符串也是一个对象，更为奇妙的是，类型也是一种对象，整数类型是一个对象，字符串也是一个对象（这与我在C++，java中的认知有很大不同，之前的认知是：这是一个什么<em>类型</em>的对象）。也就是说，面向对象理论中的“类”和“对象”这两个概念在Python中都是通过Python内的对象来实现的。不得不说，这很美妙，也很让人深思。</p>
<p><em>对象的本质</em></p>
<blockquote>
<p>在计算机中，一个对象实际上就是一片被分配的内存空间，这些内存可能是连续的，也可能是离散的，这都不重要，重要的是这片内存在更高的层次上可以作为一个整体来考虑，这个整体就是一个对象，在这片内存中，存储着一系列的数据以及可以对这些数据进行修改或读取操作的一系列代码。    </p>
</blockquote>
<p><em>在Python中，对象就是C中的结构体在堆上申请的一块内存</em>。为了确保对象能被正确的garbage-collected:<strong>对象是不能被静态初始化的，也不能在栈空间上生存</strong>（惟一的例外就是类型对象，Python中所有的内建的类型对象（如整数型对象，字符串类型对象）都是被静态初始化的。）；<strong>并且只能通过特殊的macros（宏）和方法来访问。</strong></p>
<p>在Python中，一个对象一旦被创建了，那么它在内存中的大小和地址就是确定的了。这意味着那些需要容纳可变长度数据的对象只能在对象内维护一个指向一下指向一块可变大小的内存区域的指针。<strong>遵循这样的规则可以使通过指针维护对象的工作变得十分简单。</strong> <em>优秀的设计</em></p>
<h3 id="对象机制的基石——PyObject"><a href="#对象机制的基石——PyObject" class="headerlink" title="对象机制的基石——PyObject"></a>对象机制的基石——PyObject</h3><p>可以说，PyObject是整个Python对象机制的核心。</p>
<p><strong>python2.5</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[object.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span>&#123;</span></span><br><span class="line">	PyObject_HEAD</span><br><span class="line">&#125;PyObject;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_HEAD            \</span></span><br><span class="line">	_PyObject_HEAD_EXTRA         \</span><br><span class="line">	<span class="keyword">int</span> ob_refcent;              \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>  \</span></span><br></pre></td></tr></table></figure>
<p><strong>python3.6.5</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span>&#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span>        </span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p><em>整型变量ob_refcnt与Python的内存管理机制有关，它实现了Python基于引用技术的垃圾收集机制。</em></p>
<p><em>而ob_type是一个指向_typeobject结构体的指针，实际上这个结构体对应着Python内部的一个特殊的对象，它用来指定一个对象类型的类型对象。</em></p>
<p>再来看看可变对象PyVarObject的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject</span><br></pre></td></tr></table></figure>
<p>可以看出，PyVarObject实际上只是对PyObject的一个扩展而已。</p>
<p>至此，可以明确看出，Python对象机制的核心非常简单：<strong>引用计数 + 类型信息</strong>。</p>
<p>关于类型信息，看一段源码的注释：</p>
<blockquote>
<p>An object has a ‘type’ that determins what ir represents and what kind of data it contains. An ovject ‘type’ is fixed when it is created. Types themselves are represented as objects; an object contains a pointer to the corresponding type object. The type itself has type pointer pointing to the object represnting the type ‘type’, which contains a pointer to itself</p>
</blockquote>
<h3 id="对象里的特殊对象，类型对象——PyTypeObject。"><a href="#对象里的特殊对象，类型对象——PyTypeObject。" class="headerlink" title="对象里的特殊对象，类型对象——PyTypeObject。"></a>对象里的特殊对象，类型对象——PyTypeObject。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_typeobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line">    </span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    ......   </span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>
<p>在_typeobject的定义中包含了许多信息，主要可以分为4类：</p>
<ul>
<li>类型名，tp_name，主要是Python内部以及调试的时候使用。</li>
<li>创建该类型对象时分配内存空间大小的信息，即tp_basecsize和tp_itemsize。</li>
<li>与该类型对象相关联的操作信息（诸如tp_print这样的许多的函数指针）。</li>
<li>类型的类型信息。</li>
</ul>
<p>在python3.6.5源码的object.h文件中有这么一段注释</p>
<blockquote>
<p>/<em> PyObject_HEAD defines the initial segment of every PyObject. </em>/</p>
</blockquote>
<p>换句话说，在Python内部，每一个对象都拥有相同的对象头部。这就使得在Python中，对对象的引用变得非常的统一，只需要用一个PyObject *指针就可以引用任意的一个对象。而不论该对象实际是一个什么对象。</p>
<h3 id="Python对象的多态性"><a href="#Python对象的多态性" class="headerlink" title="Python对象的多态性"></a>Python对象的多态性</h3><p>到这里，Pyhton底层如何用C实现<em>多态</em>的已经跃然纸上了。</p>
<p>通过PyObject和PyTypeObject，Pyhton利用C语言完成了C++所提供的对象的多态的特性。在Python创建一个对象，比如PyIntObejct对象时，会分配内存，进行初始化。然后Python内部用一个PyObject<em>变量来保存和维护这个对象。其他对象也于此类似，所以在Python内部各个函数之间传递的都是一种范型指针——PyObject </em>。这个指针所指的对象究竟是什么类型，只能从指针所指对象的ob_type域动态进行判断，而正是通过这个域，Python实现了多态机制。</p>
<p>说了这么多，现在用图来捋一捋。毕竟，一图胜万言。</p>
<p>​                                                                         <strong>各种Object之间的联系</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/Utur_PyObject.png" alt="Object">​       </p>
<p>​                                                               <strong>通过PyInt_Type创建整数</strong></p>
<p><img src="https://image.littlechao.top/20180927032505000012.jpg" alt="jiaohu"></p>
<p>​                                                                  <strong>运行时整数对象及其类型之间的关系</strong>(对照上图)</p>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/Utur_Integer.png" alt="Integer"></p>
<h3 id="Python内对象分类"><a href="#Python内对象分类" class="headerlink" title="Python内对象分类"></a>Python内对象分类</h3><p>关于Python内对象的分类，这里提供几种角度，不保证正确性。</p>
<h4 id="从概念上的角度"><a href="#从概念上的角度" class="headerlink" title="从概念上的角度"></a>从概念上的角度</h4><ul>
<li>Fundamental对象：类型对象</li>
<li>Numeric对象：数值对象</li>
<li>Sequence 对象：容纳其他对象的序列集合对象</li>
<li>Mapping 对象：类似于C++中map的关联对象</li>
<li>Internal 对象：Python虚拟机在运行时内部使用的对象</li>
</ul>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/object.png" alt="对象分类"></p>
<h4 id="从内存上的角度"><a href="#从内存上的角度" class="headerlink" title="从内存上的角度"></a>从内存上的角度</h4><p><strong>定长对象</strong>:不包含可变长度数据的对象（es，整数对象）</p>
<p><strong>变长对象</strong>:包含可变长度数据的对象（es，字符串对象）</p>
<p><em>区别：</em>定长对象的不同对象占用的内存是一样的（es，1和100），而变长对象的不同对象占用的内存可能是不一样的。（es，”Python“和”Java“)</p>
<p>实际上，在变长对象中，还可分为<em>可变对象</em>和<em>不可变对象</em>。可变对象维护的数据在对象在创建后还能再变化，比如一个list被创建后，可以向其中添加元素或删除元素，这些操作都会改变其维护的数据；而不可变对象所维护的数据在对象创建之后就不能再改变了，比如string和tuple。    </p>
<p>到这里，对对象的结构性认识已经差不多了，接下来，就是各种对象在具体实现上一些差异化了。</p>
<h3 id="Python内建对象"><a href="#Python内建对象" class="headerlink" title="Python内建对象"></a>Python内建对象</h3><p>在Python中，已经预先定义了一些类型对象，比如int类型、string类型、dict类型等</p>
<h4 id="PyIntObject对象"><a href="#PyIntObject对象" class="headerlink" title="PyIntObject对象"></a>PyIntObject对象</h4><p>先看个图</p>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/2018-09-28 21-36-35屏幕截图3.png" alt="PyIntObject"></p>
<p>内置函数id()用来返回对象的身份(identity)，而这里的身份说白了就是该对象的内存地址。</p>
<p>下面给出总结：</p>
<ul>
<li><strong>处于对Python性能和运行效率的考虑，对于频繁使用的小整数对象，Python采用了对象池技术。在小整数对象池中完全缓存了其PyIntObject对象，这意味着每一个对象池里的每一个PyIntObject对象都能够被任意的共享。</strong></li>
<li>小整数的范围可以被用户通过源码修改，默认的是[-5, 257)</li>
<li>对于其他整数，设计者们在时间与空间的两难选择上，作出的妥协是：Python运行环境提供一块内存空间（通用整数对象池），这些内存空间由这些大整数轮流使用。这样免去了不断地malloc之苦，又在一定程度上考虑了效率问题。</li>
<li>对于通用整数对象池，Python通过定义一个PyIntBlock结构，在这个结构的基础上，实现了一个单向列表。</li>
</ul>
<h5 id="通用整数对象池的实现基础——PyIntBlock"><a href="#通用整数对象池的实现基础——PyIntBlock" class="headerlink" title="通用整数对象池的实现基础——PyIntBlock"></a>通用整数对象池的实现基础——PyIntBlock</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[intobject.c]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> *<span class="title">next</span>;</span></span><br><span class="line">    PyIntObject object[N_INTOBJCETS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> <span class="title">PyIntBlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntBlock *block_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> PyIntObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>PyIntBlock，顾名思义，就是一块保存了N_INTOBJECTS个PyIntobject对象的内存（block）。</p>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/IntBlock.png" alt="PyIntBlock"></p>
<p>这里存在一个隐患：两个PyIntBlock处于同一个链表当中，但是每一个PyIntBlock中至光重要的存放PyIntObject对象的objects却是分离的。 若真是这样，就意味着所有的内存只能使用一次，跟内存泄漏也就没什么区别了。</p>
<p>Python的设计者当然不会允许这样的存在，所以才有了free，_list的存在。</p>
<p>在一个PyIntObject对象被销毁的时候（tp_dealloc），不同PyIntBlock中空闲的内存块被链接free_list里了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[intobject.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_dealloc</span><span class="params">(PyIntObject *v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyInt_CheckExact(v)) &#123;</span><br><span class="line">        v-&gt;ob_type = (struct _typeobject *)free_list;</span><br><span class="line">        free_list = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	v-&gt;ob_type-&gt;tp_free(PyObjcet *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以真相如图：</p>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/block.png" alt="free_list"></p>
<p>但是，这里还隐藏着Python的整数对象系统实现中的一个惊天隐秘：当一个整数对象的引用计数变为0时，就会被Python回收，但是在int_dealloc中，只是将该内存重新加入自由内存链表中， 却不是向系统堆交还任何内存。那么，理论上，是可以利用这个漏洞将系统的内存全部吃光的。只要你定义足够多的大整数对象。</p>
<h4 id="PythonStringObject对象"><a href="#PythonStringObject对象" class="headerlink" title="PythonStringObject对象"></a>PythonStringObject对象</h4><p>在Python中，PyStringObject是对字符串对象的实现。PyStringObejct是一个拥有可变长度内存的对象，这一点毋庸置疑。但同时，其又是一个不变对象。因为当创建了一个PyStringObject对象之后，该对象内部维护的字符串就不能再被改变了。这一点特性使得PyStringObject对象可作为dict的键值，但同时也使得一些字符串操作的效率大大降低，比如多个字符串的连接。</p>
<p><strong>PythonStirngObejct</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[stringobejct.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObejct_VAR_HEAD</span><br><span class="line">    <span class="keyword">long</span> ob_shash;</span><br><span class="line">    <span class="keyword">int</span> ob_sstate;</span><br><span class="line">    <span class="keyword">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line">&#125; PyStringObject;</span><br></pre></td></tr></table></figure>
<ul>
<li>ob_shash：缓存该对象的hash值，避免每一次都重新计算该字符串对象的hash值。初始值为-1</li>
<li>ob_sstate：标记了该对象是否已经过intern机制的处理。</li>
<li>ob_sval：实际上是作为一个字符指针指向一段内存，这段内存保存着这个字符串对象所维护的实际字符串，显然，这段内存不会只是一个字节。而这段内存的实际长度（字节），正是有ob_size来维护，这个机制是Python中所有变长对象的实现机制。</li>
</ul>
<h5 id="intern机制"><a href="#intern机制" class="headerlink" title="intern机制"></a>intern机制</h5><p>对PyStringObject对象做intern操作目的在于：在Python运行期间，系统中只有一个与特定字符串对应的PyStringObject对象。当判断两个PyStringObject对象是否相同，如果都被intern处理过了，只需简单地检查对应PyObject *是否相同即可。这个机制既节省了空间，又简化了PyStringObejct对象的比较。</p>
<p><strong>Python会对简单的字符串进行intern，并将intern的结果放入对象缓存池中。</strong></p>
<p><strong><em>简单的字符串：空串，字符，只包含字母或数字</em></strong></p>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/string.png" alt="string"></p>
<p><strong><em>总结：类似于小整数对象，Python会选择性地对一些字符串进行池化，以减少对象的数量和对内存的占用。</em></strong></p>
<h5 id="PyStringObejct效率相关问题"><a href="#PyStringObejct效率相关问题" class="headerlink" title="PyStringObejct效率相关问题"></a>PyStringObejct效率相关问题</h5><p>一个严重影响python执行效率的问题——字符串连接”+”操作</p>
<p>根源 ：PyStringObject对象是一个不可变对象，若要连接<strong>N</strong>个PyStringObject对象，那么必须进行N-1次的内存申请及内存搬运的工作。可想而知，这是多大的工作量，必将严重影响Python的执行效率。</p>
<p>官方推荐的做法是通过利用join来对N个存在list或tuple的PyStringObejct对象进行连接操作，先统计一共有多少个PyStirngObejct对象，并统计这些对象所维护的字符串一共有多长，然后申请内存。这种做法只需要分配一次内存，执行效率将大大提高</p>
<p>看下实际运行情况：</p>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/time.png" alt="time">        </p>
<p><em>可以看出在N较小的情况下，”+”操作效率比join还高</em>。</p>
<p><strong>总结：”+”连接效率低是出现在字符串数目较多的情况，而在字符串数目较小的情况下，”+”比join执行效率还高。</strong></p>
<h4 id="PyListObject"><a href="#PyListObject" class="headerlink" title="PyListObject"></a>PyListObject</h4><p>PyListObject对象是Python提供的对列表的抽象，它可以有效地支持对元素的插入，添加，删除等操作，在Python的列表中无一例外存放的都是PyObject *指针。很明显，PyListObject是一个变长对象，而且还是个可变对象。</p>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated</span><br><span class="line">&#125; PylistObject</span><br></pre></td></tr></table></figure>
<ul>
<li>**ob_item：指针指向元素列表所在的内存块的首地址</li>
<li>allocated：维护了当前列表的可容纳的元素的总数</li>
<li>ob_size：实际被使用的内存的数量</li>
</ul>
<p>对于一个PyListObject对象，存在以下关系：</p>
<p><strong>0 &lt;= ob_size &lt;= allocated</strong></p>
<p><strong>len(list) == ob_size</strong></p>
<p><strong>ob_item == NULL 意味着 ob_size == allocated == 0</strong></p>
<p>由此可以窥探Python对PyListObejct所采的内存管理策略和C++中vector采取的内存管理策略是一致的：<strong>总会申请一大块内存，而不是存了多少就申请对应大小的内存。</strong></p>
<h5 id="PyListObject的创建"><a href="#PyListObject的创建" class="headerlink" title="PyListObject的创建"></a>PyListObject的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PyList_New(Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    PyListObject *op;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> initialized = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        Py_AtExit(show_alloc);</span><br><span class="line">        initialized = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为PyListObject对象申请空间</span></span><br><span class="line">     <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        <span class="comment">// 缓冲池可用</span></span><br><span class="line">        numfree--;</span><br><span class="line">        op = free_list[numfree];</span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_ALLOC_COUNT		</span></span><br><span class="line">        count_reuse++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓冲池不可用</span></span><br><span class="line">        op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_alloc++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        op-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, <span class="keyword">sizeof</span>(PyObject *));</span><br><span class="line">        <span class="keyword">if</span> (op-&gt;ob_item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(op);</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_SIZE(op) = size;</span><br><span class="line">    op-&gt;allocated = size;</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出PyListObject对象的创建主要分两步：</p>
<ul>
<li>为PyListObject对象申请空间：<ol>
<li>若缓冲池有可用对象，则使用这个可用对象</li>
<li>缓冲池无可用对象，通过PyObject_GC_New在系统堆中申请内存。</li>
</ol>
</li>
<li>为PyListObject对象中维护的元素列表申请空间</li>
</ul>
<p>PS:默认情况下，缓冲池free_lists中最多会维护80个PyListObject对象。</p>
<h5 id="PyListObject对象缓冲池"><a href="#PyListObject对象缓冲池" class="headerlink" title="PyListObject对象缓冲池"></a>PyListObject对象缓冲池</h5><p>同PyIntObject类似，PyListObject也是在被销毁的过程中加入缓冲池。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[listobject.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">list_dealloc(PyListObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject_GC_UnTrack(op);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(op)</span><br><span class="line">    / :销毁PyListObject对象维护的元素列表</span><br><span class="line">    <span class="keyword">if</span> (op-&gt;ob_item != <span class="literal">NULL</span>) &#123; </span><br><span class="line">        i = Py_SIZE(op);</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        PyMem_FREE(op-&gt;ob_item);</span><br><span class="line">    &#125;</span><br><span class="line">    / ：释放PyList自身</span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op))</span><br><span class="line">        free_list[numfree++] = op;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">    Py_TRASHCAN_SAFE_END(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出，与创建相对应，销毁也主要分为两步：</p>
<ul>
<li>销毁PyListObject对象维护的元素列表，向系统堆归还内存，以时间换取空间</li>
<li>释放PyListObject自身：<ol>
<li>若缓冲池未满，则将该对象放入缓冲池，以备后用</li>
<li>若满了，则调用自身的tp_free方法进行释放</li>
</ol>
</li>
</ul>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/listcache.png" alt="list_cache"></p>
<h4 id="PyDictObject对象"><a href="#PyDictObject对象" class="headerlink" title="PyDictObject对象"></a>PyDictObject对象</h4><h2 id="Python虚拟机"><a href="#Python虚拟机" class="headerlink" title="Python虚拟机"></a>Python虚拟机</h2><p>关于Python，有一种说法：“Python是一种解释性的语言”。其实这种说法是不准确的，因为Python程序的执行原理和Java程序、C#程序的执行原理都可以用两个词囊括——<strong>虚拟机、字节码。</strong>实际上，Python解释器在执行任何一个Python程序文件时，都先对Python源代码进行编译，编译生成一组Python的byte code（字节码），然后由虚拟机按照顺序执行字节码，从而完成对Python程序的执行动作。</p>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/Pythonrun.png" alt="Python_run"></p>
<h3 id="PyCodeObject对象和pyc文件"><a href="#PyCodeObject对象和pyc文件" class="headerlink" title="PyCodeObject对象和pyc文件"></a>PyCodeObject对象和pyc文件</h3><p>在编译过程中，包含在Python源代码中的<strong>静态信息</strong>都会被Python编译器收集起来，这些静态信息包括了<strong>字符串、常量值、字节码</strong>。在Python运行期间，<em>这些源文件提供的静态信息被存储在一个运行时的对象中——<strong>PyCodeObject</strong></em>。<em>当运行结束后，这个运行时对象所包含的信息被存储在一种文件中(当有import语句时）——<strong>pyc文件</strong></em></p>
<p>Python源码中对PyCodeObject的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">int</span> co_argcount;		<span class="comment">/* #arguments, except *args */</span></span><br><span class="line">    <span class="keyword">int</span> co_kwonlyargcount;	<span class="comment">/* #keyword only arguments */</span></span><br><span class="line">    <span class="keyword">int</span> co_nlocals;		<span class="comment">/* #local variables */</span></span><br><span class="line">    <span class="keyword">int</span> co_stacksize;		<span class="comment">/* #entries needed for evaluation stack */</span></span><br><span class="line">    <span class="keyword">int</span> co_flags;		<span class="comment">/* CO_..., see below */</span></span><br><span class="line">    <span class="keyword">int</span> co_firstlineno;   <span class="comment">/* first source line number */</span></span><br><span class="line">    PyObject *co_code;		<span class="comment">/* instruction opcodes */</span></span><br><span class="line">    PyObject *co_consts;	<span class="comment">/* list (constants used) */</span></span><br><span class="line">    PyObject *co_names;		<span class="comment">/* list of strings (names used) */</span></span><br><span class="line">    PyObject *co_varnames;	<span class="comment">/* tuple of strings (local variable names) */</span></span><br><span class="line">    PyObject *co_freevars;	<span class="comment">/* tuple of strings (free variable names) */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* tuple of strings (cell variable names) */</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *co_cell2arg; <span class="comment">/* Maps cell vars which are arguments. */</span></span><br><span class="line">    PyObject *co_filename;	<span class="comment">/* unicode (where it was loaded from) */</span></span><br><span class="line">    PyObject *co_name;		<span class="comment">/* unicode (name, for reference) */</span></span><br><span class="line">    PyObject *co_lnotab;	<span class="comment">/* string (encoding addr&lt;-&gt;lineno mapping) See</span></span><br><span class="line"><span class="comment">				   Objects/lnotab_notes.txt for details. */</span></span><br><span class="line">    <span class="keyword">void</span> *co_zombieframe;     <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">    <span class="keyword">void</span> *co_extra;</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>
<p>Python编译器在Python源代码进行变异的时候，对于代码中的<em>Code Block</em>，会创建一个PyCodeObject对象与之对应。那么何为一个Code Block——当进入一个新名字空间，或者说作用域时，就是进入了一个新的Code Block。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[demo.py]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	def B():</span><br><span class="line">		pass</span><br><span class="line"></span><br><span class="line">def C():</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">C()</span><br></pre></td></tr></table></figure>
<p>对于demo.py，根据之前的说法就要产生4个PyCodeObject，但是Python运行环境只会对一个PyCodeObject对象调用PyMarshal_WriteObjectToFile操作。很显然，这里面存在一种嵌套关系，仔细观察，在demo.py源文件中作用域呈现出一种嵌套结构，而这种结构正是PyCodeObject对象之间的结构。</p>
<p><img src="/home/utur/图片/picture_for_note/Python源码分析/ pycode.png" alt="PythonCode"></p>
<h3 id="Python虚拟机框架"><a href="#Python虚拟机框架" class="headerlink" title="Python虚拟机框架"></a>Python虚拟机框架</h3><p>Python的虚拟机是Python的核心，在.py源代码被编译为字节码指令序列后，Python虚拟机机开始接手整个工作。Python的虚拟机从编译得到的PyCodeObject对象中一次读入每一条字节码指令，并在<em>当前的上下文环境</em>中执行字节码指令。</p>
<p>Python的虚拟机实际上实在模拟操作系统运行可执行文件的过程</p>
<p><img src alt="可执行文件的运行时栈"></p>
<p>我们知道PyCodeObject对象中包含了最关键的的字节码指令，以及关于程序的所有静态信息。然而有一点，是PyCodeObject对象没有包含，也不可能包含的。那就是关于程序运行时的动态信息——<strong>执行环境</strong></p>
<p>什么是执行环境，参考下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[environment.py]</span><br><span class="line">i = <span class="string">'Python'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">	i = <span class="number">999</span></span><br><span class="line">	print(i) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">print(i) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p>在上面代码中的1和2两个地方，都是print(i)，它们所对应的字节码指令肯定是相同，但是它们的执行效果却是不同的。这样的结果正是在执行环境的影响下产生的。在执行#1处的print时，执行环境中，i的值为999；而在#2处，执行环境中的i的值为“Python”。<em>像这种同样的符号在程序运行的不同时刻对应不同的值，甚至不同类型的情况</em>，必须在运行时动态地被捕获和维护，而不可能在PyCodeObject对象中被静态的存储的。</p>
<p>仔细观察，这里的执行环境与之前提到的名字空间似乎是用一个东西，但实际上，名字空间仅仅是执行环境的一部分，除了名字空间，在执行环境中，还包含了其他的一些信息。</p>
<p><em>所以在Python执行的时候，虚拟机上面对的并不是PyCodeObject对象，而是另一个对象——<strong>PyFrameObject</strong>，也就是所谓的执行环境，是Pyhton对x86平台上栈帧的模拟。</em></p>
<h5 id="PyFrameObject对象"><a href="#PyFrameObject对象" class="headerlink" title="PyFrameObject对象"></a>PyFrameObject对象</h5><p>对于Python而言，PyFrameObject对象不仅仅是一个x86机器上看到的那个简简单单的栈帧，它实际上还包含了其他更多的信息。</p>
<p>Python源码中对PyFrameObject的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[frameobject.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span>      <span class="comment">/* previous frame, or NULL */</span></span><br><span class="line">    PyCodeObject *f_code;       <span class="comment">/* code segment */</span></span><br><span class="line">    PyObject *f_builtins;       <span class="comment">/* builtin symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_globals;        <span class="comment">/* global symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_locals;         <span class="comment">/* local symbol table (any mapping) */</span></span><br><span class="line">    PyObject **f_valuestack;    <span class="comment">/* points after the last local */</span></span><br><span class="line"></span><br><span class="line">    PyObject **f_stacktop;</span><br><span class="line">    PyObject *f_trace;          <span class="comment">/* Trace function */</span></span><br><span class="line"></span><br><span class="line">    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;</span><br><span class="line">    <span class="comment">/* Borrowed reference to a generator, or NULL */</span></span><br><span class="line">    PyObject *f_gen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f_lasti;                <span class="comment">/* Last instruction if called */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> f_lineno;               <span class="comment">/* Current line number */</span></span><br><span class="line">    <span class="keyword">int</span> f_iblock;               <span class="comment">/* index in f_blockstack */</span></span><br><span class="line">    <span class="keyword">char</span> f_executing;           <span class="comment">/* whether the frame is still executing */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* for try and loop blocks */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];  <span class="comment">/* locals+stack, dynamically sized */</span></span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure>
<ul>
<li>f_back: 在Python实际的执行中，会产生很多PyFrameObject对象，而这些对象会被链接起来，形成一条执行环境链条。正是对x86机器上栈帧间关系的模拟</li>
<li>f_code: 存放的是一个待执行的PyCodeObejct对象</li>
<li>f_builtins: builtin名字空间</li>
<li>f_globals: global名字空间</li>
<li>f_locals: local名字空间</li>
</ul>
<h5 id="名字、作用域、名字空间"><a href="#名字、作用域、名字空间" class="headerlink" title="名字、作用域、名字空间"></a>名字、作用域、名字空间</h5><h3 id="Python虚拟机中的函数机制"><a href="#Python虚拟机中的函数机制" class="headerlink" title="Python虚拟机中的函数机制"></a>Python虚拟机中的函数机制</h3><h4 id="PyFunctionObject对象"><a href="#PyFunctionObject对象" class="headerlink" title="PyFunctionObject对象"></a>PyFunctionObject对象</h4><h4 id="嵌套函数、闭包与decorater"><a href="#嵌套函数、闭包与decorater" class="headerlink" title="嵌套函数、闭包与decorater"></a>嵌套函数、闭包与decorater</h4><h3 id="Python虚拟机中的类机制"><a href="#Python虚拟机中的类机制" class="headerlink" title="Python虚拟机中的类机制"></a>Python虚拟机中的类机制</h3><h2 id="Python的多线程机制"><a href="#Python的多线程机制" class="headerlink" title="Python的多线程机制"></a>Python的多线程机制</h2><h3 id="GIL与线程调度"><a href="#GIL与线程调度" class="headerlink" title="GIL与线程调度"></a>GIL与线程调度</h3><h3 id="Python线程的调度"><a href="#Python线程的调度" class="headerlink" title="Python线程的调度"></a>Python线程的调度</h3><h3 id="Python线程的用户级互斥与同步"><a href="#Python线程的用户级互斥与同步" class="headerlink" title="Python线程的用户级互斥与同步"></a>Python线程的用户级互斥与同步</h3><h2 id="Python的内存管理"><a href="#Python的内存管理" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><h3 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h3><h3 id="小块空间的内存池"><a href="#小块空间的内存池" class="headerlink" title="小块空间的内存池"></a>小块空间的内存池</h3><h3 id="循环引用的垃圾收集"><a href="#循环引用的垃圾收集" class="headerlink" title="循环引用的垃圾收集"></a>循环引用的垃圾收集</h3><h3 id="Python中的垃圾收集"><a href="#Python中的垃圾收集" class="headerlink" title="Python中的垃圾收集"></a>Python中的垃圾收集</h3><h2 id><a href="#" class="headerlink" title=" "></a> </h2>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Linux内核（学习笔记）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Linux内核（学习笔记）/" class="post-title-link" itemprop="url">深入理解Linux内核</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:18:46" itemprop="dateModified" datetime="2019-07-06T17:18:46+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux-的优势"><a href="#Linux-的优势" class="headerlink" title="Linux 的优势"></a>Linux 的优势</h2><ol>
<li>Linux是免费的。除硬件之外，无需任何花费就能安装一套玩整的Linux系统</li>
<li>Linux的所有成分都可以充分地定制。通过内核编译选项，你可以选择自己真正需要的特征来定制内核。</li>
<li>Linux可以运行在低档、便宜的硬件平台上。</li>
<li>Linux是强大的，由于充分挖掘了硬件部分的特点，使得Linux系统速度非常块，Linux的主要目标是效率</li>
<li>Linux的开发者都是非常出色的程序员。</li>
<li>Linux内核非常小，而且紧凑。</li>
<li>Linux与很多通用操作系统高度兼容。</li>
<li>Linux有很好的技术支持</li>
</ol>
<p><strong>内核控制路径（Kernel control path）</strong>表示内核处理系统调用、异常或中断所执行的指令序列。</p>
<p>最简单的情况下，CPU从第一条指令到最后一条指令顺序地执行内核控制路径。然而当下述事件之一发生时，CPU交错执行内核控制路径：</p>
<ol>
<li>运行在用户态的进程调用一个系统调用。</li>
<li>当运行一个内核控制路径时，CPU检测到一个异常（例如，访问一个不在RAM中的页）。</li>
<li>当CPU正在运行一个启用了中断的内核控制路径时，一个硬件中断发生。</li>
<li>在支持抢占式调度的内核中，CPU正在运行，而一个更高优先级的进程加入就绪队列，则中断发生。</li>
</ol>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/内核控制路径.png" alt="内核控制路径"></p>
<p><strong>同步内核路径</strong></p>
<ol>
<li><strong><em>非抢占式内核</em></strong>，当进程在内核态执行时，它不能被任意挂起，也不能被另一个进程代替。因此，在单处理器系统上，中断或异常处理程序不能修改的所有内核数据结构，内核对它们讷的访问都是安全的</li>
<li><strong><em>禁止中断</em></strong>，单处理器系统上的另一种同步机制是：在进入一个临界区之前禁止所有硬件中断，离开时再重新启动中断。</li>
<li><strong><em>信号量</em></strong>,信号量仅仅是与一个数据结构相关的计数器。所有内核线程在试图访问这个数据结构之前，都要检查这个信号量。可以把每个信号量看成一个对象，其组成如下：<ul>
<li>一个整数变量</li>
<li>一个等待进程的链表</li>
<li>两个原子方法：down()和up()</li>
</ul>
</li>
<li><strong><em>自旋锁</em></strong>,如果修改数据结构所需的时间比较段，那么，信号量可能是低效的。为了检查信号量，内核必须把进程插入到信号量链表中，然后挂起它。因为这两种操作比较费时，完成这些操作时，其他的内核控制路径可能已经释放了信号量。在这些情况下，多处理器操作系统使用了自旋锁（spin lock）。自旋锁与信号量非常相似，但没有进程链表，当一个进程发现锁被另一个进程锁着时，它就不停地“旋转”，执行一个紧凑的循环指令直到锁打开。当然，自旋锁在单处理器环境下是无效的。</li>
</ol>
<h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><p><strong>随机访问存储器（RAM）的使用</strong></p>
<p>所有的Unix操作系统都将RAM毫无疑义地划分为两部分，其中若干兆字节专门用于存放内核映像（也就是内核代码和内核静态数据结构）。RAM的其余部分通常有虚拟内存系统来处理，并且用在以下三种可能的方面：</p>
<ul>
<li>满足内核对缓冲去、描述符及其他动态内核数据结构的请求</li>
<li>满足进程对一般内存区的请求及对文件内存映射的请求</li>
<li>借助于高速缓存从磁盘及其他缓冲设备获得较好的性能</li>
</ul>
<p><strong>内核内存分配器</strong></p>
<p>内存内核分配其（Kernel Memory Allocator, KMA）是一个子系统，它试图满足系统中所有部分对内存的请求。</p>
<p>基于各种不同的算法技术，已经提出了集中KMA，包括：</p>
<ul>
<li><em>资源图分配算法（allocator）</em></li>
<li><em>2的幂次方空间链表</em></li>
<li><em>McKusick-Karels分配算法</em></li>
<li><em>伙伴（Buddy）系统</em></li>
<li><em>Mach的区域（Zone）分配算法</em></li>
<li><em>Dynix分配算法</em></li>
<li><em>Solaris的Slab分配算法</em></li>
</ul>
<p><strong>物理内存布局</strong></p>
<p>在初始化阶段，内核必须建立一个物理地址映射来指定哪些物理地址范围对内核可用而哪些不可用（或者因为它们映射硬件设备I/O的共享内存，或者因为相应的页框含有BIOS数据）。</p>
<p>内核将下列页框记为保留：</p>
<ul>
<li>在不可用的物理地址范围内的页框。</li>
<li>含有内核代码和已初始化的数据结构的页框</li>
</ul>
<p>保留页框中的页绝不嫩被动态分配或交换到磁盘上。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程链表</strong></p>
<p>Linux的进程链表是一个双向链表，进程链表把所有进程的描述符链接起来。每个task_struct结构都包含一个list_head类型的tasks字段，这个类型的prev和next字段分别指向前面和后面的task_struct元素。</p>
<p>进程链表的头是init_task描述符，它是所谓的0进程（process 0）或swapper进程的进程描述符。init_task的tasks.prev字段指向链表中最后插入的进程描述符tasks字段。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/进程链表.png" alt="进程链表"></p>
<p><strong>TASK_RUNNING状态的进程链表</strong></p>
<p>当内核寻找一个新进程在CPU上运行时，必须只考虑可运行进程（即处在TASK_RUNNING状态的进程）。</p>
<p>早期的Linux版本把所有的可运行进程都放在同一个叫作运行队列（runqueue）的链表中，由于维持链表中的进程按优先级排序开销过大，因此，早期的调度程序不得不为选择“最佳”可运行进程而扫描整个队列。</p>
<p>Linux 2.6实现的运行队列有所不同。其目的是让点读程序能在固定的时间内选出“最佳”可运行程序，与队列中可运行的进程数无关。提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先权对应一个不同的链表。这是一个通过使数据结构更复杂来改善性能的典型例子：调度程序的操作效率的确更高了，但运行队列的链表却为此而被拆分成140(0-139）个不同的队列。——空间换时间</p>
<p><strong>进程间的关系</strong></p>
<p>程序创建的进程具有父/子关系。如果一个进程创建多个子进程时，则子进程之间具有兄弟关系。</p>
<p>图3-4显示了一组进程间的亲属关系。进程P0接连创建了P1，P2，和P3。进程P3又创建了P4。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/进程间的关系.png" alt="进程间的关系"></p>
<p><strong>pidhash表及链表</strong></p>
<p>在几种情况下，内核必须能从进程的PID到处对应的进程描述符指针。</p>
<p>顺序扫描进程链表并检查进程描述符的pid字段是可行但相当低效的。为了加速查找，引入了4个散列表。需要4个散列表是因为进程描述符包含了表示不同类型pid的字段，而且每种类型的PID需要它自己的散列表。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/4种PID.png" alt="四种PID"></p>
<p>正如计算机科学的基础课程所阐述的那样，散列（hash）函数并不总能确保PID与表的索引一一对应。两个不同的PID散列（hash）到相同的表索引称为冲突（colliding）</p>
<p>Linux利用链表来处理冲突的PID：每一个表项是由冲突的进程描述符组成的双向链表。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/pidhash表及链表.png" alt="pidhash表"></p>
<p>具有链表的散列法比从PID到表索引的线性转换更优越，这是因为在任何给定的实例中，系统中的进程数总是远远小于32768（所允许的进程PID的最大数）。如果在任何给定的实例中大部分表项都不使用的话，那么把表定义为32768项会是一种存储浪费。</p>
<p>由于需要跟踪进程间的关系，PID散列表中使用的数据结构非常复杂。</p>
<p>PID散列表的数据结构解决了所有这些难题，因为他们可以为包含在一个散列表中任意PID号定义进程链表。</p>
<p><strong>等待队列</strong></p>
<p>等待队列在内核中有很多用途，尤其用在中断处理、进程同步及定时。等待队列表示一组睡眠的进程，当某一条件变为真时，由内核唤醒它们。</p>
<p>等待队列由双向链表实现，其元素包括指向进程描述符的指针。因为等待队列是由中断处理和主要内核函数修改的，因此必须对其双向链表进行保护以免对其进行同事访问，因为同事访问会导致不可预测的后果。</p>
<p>注：雷鸣般兽群问题：即唤醒多个进程只为了竞争一个资源，而这个资源只能有一个进程访问，结果是其他进程必须再次回去睡眠。</p>
<p>非互斥进程插入等待队列链表的第一个位置。互斥进程插入等待队列链表的最后一个位置。</p>
<p>因为所有的非互斥进程总是在双向链表的开始位置，而所有的互斥进程在双向链表的尾部，所以函数总是先唤醒非互斥进程然后再唤醒互斥进程，如果有进程存在的话。</p>
<p><strong>进程切换</strong></p>
<p><strong><em>硬件上下文</em></strong></p>
<p>进程恢复执行前必须转股寄存器的一组数据称为硬件上下文（hardware context)。硬件上下文是进程可执行上下文的一个子集。在Linux中，进程硬件上下文的一部分存放在TSS段，而剩余部分存放在内核太堆栈中。</p>
<p><strong><em>任务状态段(TSS)</em></strong></p>
<p>80x86体系结构包括了一个特殊的段类型，叫任务状态段（Task State Segment, TSS)来存放硬件上下文。尽管Linux并不使用硬件上下文切换，但是强制它为系统中每个不同的CPU创建一个TSS。</p>
<p><strong>thread字段</strong></p>
<p>在每次进程切换时，被替换进程的硬件上下文必须保存在别处。不能像Intel原始设计那样把它保存在TSS中，因为Linux为每个处理器而不是为每个进程使用TSS。</p>
<p>因此，每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。</p>
<p><strong>执行进程切换</strong></p>
<p>从本质上说，每个进程切换由两步组成：</p>
<ol>
<li>切换页全局目录以安装一个新的地址空间</li>
<li>切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包括CPU寄存器。</li>
</ol>
<p><strong>创建进程</strong></p>
<p>Unix操作系统紧紧依赖进程创建来满足用户的需求。</p>
<p>传统的Unix操作系统以统一的方式对待所有的进程：子进程复制父进程所拥有的资源。这种方法使进程的创建非常慢且效率低，因为子进程需要拷贝父进程的整个个、地址空间。</p>
<p>现代Unix内核通过引入三种不同的机制解决了这个问题：</p>
<ul>
<li>写时复制技术允许父子进程读相同的物理页。只要两者中有一个试图写一个物理页，内核就把这个页的内容拷贝到一个新的物理页，并把这个新的物理页分配给正在写的进程。</li>
<li>轻量级进程允许父子进程共享进程在内核的很多数据结构，如页表、打开文件表及信号处理。</li>
<li>vfork()系统调用创建的进程能共享其父进程的内存地址空间。为了防止父进程重写子进程需要的数据，阻塞父进程的执行，一直到到子进程退出或执行一个新的程序为止。</li>
</ul>
<p><strong><em>clone()、fork()及vfork()系统调用</em></strong></p>
<p>在Linux中、轻量级进程是由名为clone()的函数创建的。</p>
<p>实际上，clone()是在C语言库中定义的一个封装（wrapper）函数，它负责建立新轻量级进程的堆栈并且调用对编程者隐藏的clone()系统调用。</p>
<p>传统的fork()系统调用和vfork()系统调用在Linux中也是用clone()实现的。</p>
<p><strong>内核线程</strong></p>
<p>因为一些系统进程只运行在内核太，所以现代操作系统把它们的函数委托给内核线程（kernel thread），内核线程不受不必要的用户态上下文的拖累。</p>
<p><strong><em>进程 0</em></strong></p>
<p>所有进程的祖先叫作进程0，idle进程，或因为历史的原因叫作swapper进程，它是在Linux的初始化阶段从无到有创建的一个内核线程。这个祖先进程使用下列静态分配的数据结构（所有其他进程的数据结构都是动态分配的）：</p>
<ul>
<li>存放在init_task变量中的进程描述符，由INIT_TASK宏完成对它的初始化</li>
<li>存放在init_thread_union变量中的thread__info描述符和内核堆栈，由INIT_THREAD_INFO宏完成对它们的初始化。。</li>
<li>由进程描述符指向的下列表：<ul>
<li>init_mm</li>
<li>init_fs</li>
<li>init_files</li>
<li>init_signals</li>
<li>init_sighand</li>
</ul>
</li>
<li>主内核页全局目录存放在swapper_pg_dir中。</li>
</ul>
<p>start_kernel()函数初始化内核需要的所有数据结构，激活中断，创建另一个叫进程1的内核线程（一般叫作init进程）。新创建内核线程的PID为1，并与进程0共享每个进程所有的内核数据结构。此外，当调度程序选择到它时，init进程开始执行init（）函数。</p>
<p>在多处理器系统中，每个CPU都有一个进程0.只要打开机器电源，计算机的BIOS就启动某一个CPU，同时禁用其他CPU。运行在CPU0还是上的swapper进程初始化内核数据结构，然后激活其他的CPU，并通过copy_process()函数创建另外的swapper进程，把 0 传递给新创建的swapper进程作为它们的新PID。</p>
<p><strong><em>进程 1</em></strong></p>
<p>由进程 0 创建的内核线程执行init()函数，init()依次完成内核初始化。init()调用execve()系统调用装入可执行程序init。结果，init内核线程变为一个普通进程，且拥有自己的每进程（per-process）内核数据结构。在系统关闭之前，init进程一直存活，因为它创建和监控在操作系统外层执行的所有进程的活动。</p>
<p><strong><em>其他内核线程</em></strong></p>
<p>Linux使用很多其他内核线程。其中一些在初始化阶段创建，一直运行奥系统关闭，而其他一些在内核必须执行一个任务时“按需”创建，这种任务在内核的执行上下文中得到很好的执行。</p>
<p><strong>进程删除</strong><br>Unix允许进程查询内核以获得其父进程的PID，或者其任何子进程的执行状态。</p>
<p>为了遵循这些设计选择，不允许Unix内核在进程一终止后就丢弃包含在进程描述符字段中的数据。只有父进程发出了与被终止的进程相关的wait（）类系统调用之后，才允许这样做。这就是引入僵死状态的原因：尽管从技术上来说进程已死，但必须保存它的描述符，直到父进程得到通知。</p>
<p>如果父进程在子进程结束之前结束会发生什么情况呢？在这种情况下，系统中会到处是僵死的进程，而且它们的进程描述符永久占据这RAM。所以这必须强迫所有的孤儿进程成为init进程的子进程来解决这个问题。这样，init进程在用wait（）类系统调用检查其合法的子进程终止时，就会撤销僵死的进程。</p>
<p>对僵死进程的处理有两种可能的方式：</p>
<ol>
<li>如果父进程不需要接收来自子进程的信号，就调用do_exit()。</li>
<li>如果已经给父进程发送了一个信号，就调用wait4（）或waitpid（）系统调用。</li>
</ol>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断通常分为<em>同步（synchronous）中断</em>和<em>异步（asynchronous）中断</em>：</p>
<ul>
<li>同步中断是指当指令执行时有CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。</li>
<li>异步中断是由其他硬件设备依照CPU时钟信号随机产生的。</li>
</ul>
<p>在Intel微处理器手册中，把同步和异步中断分别称为异常（exception）和中断（interrupt）。</p>
<p><strong><em>中断</em></strong></p>
<ul>
<li>可屏蔽中断（maskable interrupt）</li>
<li>非屏蔽中断（nonmaskable interrupt）</li>
</ul>
<p><strong><em>异常</em></strong></p>
<ul>
<li>故障（fault）</li>
<li>陷阱（trap）</li>
<li>异常中止（abort）</li>
<li>编程异常（programmed exception)</li>
</ul>
<p><strong>中断描述符表</strong></p>
<p>中断描述符表（Interrupt Descriptor Table, IDT）是一个系统表，它与灭一个中断或异常向量相联系，每一个向量在表中有相应的中断或异常处理程序的入口地址。</p>
<p>IDT包含三种类型的描述符。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/门描述符的格式.png" alt="门描述符"></p>
<p>这些描述符是：</p>
<p>任务门（task_gate)</p>
<p>​    当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。</p>
<p>中断门（interrupt gate)</p>
<p>​    包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，                             处理器清IF标志，从而关闭将来会发生的可屏蔽中断。</p>
<p>陷阱门（Trap gate）</p>
<p>​    与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志。</p>
<p><strong><em>Linux利用中断门处理中断，利用陷阱门处理异常</em></strong></p>
<p><strong>中断和异常处理程序的嵌套执行</strong></p>
<p>每个中断或异常都会引起一个内核控制路径，或者说代表当前进程在内核态执行单独的指令序列。内核控制路径可以任意嵌套：一个中断处理程序可以被另一个中断处理程序“中断”，因此引起内核控制路径的嵌套执行。如图所示。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/内核控制路径嵌套执行.png" alt="内核控制路径嵌套执行"></p>
<p>允许内核控制路径嵌套执行必须付出代价，那就是中断处理程序必须永不阻塞，换句话说，中断处理程序运行期间不能发生进程切换。事实上，嵌套的内核控制路径恢复执行时需要的所有数据都存放在内核态堆栈栈中，这个栈毫无疑义的属于当前进程。</p>
<p>一个中断处理程序既可以抢占其他的中断处理程序，也可以抢占异常处理程序。相反，异常处理程序从不抢占中断处理程序。</p>
<p>基于以下两个主要原因，Linux交错执行内核控制路径：</p>
<ul>
<li>为了提高可编程中断控制器和设备控制器的吞吐量。</li>
<li>为了实现一种没有优先级的中断模型。简化了内核代码，提高了内核的可移植性。</li>
</ul>
<p><strong>IRQ在多处理器系统上的分发</strong></p>
<p>Linux遵循对称多处理模型（SMP），这意味着，内核从内本质上对任何一个CPU都不应该有</p>
<p>偏爱。因而，内核试图以轮转的方式把来自硬件设备的IRQ信号在所有CPU之间分发。因此，所有CPU服务于I/O中断的执行时间片几乎相同。</p>
<p>在系统启动的过程中，引导CPU执行setup_IO_APIC_irqs()函数来初始化I/O APIC芯片。芯片的中断重定向表的24项被填充，以便根据“最低优先级”模式把来自I/O硬件设备的所有信号都传递给系统中的每个CPU。此外，在系统启动期间，所有的CPU都执行setup_local_APIC()函数，该函数处理本地APIC的初始化。特别是，每个芯片的任务优先级寄存器（TPR）都初始化为一个固定的值，这就意味着CPU愿意处理任何类型的IRQ信号，而不管优先级。Linux内核启动后再也不修改这个值。</p>
<p>因为所有的任务优先级寄存器都包含相同的值，因此，有所CPU总是具有相同的优先级。为了突破这种约束，多APIC系统使用本地APIC仲裁优先级寄存器中的值。因为这样的值在每次中断后都自动改变，因此，IRQ信号就公平地在所有CPU之间分发。</p>
<p>简而言之，当硬件设备发生了一个中断信号时，多APIC系统就选择其中的一个CPU，并把该信号传递给相应的本地APIC，本地APIC又依次中断它的CPU。这个事件不通报给其他所有的CPU。</p>
<hr>
<h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><p>可以把内核看作是不断对请求进行响应的服务器，这些请求可能来自在CPU上执行的进程，也可能来自发出中断请求的外部设备。这个类比强调内核的各个部分并不是严格按照顺序依次执行的，而是采用交错执行的方式。因此，这些请求可能引起竞争条件,而我们必须采用适当的同步机制对这种情况进行控制。</p>
<p><strong>内核抢占</strong></p>
<p>如果进程执行内核函数时，即它在内核态运行时，允许发生内核切换（被替换的进程是正执行内核函数的进程），这个内核就是抢占的。</p>
<p>使内核可抢占的目的是减少用户态进程的分派延迟（dispatch latency），即从进程变为可执行状态到它实际开始运行之间的时间间隔。</p>
<p><strong>内核使用的各种同步技术</strong></p>
<ul>
<li><p><strong>每CPU变量</strong></p>
<p>最好的同步技术是把设计不需要同步的内核放在首位。最简单也是最最重要的同步技术包括把内核变量声明为每CPU变量（per-cpu variable)。每CPU变量主要是数据结构的数组，系统的每个CPU对应数组的一个元素。</p>
<p>一个CPU不应该访问与其它CPU对应的数组元素，另外，它可以随意读或修改它自己的元素而不用担心出现竞争条件。但是，这也意味着每CPU变量基本上只能在特殊情况下使用，也就是当它确定在系统的CPU上的数据在逻辑上是独立的时候。</p>
<p>每CPU的数组元素在主存中被排列以使每个数据结构存放在硬件高速缓存的不同行，因此，对每CPU数组的并发访问不会导致高速缓存行的窃用和失效。</p>
<p>此外，在单处理器和多处理器系统中，内核抢占都可能使每CPU变量产生竞争条件。总的原则是内核控制路径应该在禁用抢占的情况下访问每CPU变量。</p>
</li>
<li><p><strong>原子操作</strong></p>
<p>若干汇编语言指令具有“读—修改—写”类型——也就是说，它们访问内存单元两次，第一次读原值，第二次写新值。</p>
<p>避免由于“读—修改—写”指令引起的竞争条件的最容易的方法，就是确保这样的操作在芯片级是原子的。任何一个这样 的操作都必须以单个指令执行，中间不嫩中断，且避免其他的CPU访问同一存储器单元。这些很小的原子操作（atomic opreations)可以建立在其他更灵活机制的基础之上以创建临界区。    </p>
<p>操作码前缀是lock字节（0xf0）的“读—修改—写”汇编语言指令即使在多处理器系统中也是原子的。当控制大暖检测到这个前缀时，就“锁定”内存总线，直到这条指令执行完成为止。因此，当枷锁的指令执行时，其他处理器不能访问这个内存单元。</p>
</li>
<li><p><strong>优化和内存屏障</strong></p>
<p>当使用优化的编译器时，编译器可能重新安排汇编语言指令以使寄存器以最优的方式使用。此外，现代CPU通常并行地执行若干条指令，且可能重新安排内存访问。这种重新排序可以极大地加速程序的执行。</p>
<p>然而，当处理同步时，必须避免指令重新排序。如果发放在同步原语之后的一条指令在同步原语本身之前执行，事情很快就会变得失控。事实上，所有的同步原语起优化和内存屏障的作用。</p>
<p><strong>优化屏障（memory barrier）</strong>原语保证编译程序不会混淆放在原语操作之前的汇编语言指令和放在原语操作之后的汇编语言指令。在Linux中，优化屏障就是barrier（）宏，它展开为asm volatile(“:::”memory”)。volatile关键字禁止编译器把asm指令与程序中的其他指令重新组合。memory关键字强制编译器假定RAM中的所有内存单元已经被汇编语言指令修改。因此，编译器不能使用存放在CPU寄存器中的内存单元的值来优化asm指令前的代码。</p>
<p><strong>内存屏障（memory barrier）</strong>原语确保，在原语之后的操作开始执行之前，原语之前的操作已经完成。因此，内存屏障类似于防火墙，让任何汇编语言指令都不能通过。</p>
<p>Linux使用六个内存屏障原语：</p>
<ul>
<li>rm()</li>
<li>rmb()</li>
<li>wmb()</li>
<li>smp_mb()</li>
<li>smp_rmb()</li>
<li>smp_wmb()</li>
</ul>
<p>这些原语也被当做优化屏障，因为我们必须保证编译程序不在屏障前后移动汇编语言指令。内存屏障原语的实现依赖与系统的体系机构。在80x86微处理器上，如果CPU支持lfence汇编语言指令，就把rmb（）宏展开为asm volatile（”lfence”)，否则就展开为asm volatile（”lock;addl $0,0(%%esp)”:::”memory”)。</p>
</li>
<li><p><strong>自旋锁</strong></p>
<p>一种广泛使用的同步技术是加锁（locking）。当内核控制路径必须访问共享数据结构或进入临界区时，就需要为自己获取一把”锁“。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/自旋锁.png" alt="自旋锁"></p>
<p>自旋锁（spin lock）是用来在多处理器环境中工作的一种特殊的锁。如果内核控制路径发现自旋锁”开着“，就获取锁并继续自己的执行。相反，如果内核控制路径发现锁由运行在另一个CPU上的内核控制路径”锁着“，就在周围”旋转“，反复执行一条紧凑的循环指令，直到锁被释放。</p>
<p>自旋锁的循环指令表示”忙等“。及时等待的内核控制路径无事可做（除了浪费时间），它也在CPU上保持运行。不过自旋锁通常非常方便，因为很多内核资源只锁1毫秒的时间片段。</p>
<p>一般来说，由自旋锁所保护的每个临界区都是禁止内核抢占的。在单处理器系统上，这种锁本身不起锁的作用，自旋锁原语仅仅是禁止或启用内核抢占。在自旋锁忙等期间，内核抢占还是有效的，因此，等待自旋锁释放的进程有可能被更高优先级的进程替代。</p>
<p>在Linux中，每个自旋锁都用spin_lock_t结构表示，其中包含两个字段：</p>
<p><strong>slock</strong>：该字段表示自旋锁的状态，值为1表示”未加锁“状态，而任何负数和0都表示”加锁“状态。</p>
<p><strong>break_lock</strong>：表示进程正在忙等自旋锁（只在内核支持SMP和内核抢占的情况下使用该标志）。</p>
</li>
<li><p><strong>读/写自旋锁</strong></p>
<p>读/写自旋锁的引入是为了增加内核的并发能力。只要没有内核控制路径对数据结构进行修改，读/写自旋锁就允许多个内核控制路径同时读同一数据结构。如果一个内核控制路径想对这个结构进行写操作，那么它必须首先获取读/写锁的写锁，写锁授权独占访问这个资源。当然，允许对数据结构并发读可以提高系统性能。</p>
</li>
<li><p><strong>顺序锁</strong></p>
<p>Linux2.6中引入了顺序锁（seqlock），它与读/写自旋锁非常相似，只是它为写着赋予了较高的优先级：事实上，即使在读者正在读的时候也允许写者继续运行。<em>这种策略的好处是写者永远不会等待（除非另一个写者正在写），缺点是有些时候读者不等不反复多次读相同的数据直到它获得有效的副本。</em></p>
<p>每个顺序所都是包括两个字段seqlock_t结构：一个类型为spin_lock_t的lock字段和一个整型的sequence字段，第二个字段是一个顺序计数器。**每个读者都必须在读数据前后两次读顺序计数器，并检查两次读到的值是否相同，如果不相同，说明新的写者已经开始写并增加了顺序计数器，因此暗示读者刚读到的数据是无效的。</p>
</li>
<li><p><strong>读—拷贝—更新（RCU）</strong></p>
<p>读—拷贝—更新（RCU）是为了保护在多数情况下被多个CPU读的数据结构而设计的另一种同步技术。RCU允许多个读者和写者并发执行。而且，RCU是不适用锁的，就是说，它不适用被所有CPU共享的锁或计数器，在这一点上与读/写自旋锁和顺序锁（由于高速缓存行窃用和失效而有很高的开销）相比，RCU具有更大的优势。</p>
<p>其关键思想包括限制RCU的范围：</p>
<ol>
<li>RCU只保护被动态分配并通过指针引用的数据结构</li>
<li>在被RCU保护的临界区中，任何内核控制路径都不能失眠。</li>
</ol>
</li>
<li><p><strong>信号量</strong></p>
<p>实际上，Linux提供两种信号量：</p>
<ul>
<li>内核信号量，由内核控制路径使用</li>
<li>System V IPC信号量，由用户态进程使用</li>
</ul>
<p>内核信号量类似于自旋锁，因为当锁关闭着时，它不允许内核控制路径继续进行。然而，当内核控制路径试图获取内核信号量所保护的忙资源时，相应的进程被挂起。只有在资源被释放时，进程才再次变为可运行的。因此，只有可以睡眠的的函数才能获取内核信号量，中断处理程序和可延迟函数都不能使用内核信号量。</p>
</li>
<li><p><strong>禁止本地中断</strong></p>
<p>确保一组内核语句被当做一个临界区处理的主要机制之一就是中断禁止。即使当硬件设备产生了一个IRQ信号时，中断禁止也让内核控制路径继续执行，因此，这就提供了一中有效的方式 ，确保中断处理程序访问的数据结构也受到保护。然而禁止本地中断并不保护运行在另一个CPU上的中断处理程序对数据结构的并发访问，因此，在多处理器系统上，禁止本地中断经常与自旋锁结合使用。</p>
</li>
<li><p><strong>禁止和激活可延迟函数</strong></p>
<p>禁止可延迟函数在一个CPU上执行的一种简单方式就是禁止在那个CPU上的中断。因为没有中断处理程序被激活，因此，软中断操作就不能异步地开始。</p>
</li>
<li><p>总结</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>技术</th>
<th>说明</th>
<th>使用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>每CPU变量</td>
<td>在CPU之间复制数结构</td>
<td>所有CPU</td>
</tr>
<tr>
<td>原子操作</td>
<td>对一个计数器原子地”读—修改—写“的指令</td>
<td>所有CPU</td>
</tr>
<tr>
<td>内存屏障</td>
<td>避免指令重新排序</td>
<td>本地CPU或所有CPU</td>
</tr>
<tr>
<td>自旋锁</td>
<td>加锁时忙等</td>
<td>所有CPU</td>
</tr>
<tr>
<td>信号量</td>
<td>加锁时阻塞等待（睡眠）</td>
<td>所有CPU</td>
</tr>
<tr>
<td>顺序锁</td>
<td>基于访问计数器的锁</td>
<td>所有CPU</td>
</tr>
<tr>
<td>本地中断的禁止</td>
<td>禁止单个CPU上的中断处理</td>
<td>本地CPU</td>
</tr>
<tr>
<td>本地软中断的禁止</td>
<td>禁止单个CPU上的可延迟函数处理</td>
<td>本地CPU</td>
</tr>
<tr>
<td>读—拷贝—更新（RCU)</td>
<td>通过指针而不是锁来访问共享数据结构</td>
<td>所有CPU</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="定时测量"><a href="#定时测量" class="headerlink" title="定时测量"></a>定时测量</h2><ul>
<li><p><strong>Linux计时体系结构</strong></p>
<p>Linux必定执行于定时相关的操作。例如，内核周期性地：</p>
<ul>
<li>更新自系统启动以来所经过的时间</li>
<li>更新时间和日期</li>
<li>确定当前进程在每个CPU上已运行了多长时间，如果已经超过了分配给它的时间，则抢占它。</li>
<li>更新资源使用统计数</li>
<li>检查每个软定时器的时间间隔是否已到。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>Linux与任何分时系统一样，通过一个进程到另一个进程的快速切换，达到表面上看来多个进程同时执行的神奇效果。</p>
<p>Linux的调度基于分时技术：多个进程以”时间多路服用“方式运行，因为CPU的时间被分成片”（slice）”，给每个可运行进程分配一片。如果当前运行进程的时间片或时限到期时，该进程还没有运行完毕，进程切换就可以发生。</p>
<p>传统上把进程分类为“<strong><em>I/O受限（I/O-bound）</em></strong>“或”<strong><em>CPU受限（CPU-bound）</em></strong>“。前者频繁地使用I/O设备，并花费很多时间等待I/O操作的完成；而后者则需要大量CPU时间的数据计算应用程序。</p>
<p>另一种分类法把进程分为三类：</p>
<ul>
<li><p><strong>交互式进程（interactive process）</strong></p>
<p>这些进程经常与用户进行交互，因此，要花很多时间等待键盘和鼠标操作。当接受了输入后，进程必须被很快唤醒，否则用户将发现系统反应迟钝。典型的交互式程序是命令shell、文本编辑程序及图形应用程序。</p>
</li>
<li><p><strong>批处理进程（batch process)</strong></p>
<p>这些进程不必与用户交互，因此经常在后台运行。典型的批处理进程是程序设计语言的编译程序、数据库搜索引擎及科学计算。</p>
</li>
<li><p><strong>实时进程（real-time process）</strong></p>
<p>这些进程有很强的调度需要。这样的进程绝不会被低优先级的进程阻塞，它们应该有一个很短的响应时间，更重要的是，响应时间的变化应该很小。典型的实时程序有视频和音频应用程序、机器人控制程序及从物理传感器上收集数据的程序。</p>
</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>每个Linux进程总是按照下面的调度类型被调度：</p>
<ul>
<li><p>SCHED_FIFO</p>
<p>先进先出的实时进程</p>
</li>
<li><p>SCHED_RR</p>
<p>时间片轮转的实时进程</p>
</li>
<li><p>SCHED_NORMAL</p>
<p>普通的分时进程</p>
</li>
</ul>
<h4 id="普通进程的调度"><a href="#普通进程的调度" class="headerlink" title="普通进程的调度"></a>普通进程的调度</h4><p>每个普通进程都有它自己的静态优先级，调度程序使用静态优先级来估计系统中这个进程与其他普通进程之间调度的程度。内核用从100（最高优先级）到139（最低优先级）的数表示普通进程的静态优先级。</p>
<p>基本时间片：</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/普通进程基本时间片.png" alt="时间片"></p>
<p>与优先级低的进程相比，通常优先级较高的进程获得更长额CPU时间片。</p>
<h4 id="实时进程的调度"><a href="#实时进程的调度" class="headerlink" title="实时进程的调度"></a>实时进程的调度</h4><p>每个实时进程都与一个实时优先级相关，实时优先级是一个范围从1（最高优先级）～99（最低优先级）的值。调度程序总是让优先级高的进程运行，换句话说，实时进程运行的过程中，禁止低优先级进程的执行。与普通进程相反，实时进程总是被当成活动进程。</p>
<p>只有在下述事件之一发生时，实时进程才会被另外一个进程取代：</p>
<ul>
<li>进程被另外一个具有更高实时优先级的实时进程抢占</li>
<li>进程执行了阻塞操作并进入睡眠</li>
<li>进程停止或被杀死</li>
<li>进程通过调用系统调用sched_yield()自愿放弃CPU</li>
<li>进程是基于时间片轮转的实时进程，而且用完了它的时间片。</li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>​    </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/架构学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/架构学习/" class="post-title-link" itemprop="url">架构学习</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:31:05" itemprop="dateModified" datetime="2019-07-06T17:31:05+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="定义架构"><a href="#定义架构" class="headerlink" title="定义架构"></a>定义架构</h2><p><strong>软件架构指软件系统的顶层结构</strong></p>
<p><em>相关概念</em></p>
<ol>
<li>系统是一群关联个体组成，这些“个体”可以是“子系统”、”模块“、”组件“等；架构需要明确系统包含哪些”个体“。</li>
<li>系统中的个体需要根据某种规则运作，架构需要明确个体运作和协作的规则。</li>
</ol>
<p>架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。</p>
<h2 id="架构设计的真正目的"><a href="#架构设计的真正目的" class="headerlink" title="架构设计的真正目的"></a>架构设计的真正目的</h2><p>整个软件技术发展的历史，其实就是一部与”复杂度“斗争的历史，架构的出现也不例外。简而言之，架构是为了应对软件系统负责度而提出的一个解决方案。<strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题。</strong></p>
<p>架构是为了应对软件系统复杂度而提出的一个解决方案。架构即（重要）决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体（人、财、物、时间、事情等）。架构各有千秋，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。</p>
<p>需求驱动架构。在分析设计阶段，需要考虑一定的人力与时间去”跳出代码，总揽全局“，为业务和IT技术之间搭建一座”桥梁”。</p>
<p>架构设计处于软件研制的前期，一方面，越是前期，就越早发现问题，修改的代价也就越低；另一方面，软件实施后期若有架构上的修改，也需要付出更多的代价。</p>
<h2 id="复杂度的来源"><a href="#复杂度的来源" class="headerlink" title="复杂度的来源"></a>复杂度的来源</h2><p>复杂度的来源主要有6个。</p>
<ul>
<li><p><strong>高性能</strong></p>
<p>对性能孜孜不倦的追求是整个人类技术不断发展的根本驱动力。软件系统中高性能带来的复杂度主要体现在两个方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多态计算机集群为了高性能带来的复杂度。</p>
<ul>
<li><p><strong>单机复杂度</strong></p>
<p>计算机内部复杂度最关键的地方就是操作系统，操作系统是软件系统的运行环境，操作系统的复杂度决定了软件系统的复杂度。</p>
<p>操作系统和性能最相关的是进程和线程。</p>
</li>
<li><p><strong>集群的复杂度</strong></p>
<p>通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器配合起来达到高性能的目的，是一个复杂的任务。</p>
<ol>
<li><p>任务分配</p>
<p>任务分配的意思是指每台机器都可以处理完成的业务任务，不同的任务分配到不同的机器上执行。</p>
<ul>
<li>需要增加任务分配器</li>
<li>任务分配器和真正的业务服务器之间有连接和交互</li>
<li>任务分配器需要增加分配算法。例如，轮询算法、按权重分配、或按照负载进行分配。</li>
</ul>
</li>
<li><p>任务分解</p>
<ul>
<li>简单的系统更加容易做到高性能</li>
<li>可以针对单个任务进行扩展</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>高可用</strong></p>
<p>维基百科的定义</p>
<blockquote>
<p>系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</p>
</blockquote>
<p>这个定义的关键在于“无中断”，但恰好难点也在“无中断”上面，因为无论是单个硬件还是单个软件，都不可能做到无中断，硬件会出故障，软件会老化；硬件会逐渐老化，软件会越来越复杂的庞大。</p>
<p>除了硬件和软件本质上无法做到”无中断“，外部环境导致的不可用更加不可避免、不受控制。例如、断点、水灾、的证。</p>
<p>系统的高可用方案五花八门，但万变不离其宗，<strong>本质上都是通过“ 冗余 ”来实现高可用。</strong>通俗点来讲，就是一台机器不够就两台，两台不够就四台;一个机房可能断电，那就部<br>署两个机房;一条通道可能故障，那就用两条，两条不够那就用三条(移动、电信、联通一起上)。高可用的 “ 冗余 ” 解决方案，单纯从形式上来看，和之前的高性能是一样的，都<br>是通过增加更多机器来达到目的，但其实本质上是有根本区别的: <strong>高性能增加机器目的在于“扩展”处理性能;高可用增加机器目的在于“冗余”处理单元 。</strong></p>
<p>通过冗余增强了可用性，但同事也带来了复杂性。</p>
<ul>
<li><p><strong>计算高可用</strong></p>
</li>
<li><p><strong>存储高可用</strong></p>
<p>对于需要存储数据的系统来说，整个系统的高可用设计关键点和难点就在于“存储高可用”。存储与计算相比，有一个本质上的区别: 将数据从一台机器搬到到另一台机器，需要经过线路<br>进行传输 。线路传输的速度是毫秒级别，同一机房内部能够做到几毫秒;分布在不同地方的机房，传输耗时需要几十甚至上百毫秒。例如，从广州机房到北京机房，稳定情况<br>下 ping 延时大约是 50ms ，不稳定情况下可能达到 1s 甚至更多。</p>
<p>综合分析，无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题;但如果完全<br>不做冗余，系统的整体高可用又无法保证，所以<strong>存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响 。</strong></p>
</li>
<li><p>高可用状态决策</p>
<p>无论是计算高可用还是存储高可用，其基础都是“ 状态决策 ”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。如果状态决策本身都是有错误或者有偏差的，那么后续的任何行动和处理无论多么完美也都没有意义和价值。但在具体实践的过程中，恰好存在一个本质的矛盾: 通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。</p>
<ol>
<li>独裁式</li>
<li>协商式</li>
<li>民主式</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>可扩展性</strong></p>
<p>可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。<br>由于软件系统固有的多变性，新的需求总会不断提出来，因此可扩展性显得尤其重要。在软件开发领域，面向对象思想的提出，就是为了解决可扩展性带来的问题;后来的设计模<br>式，更是将可扩展性做到了极致。得益于设计模式的巨大影响力，几乎所有的技术人员对于可扩展性都特别重视。<br>设计具备良好可扩展性的系统，有两个基本条件: 正确预测变化 、 完美封装变化 。但要达成这两个条件，本身也是一件复杂的事情。</p>
<ol>
<li><strong>预测变化</strong><ul>
<li>不能对每个设计点都考虑可扩展性</li>
<li>不能完全不考虑可扩展性</li>
<li>所有的预测都存在出错的可能性</li>
</ul>
</li>
<li><p><strong>应对变化</strong></p>
<p>将”变化“封装在一个”变化层”，将不变的部分封装在一个独立的“稳定层”。无论是变化层依赖稳定层，还是稳定层依赖变化层都是可以的，需要根据具体业务情况来设计。</p>
<ul>
<li>系统需要拆分出变化层和稳定层</li>
<li>需要设计变化层和稳定层之间的接口</li>
</ul>
</li>
</ol>
<p>设计模式的核心就是，封装变化，隔离可变性。</p>
</li>
<li><p><strong>低成本</strong></p>
<p>低成本给架构设计带来的复杂度主要体现在，往往只有“创新”才能达到低成本的目标。。这里的“创新”既包括开创一个全新的技术领域(这个要求对绝大部分公司太高)，也包括引入新技术，如果没有找到能够解决自己问题的新技术，那么就真的需要自己创造新技术了。</p>
</li>
<li><p><strong>安全</strong></p>
<p>安全本身是一个庞大而又复杂的技术领域，并且一旦出问题，对业务和企业形象影响非常大。</p>
<ul>
<li><p>功能安全</p>
<p>从实现的角度来看，功能安全更多地是和具体的编码相关，与架构关系不大。</p>
</li>
<li><p>架构安全</p>
<p>如果说功能安全是“防小偷”，那么 架构安全就是“防强盗” 。强盗会直接用大锤将门砸开，或者用炸药将围墙炸倒;小偷是偷东西，而强盗很多时候就是故意搞破坏，对系统的影响也大得多。因此架构设计时需要特别关注架构安全，尤其是互联网时代，理论上来说系统部署在互联网上时，全球任何地方都可以发起攻击。</p>
</li>
</ul>
</li>
<li><p><strong>规模</strong></p>
<p>规模带来复杂度的主要原因就是“量变引起质变” ，当数量超过一定的阈值后，复杂度会发生质的变化。</p>
<ol>
<li>功能越来越多，导致复杂度指数级上升</li>
<li>数据越来越多，系统复杂度发生质变</li>
</ol>
</li>
</ul>
<h2 id="架构设计三原则"><a href="#架构设计三原则" class="headerlink" title="架构设计三原则"></a>架构设计三原则</h2><ol>
<li><p><strong>合适原则</strong></p>
<p>合适原则宣言：“合适优于业界领先”。</p>
<p>真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。这也是很多 BAT 出来的架构师到了小公司或者创业团队反而做不出成绩的原因，因为没有了大公司的平台、资源、积累，只是生搬硬套大公司的做法，失败的概率非常高。</p>
</li>
<li><p><strong>简单原则</strong></p>
<p>简单原则宣言：“简单优于复杂”。</p>
<p>软件领域的复杂性体现在两个方面：</p>
<ul>
<li><p>结构的复杂性</p>
<p>结构复杂的系统几乎毫无例外具备两个特点：</p>
<p>1）组成复杂系统的组件数量更多</p>
<p>2）同时这些组件之间的关系也更加复杂</p>
</li>
<li><p>逻辑的复杂性</p>
</li>
</ul>
</li>
<li><p><strong>演化原则</strong></p>
<p>演化原则宣言：“演化优于一步到位”。</p>
<ul>
<li>首先 ，设计出来的架构要满足当时的业务需要。</li>
<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐晚上。</li>
<li>第三，当业务发生变化时，架构需要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等却可以在新架构中延续。</li>
</ul>
<p>架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全，或者盲目照搬大公司的做法。应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架<br>构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。<br>即使是大公司的团队，在设计一个新系统的架构时，也需要遵循演化的原则，而不应该认为团队人员多、资源多，不管什么系统上来就要一步到位，因为业务的发展和变化是很快<br>的，不管多牛的团队，也不可能完美预测所有的业务发展和变化路径。</p>
<p>合适优于先进&gt;演化优于一步到位&gt;简单优于复杂。</p>
</li>
</ol>
<h2 id="架构设计流程"><a href="#架构设计流程" class="headerlink" title="架构设计流程"></a>架构设计流程</h2><ol>
<li>识别复杂度</li>
<li>设计备选方案</li>
<li>评估和选择备选方案</li>
<li>详细方案设计</li>
</ol>
<h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><p>在具体的实践过程中，为了更快、更好地设计出优秀的架构，除了掌握这些基础知识外，还需要掌握业界已经成熟的各种架构模式。大部分情况下，我们做架构设计主要都是基于已有的成熟模式，结合业务和团队的具体情况，进行一定的优化或者调整;即使少部分情况我们需要进行较大的创新，前提也是需要对已有的各种架构模式和技术非常熟悉。</p>
<h3 id="高性能架构模式"><a href="#高性能架构模式" class="headerlink" title="高性能架构模式"></a>高性能架构模式</h3><h4 id="高性能数据库集群"><a href="#高性能数据库集群" class="headerlink" title="高性能数据库集群"></a>高性能数据库集群</h4><p>高性能数据库集群的第一种方式是 “ 读写分离 ” ，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力;第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。</p>
<h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>读写分离原理</p>
<p>读写分离的基本原理是将数据库读写操作分散到不同的节点上 ，下面是其基本架构图。</p>
<p>读写分离的基本实现是：</p>
<ul>
<li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li>
<li>数据库主机负责读写操作，从机只负责读操作</li>
<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</li>
<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li>
</ul>
<p>读写分离的实现逻辑并不复杂，但有两个细节点将引入设计复杂度: 主从复制延迟和分配机制 。</p>
<p><strong>复制延迟</strong></p>
<p>主从复制延迟会带来一个问题:如果业务服务器将数据写入到数据库主服务器后立刻( 1 秒内)进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。</p>
<p>解决主从复制延迟的集中常见的方法：</p>
<ol>
<li>写操作后的读操作指定发给数据库主服务器</li>
<li>读从机失败后再读一次主机</li>
<li>关键业务读写操作全部指向主机，非关键业务采用读写分离。</li>
</ol>
<p><strong>分配机制</strong></p>
<p>将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：程序代码封装和中间件封装。</p>
<ol>
<li><p>程序代码封装</p>
<p>程序代码封装指在代码中抽象一个数据访问层，实现读写操作分离和数据库服务器连接的管理</p>
</li>
<li><p>中间件封装</p>
<p>中间件封装指的是独立一套系统出来，实现读写操作和数据库服务器连接的管理。中间件对业务服务器提供SQL兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。</p>
</li>
</ol>
<p>读写分离分散了数据库读写操作的压力，但没有分散存储压力，当数据量达到千万甚至上亿条的时候，单台数据库服务器的存储能力会成为系统的瓶颈，主要体现在以下几个方面：</p>
<ul>
<li>数据量太大，读写的性能会下降，即使有索引，索引也会变得恨到，性能同样会下将。</li>
<li>数据文件会变得很大，数据库备份和恢复费需要耗费很长时间。</li>
<li>数据文件越大，极端情况下丢失数的风险越高。</li>
</ul>
<h5 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h5><p><strong>业务分库</strong></p>
<p>业务分库指的是按照业务模块将数据分散到不同的数据库服务器。 例如，一个简单的电商网站，包括用户、商品、订单三个业务模块，我们可以将用户数据、商品数据、订单数据分开放到三台不同的数据库服务器上，而不是将所有数据都放在一台数据库服务器上。</p>
<p>虽然业务分库能够分散存储和访问压力，但同时也带来了新的问题。</p>
<ol>
<li><p>join操作问题</p>
<p>业务分库后，原本在同一个数据库中的表分散到不同的数据库表中，导致无法使用SQL的join查询。</p>
</li>
<li><p>事务问题</p>
<p>原本在同一个数据库中不同的表可以在用一个事务中修改，业务分库后，表分散到不同的数据库中，无法通过事务统一修改。虽然数据库厂商提供了一些分布式事务的解决方案，但性能实在太低，与高性能存储的目标是相违背的。</p>
</li>
<li><p>成本问题</p>
<p>业务分库同时也带来了成本的代价，本来 1 台服务器搞定的事情，现在要 3 台，如果考虑备份，那就是 2 台变成了 6 台。</p>
</li>
</ol>
<p><strong>分表</strong></p>
<p>将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。</p>
<p>单表数据拆分有两种方式：<strong>垂直分表和水平分表</strong></p>
<h4 id="高性能NoSQL"><a href="#高性能NoSQL" class="headerlink" title="高性能NoSQL"></a>高性能NoSQL</h4><p>关系数据库存在以下缺点：</p>
<ul>
<li>关系数据库存储的是行为记录，无法存储数据结构</li>
<li>关系数据库的schema扩展很不方便</li>
<li>关系数据库在大数据场景下I/O较高</li>
<li>关系数据库的全文搜索功能较弱</li>
</ul>
<p>针对上述问题，分别</p>
<p>针对上述问题，分别诞生了不同的 NoSQL 解决方案，这些方案与关系数据库相比，在某些应用场景下表现更好。但世上没有免费的午餐， NoSQL 方案带来的优势，本质上是牺牲ACID中的某个或者某几个特性， 因此我们不能盲目地迷信NoSQL是银弹，而应该将NoSQL作为SQL的一个有力补充 ，NoSQL != No SQL，而是NoSQL = Not Only SQL。<br>常见的 NoSQL 方案分为 4 类。</p>
<ul>
<li>K-V存储:解决关系数据库无法存储数据结构的问题，以Redis为代表。</li>
<li>文档数据库:解决关系数据库强schema约束的问题，以MongoDB为代表。</li>
<li>列式数据库:解决关系数据库大数据场景下的I/O问题，以HBase为代表。</li>
<li>全文搜索引擎:解决关系数据库的全文搜索性能问题，以Elasticsearch为代表。</li>
</ul>
<h4 id="高性能缓存架构"><a href="#高性能缓存架构" class="headerlink" title="高性能缓存架构"></a>高性能缓存架构</h4><p>缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。</p>
<p>缓存的架构设计要点：</p>
<ul>
<li><p>缓存穿透</p>
<p>缓存穿透是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。</p>
</li>
<li><p>缓存雪崩</p>
<p>缓存雪崩是指当缓存失效（过期）后引起系统性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算,这个处理步骤<br>耗时几十毫秒甚至上百毫秒。而对于一个高并发的业务系统来说,几百毫秒内可能会接到几百上千个请求。由于旧的缓存已经被清除,新的缓存还未生成,并且处理这些请求的线程都不知道另外有一个线程正在生成缓存,因此所有的请求都会去重新生成缓存,都会去访问存储系统,从而对存储系统造成巨大的性能压力。这些压力又会拖慢整个系统,严重的会造成数据库宕机,从而形成一系列连锁反应,造成整个系统崩溃。</p>
</li>
<li><p>缓存热点</p>
<p>虽然缓存系统本身的性能比较高,但对于一些特别热点的数据,如果大部分甚至所有的业务请求都命中同一份缓存数据,则这份数据所在的缓存服务器的压力也很大。例如,某明星微博发布 “ 我们 ” 来宣告恋爱了,短时间内上千万的用户都会来观。<br>缓存热点的解决方案就是复制多份缓存副本,将请求分散到多个缓存服务器上,减轻缓存热点导致的单台缓存服务器压力 。</p>
</li>
</ul>
<h4 id="单服务器高性能模式"><a href="#单服务器高性能模式" class="headerlink" title="单服务器高性能模式"></a>单服务器高性能模式</h4><p>站在架构师的角度，需要特别关注高性能架构的设计。高性能架构设计主要集中在两方面：</p>
<ul>
<li>尽量提升单服务器的性能，将单服务器的性能发挥到极致</li>
<li>如果单服务器无法支撑性能，设计服务器集群方案</li>
</ul>
<p>除了以上两点，最终系统能否实现高性能，还和具体的实现及编码相关。但架构设计是高性能的基础，如果架构设计没有做到高性能，则后面的具体实现和编码能提升的空间是有限的。形象地说，架构设计决定了系统性能的上限，实现细节决定了系统性能的下限。</p>
<p>单服务器高性能的关键之一就是服务器采取的并发模型，并发模型有如下两个关键设计点：</p>
<ul>
<li>服务器如何管理连接</li>
<li>服务器如何处理请求。</li>
</ul>
<p>以上两个设计点最终都和操作系统的I/O模型及进程模型相关。</p>
<ul>
<li>I/O模型：阻塞、非阻塞、同步、异步</li>
<li>进程模型：单进程、多进程、多线程</li>
</ul>
<h5 id="PPC与TPC"><a href="#PPC与TPC" class="headerlink" title="PPC与TPC"></a>PPC与TPC</h5><p>PPC是Process Per Connection的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的UNIX网络服务器所采用的模型。基本的流程图是：</p>
<p>TPC 是 Thread Per Connection 的缩写,其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比,线程更轻量级,创建线程的消耗比进程要少得多;同时多线程是共享进程内存空间的,线程通信相比进程通信更简单。因此, TPC 实际上是解决或者弱化了 PPC fork 代价高的问题和父子进程通信复杂的问题。</p>
<h5 id="Reactor与Proactor"><a href="#Reactor与Proactor" class="headerlink" title="Reactor与Proactor"></a>Reactor与Proactor</h5><p>单服务器高性能的PPC和TPC模式，它们的优点是实现简单，缺点是都无法支撑高并发的场景。</p>
<p><strong>Reactor</strong></p>
<p>PPC 模式最主要的问题就是每个连接都要创建进程(为了描述简洁,这里只以 PPC 和进程为例,实际上换成 TPC 和线程,原理是一样的),连接结束后进程就销毁了,这样做其实是很大的浪费。为了解决这个问题,一个自然而然的想法就是资源复用,即不再单独为每个连接创建进程,而是创建一个进程池,将连接分配给进程,一个进程可以处理多个连接的业务。<br>引入资源池的处理方式后,会引出一个新的问题:进程如何才能高效地处理多个连接的业务?当一个连接一个进程时,进程可以采用 “read -&gt; 业务处理 -&gt; write” 的处理流程,如果当前连接没有数据可以读,则进程就阻塞在 read 操作上。这种阻塞的方式在一个连接一个进程的场景下没有问题,但如果一个进程处理多个连接,进程阻塞在某个连接的 read 操作上,此时即使其他连接有数据可读,进程也无法去处理,很显然这样是无法做到高性能的。<br>解决这个问题的最简单的方式是将 read 操作改为非阻塞,然后进程不断地轮询多个连接。这种方式能够解决阻塞的问题,但解决的方式并不优雅。首先,轮询是要消耗 CPU 的;其次,如果一个进程处理几千上万的连接,则轮询的效率是很低的。<br>为了能够更好地解决上述问题,很容易可以想到,只有当连接上有数据的时候进程才去处理,这就是 I/O 多路复用技术的来源。</p>
<p>I/O多路复用技术归纳起来有两个关键实现点：</p>
<ul>
<li>当多条链接共用一个阻塞对象后，进程只需要在一个是阻塞对象上等待，而无序再轮询所连接，常见的实现方式有select、epoll、kqueue等。</li>
<li>当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。</li>
</ul>
<p>I/O 多路复用结合线程池,完美地解决了 PPC 和 TPC 的问题,而且 “ 大神们 ” 给它取了一个很牛的名字: Reactor ,中文是 “ 反应堆 ” 。联想到 “ 核反应堆 ” ,听起来就很吓人,实际上这里<br>的“反应”不是聚变、裂变反应的意思,而是“ 事件反应 ”的意思,可以通俗地理解为“ 来了一个事件我就有相应的反应 ”,这里的“我”就是Reactor,具体的反应就是我们写的代码, Reactor 会根据事件类型来调用相应的代码进行处理。 Reactor 模式也叫 Dispatcher 模式(在很多开源的系统里面会看到这个名称的类,其实就是实现 Reactor 模式的),更加贴近模式本身的含义,即 I/O 多路复用统一监听事件,收到事件后分配( Dispatch )给某个进程。<br>Reactor 模式的核心组成部分包括 Reactor 和处理资源池(进程池或线程池),其中 Reactor 负责监听和分配事件,处理资源池负责处理事件。</p>
<p><strong>Proactor</strong></p>
<p>Reactor 是非阻塞同步网络模型,因为真正的 read 和 send 操作都需要用户进程同步操作。这里的 “ 同步 ” 指用户进程在执行 read 和 send 这类 I/O 操作的时候是同步的,如果把 I/O 操作改为异步就能够进一步提升性能,这就是异步网络模型 Proactor 。<br>Proactor 中文翻译为 “ 前摄器 ” 比较难理解,与其类似的单词是 proactive ,含义为 “ 主动的 ” ,因此我们照猫画虎翻译为 “ 主动器 ” 反而更好理解。 Reactor 可以理解为 “ 来了事件我通知你,你来处理”,而Proactor可以理解为“ 来了事件我来处理,处理完了我通知你 ”。这里的“我”就是操作系统内核,“事件”就是有新连接、有数据可读、有数据可写的这些I/O事件, “ 你 ” 就是我们的程序代码。</p>
<h4 id="高性能负载均衡"><a href="#高性能负载均衡" class="headerlink" title="高性能负载均衡"></a>高性能负载均衡</h4><p>单服务器无论如何优化,无论采用多好的硬件,总会有一个性能天花板,当单服务器的性能无法满足业务需求时,就需要设计高性能集群来提升系统整体的处理性能。<br>高性能集群的本质很简单,通过增加更多的服务器来提升系统整体的计算能力。由于计算本身存在一个特点:同样的输入数据和逻辑,无论在哪台服务器上执行,都应该得到相同的<br>输出。因此高性能集群设计的复杂度主要体现在任务分配这部分,需要设计合理的任务分配策略,将计算任务分配到多台服务器上执行。<br>高性能集群的复杂性主要体现在需要增加一个任务分配器,以及为任务选择一个合适的任务分配算法 。对于任务分配器,现在更流行的通用叫法是“负载均衡器”。但这个名称有一定的误导<br>性,会让人潜意识里认为任务分配的目的是要保持各个计算单元的负载达到均衡状态。而实际上任务分配并不只是考虑计算单元的负载均衡,不同的任务分配算法目标是不一样的,<br>有的基于负载考虑,有的基于性能(吞吐量、响应时间)考虑,有的基于业务考虑。考虑到 “ 负载均衡 ” 已经成为了事实上的标准术语,这里我也用 “ 负载均衡 ” 来代替 “ 任务分配 ” ,但请你时刻记住, 负载均衡不只是为了计算单元的负载达到均衡状态 。</p>
<h5 id="分类及架构"><a href="#分类及架构" class="headerlink" title="分类及架构"></a>分类及架构</h5><p>常见的负载均衡系统包括3种：DNS负载均衡、硬件负载均衡和软件负载均衡。</p>
<p><strong>DNS负载均衡</strong></p>
<p>DNS 是最简单也是最常见的负载均衡方式,一般用来实现地理级别的均衡。例如,北方的用户访问北京的机房,南方的用户访问深圳的机房。 DNS 负载均衡的本质是 DNS 解析同一个域名可以返回不同的 IP 地址。例如,同样是 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ,北方用户解析后获取的地址是 61.135.165.224 (这是北京机房的 IP ),南方用户解析后获取的地址是 14.215.177.38 (这是深圳机房的 IP )。</p>
<p><strong>硬件负载均衡</strong></p>
<p>硬件负载均衡是通过单独的硬件设备来实现负载均衡功能,这类设备和路由器、交换机类似,可以理解为一个用于负载均衡的基础网络设备。目前业界典型的硬件负载均衡设备有两款: F5 和 A10 。这类设备性能强劲、功能强大,但价格都不便宜,一般只有 “ 土豪 ” 公司才会考虑使用此类设备。普通业务量级的公司一是负担不起,二是业务量没那么大,用这些设备也是浪费。</p>
<p><strong>软件负载均衡</strong></p>
<p>软件负载均衡通过负载均衡软件来实现负载均衡功能,常见的有Nginx和LVS,其中Nginx是软件的7层负载均衡,LVS是Linux内核的4层负载均衡。4层和7层的区别就在于 协议 和 灵活性 ,Nginx支持HTTP、E-mail协议;而LVS是4层负载均衡,和协议无关,几乎所有应用都可以做,例如,聊天、数据库等。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>负载均衡算法数量较多,而且可以根据一些业务特性进行定制开发,抛开细节上的差异,根据算法期望达到的目的,大体上可以分为下面几类。</p>
<ul>
<li>任务平分类：负载均衡系统将收到的任务平均分配给服务器进行处理,这里的“平均”可以是绝对数量的平均,也可以是比例或者权重上的平均。<ul>
<li>轮询</li>
<li>加权轮询</li>
</ul>
</li>
<li>负载均衡类：负载均衡系统根据服务器的负载来进行分配,这里的负载并不一定是通常意义上我们说的“CPU负载”,而是系统当前的压力,可以用CPU负载来衡量,也可以用连接数、 I/O 使用率、网卡吞吐量等来衡量系统的压力。<ul>
<li>负载最低优先</li>
</ul>
</li>
<li>性能最优类：负载最低优先类算法是站在服务器的角度来进行分配的,而性能最优优先类算法则是站在客户端的角度来进行分配的,优先将任务分配给处理速度最快的服务器,通过这种方式达到最快响应客户端的目的。</li>
<li>Hash类：负载均衡系统根据任务中的某些关键信息进行 Hash 运算,将相同 Hash 值的请求分配到同一台服务器上,这样做的目的主要是为了满足特定的业务需求。<ul>
<li>源地址Hash</li>
<li>ID Hash</li>
</ul>
</li>
</ul>
<h3 id="高可用架构模式"><a href="#高可用架构模式" class="headerlink" title="高可用架构模式"></a>高可用架构模式</h3><h4 id="高可用存储架构"><a href="#高可用存储架构" class="headerlink" title="高可用存储架构"></a>高可用存储架构</h4><p>存储高可用方案的本质都是通过将数据复制到多个存储设备,通过数据冗余的方式来实现高可用,其复杂性主要体现在如何应对复制延迟和中断导致的数据不一致问题。</p>
<h5 id="双机架构"><a href="#双机架构" class="headerlink" title="双机架构"></a>双机架构</h5><p>常见的高可用存储架构有主备、主从、主主、集群、分区,每一种又可以根据业务的需求进行一些特殊的定制化功能,由此衍生出更多的变种。</p>
<ul>
<li><p>主备复制</p>
<p>主备复制是最常见也是最简单的一种存储高可用方案,几乎所有的存储系统都提供了主备复制的功能,例如 MySQL 、Redis 、 MongoDB 等。</p>
</li>
<li><p>主从复制</p>
<p>主从复制和主备复制只有一字之差, “ 从 ” 意思是 “ 随从、仆从 ” , “ 备 ” 的意思是备份。我们可以理解为仆从是要帮主人干活的,这里的干活就是承担 “ 读 ” 的操作。也就是说,主机负责读写操作,从机只负责读操作,不负责写操作。</p>
</li>
<li><p>双机切换</p>
<p>主备复制和主从复制方案存在两个共性的问题：</p>
<ul>
<li>主机故障后，无法进行写操作</li>
<li>如果主机无法恢复，需要人工指定新的主机角色</li>
</ul>
<p>双机切换就是为了解决这两个问题而产生的,包括主备切换和主从切换两种方案。简单来说,这两个方案就是在原有方案的基础上增加 “ 切换 ” 功能,即系统自动决定主机角色,并完<br>成角色切换。</p>
</li>
<li><p>主主复制</p>
<p>主主复制指的是两台机器都是主机,互相将数据复制给对方,客户端可以任意挑选其中一台机器进行读写操作,</p>
</li>
</ul>
<h5 id="集群和分区"><a href="#集群和分区" class="headerlink" title="集群和分区"></a>集群和分区</h5><p><strong>数据集群</strong></p>
<p>主备、主从、主主架构本质上都有一个隐含的假设:主机能够存储所有数据,但主机本身的存储和处理能力肯定是有极限的。</p>
<p>简单来说,集群就是多台机器组合在一起形成一个统一的系统,这里的 “ 多台 ” ,数量上至少是 3 台;相比而言,主备、主从都是 2 台机器。根据集群中机器承担的不同角色来划分,集群可以分为两类:数据集中集群、数据分散集群。</p>
<ol>
<li><p>数据集中集群</p>
<p>数据集中集群与主备、主从这类架构相似,我们也可以称数据集中集群为 1 主多备或者 1 主多从。无论是 1 主 1 从、 1 主 1 备,还是 1 主多备、 1 主多从,数据都只能往主机中写,而读操作可以参考主备、主从架构进行灵活多变。</p>
</li>
<li><p>数据分散集群</p>
<p>数据分散集群指多个服务器组成一个集群,每台服务器都会负责存储一部分数据;同时,为了提升硬件利用率,每台服务器又会备份一部分数据。</p>
</li>
</ol>
<p><strong>数据分区</strong></p>
<p>前面我们讨论的存储高可用架构都是基于硬件故障的场景去考虑和设计的,主要考虑当部分硬件可能损坏的情况下系统应该如何处理,但对于一些影响非常大的灾难或者事故来说,有可能所有的硬件全部故障。例如,新奥尔良水灾、美加大停电、洛杉矶大地震等这些极端灾害或者事故,可能会导致一个城市甚至一个地区的所有基础设施瘫痪,这种情况下基于硬件故障而设计的高可用架构不再适用,我们需要基于地理级别的故障来设计高可用架构,这就是数据分区架构产生的背景。</p>
<p>数据分区指将数据按照一定的规则进行分区,不同分区分布在不同的地理位置上,每个分区存储一部分数据,通过这种方式来规避地理级别的故障所造成的巨大影响。采用了数据分区的架构后,即使某个地区发生严重的自然灾害或者事故,受影响的也只是一部分数据,而不是全部数据都不可用;当故障恢复后,其他地区备份的数据也可以帮助故障地区快速恢复业务。</p>
<p>设计一个良好的数据分区架构，需要从多个方面去考虑。</p>
<ol>
<li>数据量</li>
<li>分区规则</li>
<li>复制规则</li>
</ol>
<h4 id="业务高可用的保障：异地多活架构"><a href="#业务高可用的保障：异地多活架构" class="headerlink" title="业务高可用的保障：异地多活架构"></a>业务高可用的保障：异地多活架构</h4><p>无论是高可用计算架构,还是高可用存储架构,其本质的设计目的都是为了解决部分服务器故障的场景下,如何保证系统能够继续提供服务。但在一些极端场景下,有可能所有服务器都出现故障。例如,典型的有机房断电、机房火灾、地震、水灾 …… 这些极端情况会导致某个系统所有服务器都故障,或者业务整体瘫痪,而且即使有其他地区的备份,把备份业务系统全部恢复到能够正常提供业务,花费的时间也比较长,可能是半小时,也可能是 12 小时。因为备份系统平时不对外提供服务,可能会存在很多隐藏的问题没有发现。如果业务期望达到即使在此类灾难性故障的情况下,业务也不受影响,或者在几分钟内就能够很快恢复,那么就需要设计异地多活架构。</p>
<p><strong>应用场景</strong></p>
<p>顾名思义,异地多活架构的关键点就是异地、多活,其中异地就是指地理位置上不同的地方,类似于 “ 不要把鸡蛋都放在同一篮子里 ” ;多活就是指不同地理位置上的系统都能够提供业务服务,这里的 “ 活 ” 是活动、活跃的意思。判断一个系统是否符合异地多活,需要满足两个标准:</p>
<ul>
<li>正常情况下，用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务。</li>
<li>某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务。</li>
</ul>
<p><strong>架构模式</strong></p>
<ul>
<li>同城异区</li>
<li>跨城异地</li>
<li>跨国异地</li>
</ul>
<h3 id="可扩展架构模式"><a href="#可扩展架构模式" class="headerlink" title="可扩展架构模式"></a>可扩展架构模式</h3><p>软件系统与硬件和建筑系统最大的差异在于软件是可扩展的,一个硬件生产出来后就不会再进行改变、一个建筑完工后也不会再改变其整体结构。例如,一颗 CPU 生产出来后装到一台 PC 机上,不会再返回工厂进行加工以增加新的功能;金字塔矗立千年历经风吹雨打,但其现在的结构和当时建成完工时的结构并无两样。相比之下,软件系统就完全相反,如果一个软件系统开发出来后,再也没有任何更新和调整,反而说明了这套软件系统没有发展、没有生命力。真正有生命力的软件系统,都是在不断迭代和发展的,典型的如 Windows 操作系统,从 Windows 3.0 到 Windows 95 到 Windows XP ,直到现在的 Windows 10 ,一直在跟着技术的发展而不断地发展。</p>
<h4 id="可扩展架构的基本思想和模式"><a href="#可扩展架构的基本思想和模式" class="headerlink" title="可扩展架构的基本思想和模式"></a>可扩展架构的基本思想和模式</h4><p><strong>可扩展的基本思想</strong></p>
<p>可扩展性架构的设计方法很多，但万变不离其宗，所有的可扩展性架构设计，背后的基本思想都可以总结为一个字：<strong>拆</strong></p>
<p>拆，就是将原来大一统的系统拆分成多个规模小的部分，扩展时只修改其中一个部分即可，无须整个系统到处都改，通过这种方式来减少改动范围，降低改动风险。</p>
<p>按照不同的思路来拆分软件系统，就会得到不同的架构。常见的拆分思路有如下三种：</p>
<ul>
<li>面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分</li>
<li>面向服务拆分：将系统提供的服务拆分，每个服务作为一部分</li>
<li>面向功能拆分：将系统提供的功能拆分，每个功能作为一部分</li>
</ul>
<p>理解这三种思路的关键就在于如何理解“流程”、“服务”、“功能”三者的联系和区别。从范围上来看，从大到小依次为：流程&gt;服务&gt;功能。</p>
<p>不同的拆分方式，本质上决定了系统的扩展方式。不同的拆分方式，将得到不同的系统架构，典型的可扩展系统架构有：</p>
<ul>
<li>面向流程拆分：分层架构</li>
<li>面向服务拆分：SOA、微服务</li>
<li>面向功能拆分：微内核架构</li>
</ul>
<h4 id="传统的可扩展架构模式：分层架构和SOA"><a href="#传统的可扩展架构模式：分层架构和SOA" class="headerlink" title="传统的可扩展架构模式：分层架构和SOA"></a>传统的可扩展架构模式：分层架构和SOA</h4><p><strong>分层架构</strong></p>
<p>分层架构是很常见的架构模式，也加N层架构，通常情况下，N至少是2层。例如，C/S架构、B/S脚骨。常见的是3层架构（例如，MVC、MVP架构），4层架构，5层脚骨的比较少见，一般是比较复杂的系统才会达到或者超过5层，比如操作系统内核架构。</p>
<p>按照分层架构进行设计时，根据不同的划分维度和对象，可以得到多种不同的分层架构。</p>
<ol>
<li><p>C/S架构、B/S架构</p>
<p>划分的对象是整个业务系统,划分的维度是用户交互,即将和用户交互的部分独立为一层,支撑用户交互的后台作为另外一层</p>
</li>
<li><p>MVC架构、MVP架构</p>
<p>划分的对象是单个业务子系统,划分的维度是职责,将不同的职责划分到独立层,但各层的依赖关系比较灵活。</p>
</li>
<li><p>逻辑分层架构</p>
<p>划分的对象可以是单个业务子系统,也可以是整个业务系统,划分的维度也是职责。虽然都是基于职责划分,但逻辑分层架构和 MVC 架构、 MVP 架构的不同点在于,逻辑分层架构中的层是自定向下依赖的。典型的有操作系统内核架构、TCP/IP架构。</p>
</li>
</ol>
<p>无论采取何种分层维度，分层架构设计最核心的一点就是需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构，这也是分层不能太多的原因。</p>
<p>分层架构之所以能够较好地支撑系统扩展，本质在于隔离关注点，即每个层中的组件只会处理本层的逻辑。但是，分层时要保证层与层之间的依赖是稳定的，才能真正支撑快速扩展。</p>
<p>分层结构的另外一个特点就是层层传递，也就是说一旦分层确定，整个业务流程是按照层进行依次传递的，不能 在层之间进行跳跃。这种约束的好处在于强制将分层依赖限定为两两依赖，降低了整体系统复杂度，但代价就是冗余，也就是说，不管这个业务多么简单，每层都必须要参与处理。langfei</p>
<p>分层架构另外一个典型的缺点就是性能，因为每一次l业务请求都需要穿越所有的架构分层，有一些事情是多余的，多少都会有一些性能的浪费。</p>
<p><strong>SOA</strong></p>
<p>SOA的全称是 Service Oriented Architecture，中文翻译为“面向服务的架构”。</p>
<p>SOA提出了3个关键概念</p>
<ul>
<li><p>服务</p>
<p>所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。</p>
</li>
<li><p>ESB</p>
<p>ESB的全称是 Enterprise Service Bus，中文翻译为“企业服务总线”。从名字就可以看出，ESB参考了计算机总线的概念。ESB将企业中各个不同的服务连接在一起。</p>
</li>
<li><p>松耦合</p>
<p>松耦合的目的是减少各个服务间的依赖和互相影响。</p>
</li>
</ul>
<h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>微服务是一种和SOA相似但本质上不同架构理念。</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>SOA</th>
<th>微服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务粒度</td>
<td>粗</td>
<td>细</td>
</tr>
<tr>
<td>服务通信</td>
<td>重量级，ESB</td>
<td>轻量级，例如，HTTP RESTful RPC</td>
</tr>
<tr>
<td>服务交付</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>应用场景</td>
<td>企业级</td>
<td>互联网</td>
</tr>
</tbody>
</table>
<p>Martin Fowle在他的微服务文章中，做了很好地提炼</p>
<blockquote>
<p>In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery.</p>
</blockquote>
<p><strong>微服务的陷阱</strong></p>
<ol>
<li>服务划分过膝，服务间关系复杂</li>
<li>服务数量太多，团队效率急剧下降</li>
<li>调用链太长，性能下降</li>
<li>调用链太长，问题定位困难</li>
<li>没有自动化支撑，无法快速交付</li>
<li>没有服务治理，微服务数量多了后台管理混乱</li>
</ol>
<h4 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h4><p>微内核脚骨（Microkernel Architecture），也被称为插件化架构（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品的应用。例如Eclipse这类IDE软件、UNIX这类操作系统、淘宝APP这类客户端软件。</p>
<p><strong>基本架构</strong></p>
<p>微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑。</p>
<p>微内核的基本架构示意图如下：</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Utur</p>
              <div class="site-description motion-element" itemprop="description">木龟想做一个哈皮程序猿。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Turtle-knight" title="GitHub &rarr; https://github.com/Turtle-knight" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:turtle.mugui@gmail.com" title="E-Mail &rarr; mailto:turtle.mugui@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://plus.google.com/木龟" title="Google &rarr; https://plus.google.com/木龟" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Utur</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
