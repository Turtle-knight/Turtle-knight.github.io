<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="木龟想做一个哈皮程序猿。">
<meta property="og:type" content="website">
<meta property="og:title" content="Utur的个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Utur的个人博客">
<meta property="og:description" content="木龟想做一个哈皮程序猿。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Utur的个人博客">
<meta name="twitter:description" content="木龟想做一个哈皮程序猿。">





  
  
  <link rel="canonical" href="http://yoursite.com/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Utur的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Utur的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">天天学习，好好向上</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Apache_Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Apache_Kafka/" class="post-title-link" itemprop="url">消息队列Kafka学习笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 16:50:18" itemprop="dateModified" datetime="2019-07-06T16:50:18+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p>Kafka是一款由美国领英公司（LinkedIn）开源出来的<strong>高性能消息引擎系统（Messaging system）</strong>,其核心功能是——<em>高性能的消息发送与高性能的消息消费</em>。但随着Kafka的不断演进，在Kafka 0.10.0.0版本正式推出了Kafka Streams，即流式处理组件。自此Kafka正式成为了一个流式处理框架。</p>
<hr>
<h2 id="前置知识背景"><a href="#前置知识背景" class="headerlink" title="前置知识背景"></a>前置知识背景</h2><h3 id="消息引擎系统"><a href="#消息引擎系统" class="headerlink" title="消息引擎系统"></a>消息引擎系统</h3><p>消息引擎，又叫消息队列，消息中间件等。</p>
<p>根据维基百科的定义，企业消息引擎系统（EMS）是企业发布的一组规范。公司使用这组规范实现在不同系统之间传递语义准确的消息。在实际使用场景中，消息引擎系统通常以软件接口为主要形式，实现了松耦合的异步式数据传递语义。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/消息引擎架构.png" alt="消息引擎"></p>
<hr>
<h3 id="消息引擎范型"><a href="#消息引擎范型" class="headerlink" title="消息引擎范型"></a>消息引擎范型</h3><p>根据维基百科定义，一个消息引擎范型是一个基于网络的架构范型，描述了消息引擎系统的两个不同的子部分是如何互连且交互的。如果把消息引擎系统的这两个子系统比喻成两座城市，那么传输协议就是需要铺设的沥青公路，而引擎范型决定了来往穿梭与这两座城市的路线。</p>
<p>最常见的两种消息引擎范型是<strong><em>消息队列模型</em></strong>和<strong><em>发布/订阅模型</em></strong>。</p>
<ul>
<li><p>消息队列（message queue）模型是基于队列提供消息传输服务的，多用于进程间通信以及线程间通信。该模型定义了消息队列、发送者和接收者，提供了一种点对点的消息传递方式，即发送者发送每条消息到队列的指定位置，接收者从指定位置获取消息。每条消息由一个发送者生产出来，且只被一个消费者处理。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/队列消息引擎模型.png" alt="消息队列模型"></p>
</li>
<li><p>发布/订阅模型(publish/subscribe),它有主题（topic）的概念：一个topic可以理解为逻辑语义相近的消息的容器。这种模型定义了类似于生产者/消费者这样的角色，即发布者和订阅者。发布者将消息生产出来发送到指定的topic中，所有订阅了该topic的订阅者都可以接收到该topic下的所有消息。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/发布订阅消息模型.png" alt="发布订阅"></p>
</li>
</ul>
<hr>
<h2 id="Kafka术语"><a href="#Kafka术语" class="headerlink" title="Kafka术语"></a>Kafka术语</h2><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>既然Kafka的核心功能就是消息引擎，那么对消息的设计日然是首当其冲的事情。Kafka在消息设计时特意避开了繁重的Java堆上内存分配，直接使用紧凑二进制字节数组ByteBuffer而不是独立的对象，因此至少能够访问多一倍的可用内存。</p>
<p>省去padding，java对对象保存的大开销以及可能的页缓存。</p>
<h3 id="topic和partiiton"><a href="#topic和partiiton" class="headerlink" title="topic和partiiton"></a>topic和partiiton</h3><p>从概念上来说，topic只是一个逻辑概念，代表了一类消息，也可以认为是消息被发送到的地方。通常可以使用topic来区分实际业务，比如业务A使用一个topic，业务B使用另一个topic。</p>
<p>Kafka中的topic通常都会被多个消费者订阅，出于性能的考量，Kafka并不是topic-message的两级结构，而是采取了topic-partition-message的三级结构来分散负载。从本质上来说，每个Kafka topic都由若干个partition组成。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/topic和partition.png" alt="topic和partition"></p>
<p>topic是由多个partition组成的，而Kafka的partition是不可修改的有序消息队列，也可以说是有序的消息日志。每个partition都有自己专属的partition号。用户对partition唯一能做的操作就是在消息序列的尾部追加写入消息。<strong>partition上的每条消息都会被分配一个唯一的序列号-该序列号被称为位移（offset）。位移信息可以唯一定位到某partition下的一条消息</strong></p>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>实际上，Kafka消费者也有位移（offset）的概念，但这两个offset属于不同的概念。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/消费者位移.png" alt="消费者位移"></p>
<p>每条消息在某个partition的位移是固定的，但消费该partition的消费者的位移会随着消费进度不断前移，但不能超过该分区最新一条消息的位移。</p>
<p><strong>从本质上看，Kafka中的一条消息其实就是一个&lt;topic,partition,offset&gt;三元组（tuple），通过该元组，可以在Kafka集群中找到位移对应的那条消息。</strong></p>
<h3 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h3><p>为了实现高可靠性，通过冗余机制——备份多份日志。这些备份日志在Kafka中被称为副本（replica），它们存在的唯一目的就是防止数据丢失。</p>
<p><strong>副本分为两类：领导者副本（leader replica）和追随者副本（follower replica）</strong>。follower replica是不能提供服务给客户端的，它只是被动地向领导者副本（leader replica）获取数据，一旦leader replica所在的broker宕机，Kafka会从剩余的replica中选举出新的leader继续提供服务。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/leadr-follower.png" alt="leader-follower"></p>
<h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p><strong>ISR的全称是 in-sync replica，就是与leader replica保持同步的replica集合。</strong></p>
<p>Kafka为partition动态维护一个replica集合。该集合中的所有replica保存的消息日志都与leader replica保护同步状态。<em>只有这个集合中的replica才能被选举为leader，也只有该集合中所有replica都接收到了同一条消息，Kafka才会将该消息置于“已提交”状态，即认为这条消息发送成功</em>。<strong>Kafka承诺只要这个集合中至少存在一个replica，那些”已提交“状态的消息就不会丢失。</strong></p>
<hr>
<h2 id="Kafka使用场景"><a href="#Kafka使用场景" class="headerlink" title="Kafka使用场景"></a>Kafka使用场景</h2><ul>
<li>消息传输</li>
<li>网站行为日志追踪</li>
<li>审计数据收集</li>
<li>日志收集</li>
<li>Event Sourcing</li>
<li>流式处理</li>
</ul>
<hr>
<h2 id="Kafka设计原理"><a href="#Kafka设计原理" class="headerlink" title="Kafka设计原理"></a>Kafka设计原理</h2><h3 id="broker端设计架构"><a href="#broker端设计架构" class="headerlink" title="broker端设计架构"></a>broker端设计架构</h3><p>broker是Apache Kafka最重要的组件，本质上它是一个功能载体（或服务载体），承载了绝大多数的Kafka服务。事实上，大多数的消息队列框架都有broker或已知类似的角色。一个broker通常是以服务器的形式出现的。</p>
<h4 id="消息设计"><a href="#消息设计" class="headerlink" title="消息设计"></a>消息设计</h4><ol>
<li><p><strong>消息格式</strong></p>
<p>V2版本分为<strong>消息</strong>和<strong>消息集合</strong>两个维度，不过消息集合的提法被消息批次所取代。V2版本中，它有一个专门的属于：RecordBatch。</p>
<p>V2版本消息格式</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/V2版本消息格式.png" alt="消息格式"></p>
<p>“可变长度”表示Kafka会根据具体的值来确定到底需要几字节保存。为了在序列化时降低使用的字节数，V2版本借鉴了Google ProtoBuffer中的Zig-zag编码方式，使得绝对值较小的整数占用字节数较少的字节。</p>
</li>
<li><p><strong>消息batch</strong></p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/V2版本消息batch格式.png" alt="消息batch"></p>
<ul>
<li>CRC值从消息层面被移除，放入batch这一层</li>
<li>PID、producer epoch和序列号等消息都是0.11.0.0版本为了实现幂等性producer和支持事务而一如的。</li>
</ul>
<p>通过使用mirco-batch，批次地发送消息，能大幅度地提高Kafka的吞吐量。</p>
</li>
</ol>
<hr>
<h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h4><p>Kafka是分布式的消息引擎集群环境，支持自动化的服务发现与成员管理。依赖于Apache Zookeeper实现，每当一个broker启动，它会将自己注册到Zookeeper下的一个节点。</p>
<ul>
<li><p>首先，每个broker在Zookeper下注册节点的路径是chroot/brokers/ids/&lt;broker.id&gt;。如果没有配置chroot，则路径是/broker/ids/&lt;broker.id&gt;。</p>
</li>
<li><p>其次，broker向Zookeeper中的注册消息以JSON格式保存。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"loacalhost"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">9092</span>,</span><br><span class="line">    <span class="attr">"jmx_port"</span>: <span class="number">9999</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="number">1499737197</span>,</span><br><span class="line">    <span class="attr">"endpoints"</span>: [</span><br><span class="line">        <span class="string">"CLIENT"</span>://host1:<span class="number">9092</span><span class="string">",</span></span><br><span class="line"><span class="string">        "</span>REPLICATION://HOST1:<span class="number">9093</span><span class="string">"</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    "</span>listener_security_protocol_map<span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>CLIENT<span class="string">": "</span>SSL<span class="string">",</span></span><br><span class="line"><span class="string">        "</span>REPLICATION<span class="string">": "</span>PLAINTEXT<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "</span>rack<span class="string">": "</span>dc1<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，Zookeeper临时节点的生命周期和客户端会话绑定。如果客户端会话失效，该临时节点就会自动被清除掉。Kafka正是利用Zookeeper临时节点来管理broker生命周期的。broker启动时在Zookeeper中创建对应的临时节点，同时还会创建一个监听器（listener）监听该临时节点的状态；一旦broker启动后，监听器会自动同步整个集群消息到该broker上；而一旦broker崩溃，它与Zookeeper的会话就会失效，导致临时节点被删除，监听器被触发，然后处理broker崩溃的后续事宜。这就是Kafka管理集群及其成员的主要流程。</p>
</li>
</ul>
<hr>
<h4 id="副本与ISR设计"><a href="#副本与ISR设计" class="headerlink" title="副本与ISR设计"></a>副本与ISR设计</h4><p>一个Kafka分区本质上就是一个备份日志，即利用多份相同的备份共同提供冗余机制来保持系统高可用性。这些备份在Kafka中被称为副本（replica）。</p>
<ul>
<li><p><strong>follower副本同步</strong></p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/副本位置信息.png" alt="副本位置信息"></p>
<ol>
<li><p>起始位移（base offset）：表示该副本当前所含第一条消息的位移</p>
</li>
<li><p><strong>高水印值（high watermark，HW</strong>）：副本高水印值。它保存了该副本最新一条已提交消息的位移。leader分区的HW值决定了副本中已提交消息的范围，也确定了consumer能够获取消息的消息上限。任何一个副本对象的HW值一定不大于其LEO值。Kafka对leader副本和follower副本的HW值更新机制是不同的。</p>
</li>
<li><p><strong>日志末端位移（log end offset，LEO）</strong>：副本日志中下一条待写入消息的offset。所有副本都需要维护自己的LEO信息。只有ISR中的所有副本都更新了对应的LEO之后，leader副本才会向右移动HW值表明消息写入成功。Kafka对leader副本和follower副本的LEO值更新机制也是不同的。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/副本同步流程.png" alt="副本同步流程"></p>
</li>
</ol>
</li>
<li><p><strong>水印（watermark）和leader epoch</strong></p>
<p>水印被称为高水印或高水位，通常被用在流水式处理领域，以表征元素或时间在基于时间层面上的进度。在Kafka中，水印的概念与时间无关，而与位置信息相关。严格来说，它表示的就是位置信息，即位移（offset）。</p>
<ul>
<li><p><strong>LEO更新机制</strong></p>
<ul>
<li><p><strong>follower</strong></p>
<p>follower副本不停地向leader副本所在broker发送FETCH请求，一旦获取消息，便写入自己的日志中进行备份。</p>
<p>Kafka设计了两套follower副本LEO属性：一套LEO属性保存在follower副本所在broker的缓存上；另一套LEO值保存在leader副本所在broker的缓存上。换句话说，leader副本所在broker的缓存上保存了该分区下所有follower副本的LEO属性值。</p>
<ol>
<li><p>follower副本端LEO更新</p>
<p>每当在底层日志新写入一条消息，其LEO值就会加1.</p>
</li>
<li><p>leader副本端的follower副本LEO更新</p>
<p>一旦leader接收到follower发送的FETCH请求，它首先会从自己的log中读取相应的数据，但是在给follower返回数据之前它先去更新follower的LEO。</p>
</li>
</ol>
</li>
<li><p><strong>leader</strong></p>
<p>每当在底层日志新写入一条消息，其LEO值就会加1.</p>
</li>
</ul>
</li>
<li><p><strong>HW更新机制</strong></p>
<p>前面说过，leader broker上保存了一套follower副本的LEO以及它自己的LEO。当尝试确定分区HW时，它会选出所有满足条件的副本，比较它们的LEO，并选择最小的LEO值作为HW值。</p>
</li>
<li><p><strong>图解Kafka备份原理</strong></p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/Kafka备份原理.png" alt="Kafka备份原理"></p>
</li>
<li><p><strong>基于水印机制的缺陷</strong></p>
<ul>
<li><strong>数据丢失</strong>：使用HW值来确定备份进度时其值的更新是在下一轮RPC中完成的。延迟一轮FETCH请求更新HW的值的设计使得followerHW值是异步延迟更新的，若在这个过程中leader发生变更，那么称为新leader的follower的HW值就有可能是过期的，使得clients端认为成功提交的消息被删除了。</li>
<li><strong>数据不一致/数据离散</strong>：leader端log和follower端的log数据不一致</li>
</ul>
</li>
<li><p><strong>leader epoch</strong></p>
<p><strong>上述两个问题的根本原因在于HW值被用于衡量副本备份的成功与否，以及在出现崩溃时作为日志截断的依据，但HW值的更新是异步延迟的，特别是需要额外的FETCH请求处理流程才能更新，这中间发生的任何崩溃都可能导致HW值的过期</strong></p>
<p>leader epoch，实际上是一对值(epoch，offset)。epoch表示leader的版本号，从0开始，当leader变更过1次时，epoch就会+1，而offset则对应于该epoch版本的leadre写入第一条消息的位移。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><ul>
<li><p><strong>协议设计</strong></p>
<p>所谓通信协议，就是实现client-server间或server-server间数据传输的一套规范。Kafka通信协议是基于TCP之上的二进制协议，这套协议提供的API表现为服务于不同功能的多种请求类型以及对应的相应。所有类型的请求和响应都是结构化的，有不同的初始类型构成。</p>
</li>
<li><p><strong>常见请求类型</strong></p>
<ol>
<li>PRODUCE请求</li>
<li>FETCH请求</li>
<li>METADATA请求</li>
</ol>
</li>
<li><p><strong>请求处理流程</strong></p>
<ul>
<li><p><strong>clients端</strong></p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/clients端处理流程.png" alt="cliens请求处理"></p>
</li>
<li><p><strong>broker端</strong></p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/broker端请求处理流程.png" alt="broker端请求处理"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="controller设计"><a href="#controller设计" class="headerlink" title="controller设计"></a>controller设计</h4><ul>
<li><p><strong>controller概览</strong></p>
<p>在一个Kafka集群中，某一个broker会被选举出来承担特殊的角色，即控制器。一如controller就是用来管理和协调Kafka集群的。具体来说，就是管理集群中所有分区的状态并执行相应的管理操作。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/controller架构.png" alt="controller架构"></p>
</li>
<li><p><strong>controller管理状态</strong></p>
<p>controller维护的状态分为两类：每台broker上的分区副本和每个分区的leader副本信息。从维度上看，这些状态可分为副本状态和分区状态。</p>
<ul>
<li><p><strong>副本状态机</strong></p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/副本状态机.png" alt="副本状态机"></p>
</li>
<li><p><strong>分区状态机</strong></p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/分区状态机.png" alt="分区状态机"></p>
</li>
</ul>
</li>
<li><p><strong>controller职责</strong></p>
<ol>
<li>更新集群元数据信息</li>
<li>创建topic</li>
<li>删除topic</li>
<li>分区重分配</li>
<li>preferred leader副本选举</li>
<li>topic分区扩展</li>
<li>broker加入集群</li>
<li>broker崩溃</li>
<li>受控关闭</li>
<li>controller leader选举</li>
</ol>
</li>
</ul>
<hr>
<h4 id="broker请求处理"><a href="#broker请求处理" class="headerlink" title="broker请求处理"></a>broker请求处理</h4><ul>
<li><strong>Reactor模式</strong></li>
</ul>
<p>Kafka broker处理请求的模式就是Reactor设计模式。Reactor设计模式是一种事件处理模式，旨在处理多个输入源同时发送过来的请求。Reactor模式中的服务处理器或分发器将入站请求按照多路复用的方式分发到对应的请求处理器。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/Reactor模式.png" alt="Reactor模式"></p>
<ul>
<li><p><strong>Kafka broker请求处理</strong></p>
<p>Kafka broker请求处理实现了Reactor模式。在Kafka中，每个broker都有一个acceptor线程和若干个processor线程。processor线程的数量是可以配置的。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/broker请求处理流程.png" alt="broker请求处理流程"></p>
</li>
</ul>
<hr>
<h3 id="producer端设计架构"><a href="#producer端设计架构" class="headerlink" title="producer端设计架构"></a>producer端设计架构</h3><h4 id="producer端基本数据结构"><a href="#producer端基本数据结构" class="headerlink" title="producer端基本数据结构"></a>producer端基本数据结构</h4><ul>
<li><p><strong>ProducerRecord</strong></p>
<p>一个ProducerRecord封装了一条待发送的消息（或称为记录）。</p>
<p>ProducerRecord由5个字段构成:</p>
<ol>
<li>topic：该消息所属的topic</li>
<li>partition：该消息所属的分区</li>
<li>key：消息key</li>
<li>value：消息体</li>
<li>timestamp：消息时间戳</li>
</ol>
</li>
<li><p><strong>RecordMetadata</strong></p>
<p>该数据结构表示Kafka服务器端返回给客户端的消息的元数据</p>
<ol>
<li>offset：消息在 分区日志中的位移信息</li>
<li>timesstamp：消息时间戳</li>
<li>topic/partition</li>
<li>checksum：消息CRC32码</li>
<li>serializedKeySize：序列化后消息的key字节数</li>
<li>serializedValueSize：序列化后消息value字节数</li>
</ol>
</li>
</ul>
<hr>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>如果把producer统一看成一个盒子，那么整个producer端的工作原理便如图所示。大体来说，用户首先构建待发送的消息对象ProducerRecord，然后调用KafkaProducer#send方法进行发送。KafkaProducer接收到消息后首先对其进行序列化，然后结合本地缓存的元数据信息一起发送给partitioner去确定目标分区，最后追加写入内存中的消息缓冲池。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/producer端的工作原理.png" alt="producer端的工作原理"></p>
<p>调用KafkaProducer.send执行的操作：</p>
<ol>
<li><p><strong>序列化+计算目标分区</strong></p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/producer序列化.png" alt="序列化"></p>
</li>
<li><p><strong>追加写入消息缓冲区</strong></p>
</li>
<li><p><strong>Sender线程预处理及消息发送</strong></p>
</li>
</ol>
<hr>
<h3 id="consumer端设计架构"><a href="#consumer端设计架构" class="headerlink" title="consumer端设计架构"></a>consumer端设计架构</h3><h4 id="consumer-group-状态机"><a href="#consumer-group-状态机" class="headerlink" title="consumer group 状态机"></a>consumer group 状态机</h4><p>新版本consumer依赖于broker端的组协调者coordinator来管理组内的所有consumer实例并负责把分配方案发到每个consumer上。分配方案由组内的leader consumer根据指定的分区分配策略指定的。</p>
<p>分区分配的操作在consumer端执行而非broker端的好处：</p>
<ol>
<li>便于维护与升级：如果在broker端实现，那么分配策略的变动势必要重启整个Kafka集群。生产环境中重启服务器的代价是很高的。</li>
<li>便于实现自定义策略：不同的策略由不同的逻辑实现。coordinator端代码不容易实现灵活可定制的分配逻辑</li>
<li>解耦了组管理与分区分配，coordinator负责组管理工作，而consumer程序负责分区分配。</li>
</ol>
<p>Kafka为每个consumer group定义了5个状态：</p>
<ul>
<li><strong>Empty</strong>：表明group下没有任何active consumer，但可能包含位移信息。</li>
<li><strong>PreparingRebalance</strong>：该状态表明group正在准备进行group rebalance。</li>
<li><strong>AwaitingSync</strong>：该状态表明所有成员都已经加入组并等待leader consumer发送分区分配方案。</li>
<li><strong>Stable</strong>：该状态表明group开始正常消费。此时group必须响应clients发送过来的任何请求。</li>
<li><strong>Dead</strong>：该状态表明group已经彻底废弃，group内没有任何成员并且group的所有元数据都已被删除。</li>
</ul>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/consumer group状态机.png" alt="consumer group状态机"></p>
<hr>
<h3 id="实现精确一次处理语义-exactly-once-semanties-EOS"><a href="#实现精确一次处理语义-exactly-once-semanties-EOS" class="headerlink" title="实现精确一次处理语义(exactly-once semanties, EOS)"></a>实现精确一次处理语义(exactly-once semanties, EOS)</h3><p>clients端常见的3种消息交付语义：</p>
<ol>
<li><strong>最多一次（ai most once）</strong>：消息可能丢失也可能被处理，但最多只会被处理一次</li>
<li><strong>至少一次（at last once）</strong>：消息不会丢失，但可能被多次处理</li>
<li><strong>精确一次（exactly once）</strong>：消息被处理且只会被处理一次。</li>
</ol>
<h4 id="幂等性producer（idempotent-producer）"><a href="#幂等性producer（idempotent-producer）" class="headerlink" title="幂等性producer（idempotent producer）"></a>幂等性producer（idempotent producer）</h4><p>幂等性producer是Apache Kafka 0.11.0.0版本用于实现EOS的一个利器。若一个操作执行多次的结果与只运行一次的结果是相同的，那么称该操作为幂等操作。引入幂等producer表示它的发送操作是幂等。瞬时的发送错可能导致produecer端出现重试，同一个消息被producer发送多次，但在broker端这条消息只会被写入日志一次。</p>
<p>幂等性producer的设计思路类似于TCP的工作方式。发送到broker端的每批消息都会被赋予一个序列号（sequence number）用于消息去重。但是和TCP不同的是，这个序列号不会被丢弃，相反Kafka会把它们保存在底层日志中，这样即使分区的leader副本挂掉，新选出来的leader broker也能执行消息去重工作。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/幂等性producer消息去重.png" alt="幂等性producer消息去重"></p>
<hr>
<h4 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h4><p>对事务的支持是Kafka实现EOS的第二个利器。引入事务使得clients端程序（无论是producer还是consumer）能够将一组消息放入一个原子性单元中统一处理。</p>
<p>处于事务中的这组消息能够从多个分区中消费，也可以发送到多个分区中。重要的是不论是发送还是消费，Kafka都能保证它们是原子性，即所有的写入操作幺妹全部成功，要么全部失败。</p>
<p>Kafka为实现事务要求应用程序必须提供一个唯一的id来表征事务。这个id被称为事务id，它必须在应用程序所有的会话上是唯一的。</p>
<p><img src="/2019/02/25/Apache_Kafka/utur/图片/picture_for_note/Apache_Kafka/跨分区事务提交与读取.png" alt="跨分区事务提交与读取"></p>
<p>PS：未完待续，后续深入学习再做补充</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Ubuntu快速配置工作环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Ubuntu快速配置工作环境/" class="post-title-link" itemprop="url">Ubuntu环境</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 16:42:11" itemprop="dateModified" datetime="2019-07-06T16:42:11+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Ubuntu/" itemprop="url" rel="index"><span itemprop="name">Ubuntu</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Ubuntu工作环境快速配置"><a href="#Ubuntu工作环境快速配置" class="headerlink" title="Ubuntu工作环境快速配置"></a>Ubuntu工作环境快速配置</h1><p>首先更新一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br></pre></td></tr></table></figure>
<h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><p>详情<a href="https://blog.csdn.net/JRRRJ/article/details/81082444" target="_blank" rel="noopener">https://blog.csdn.net/JRRRJ/article/details/81082444</a></p>
<p>将阿里源添加到<strong>sources.list</strong>中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure>
<p>保存退出，然后更新。</p>
<h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><p>在「软件和更新」-「附加驱动」选项卡中进行选择</p>
<h2 id="基础软件安装"><a href="#基础软件安装" class="headerlink" title="基础软件安装"></a>基础软件安装</h2><h3 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure>
<h4 id="vim-个人配置"><a href="#vim-个人配置" class="headerlink" title="vim 个人配置"></a>vim 个人配置</h4><p>.vimrc (保存在个人百度网盘快速配置Ubuntu环境文件夹)</p>
<h3 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h3><p><a href="https://blog.csdn.net/fx_yzjy101/article/details/80243710" target="_blank" rel="noopener">https://blog.csdn.net/fx_yzjy101/article/details/80243710</a></p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>
<h3 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h3><p><a href="https://blog.csdn.net/qq_15192373/article/details/81091278" target="_blank" rel="noopener">https://blog.csdn.net/qq_15192373/article/details/81091278</a></p>
<h3 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a>ipython</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ipython3</span><br></pre></td></tr></table></figure>
<h3 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h3><p>安装详情见<a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">flask官网</a></p>
<h3 id="Typora-Markdown编辑"><a href="#Typora-Markdown编辑" class="headerlink" title="Typora(Markdown编辑)"></a>Typora(Markdown编辑)</h3><p>安装详情见<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora官网</a></p>
<h3 id="Shutter-截图软件"><a href="#Shutter-截图软件" class="headerlink" title="Shutter(截图软件)"></a>Shutter(截图软件)</h3><p>详情见<a href="https://blog.csdn.net/qq_19339041/article/details/80058892" target="_blank" rel="noopener">https://blog.csdn.net/qq_19339041/article/details/80058892</a></p>
<h3 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h3><p>先卸载LibreOffice</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge libreoffice*</span><br></pre></td></tr></table></figure>
<p>下载安装访问<a href="http://www.wps.cn/product/wpslinux/" target="_blank" rel="noopener">WPS官网</a></p>
<h3 id="MySQL-amp-amp-Redis"><a href="#MySQL-amp-amp-Redis" class="headerlink" title="MySQL &amp;&amp; Redis"></a>MySQL &amp;&amp; Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure>
<h3 id="Wechat"><a href="#Wechat" class="headerlink" title="Wechat"></a>Wechat</h3><p><a href="https://www.cnblogs.com/dotnetcrazy/p/9124658.html" target="_blank" rel="noopener">Ubuntu 18.04 安装微信（Linux通用）</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Redis设计与实现（笔记）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Redis设计与实现（笔记）/" class="post-title-link" itemprop="url">Redis设计与实现（笔记）</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:21:00" itemprop="dateModified" datetime="2019-07-06T17:21:00+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis总体认识"><a href="#Redis总体认识" class="headerlink" title="Redis总体认识"></a>Redis总体认识</h2><p>Redis是一个速度非常快的非关系远程内存数据库，它不仅性能强劲，而且具有复制特性以及为解决问题而省的独一无二的数据模型。</p>
<hr>
<h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><h3 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h3><p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。</p>
<h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><p>每个sds.h/shshdr结构表示一个SDS值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">//等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/SDS.png" alt="SDS"></p>
<p>SDS遵循C字符串以空字符结尾的惯例，保存空字符串的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。<em>遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字函数库里面的函数</em></p>
<h4 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与Ｃ字符串的区别"></a>SDS与Ｃ字符串的区别</h4><ul>
<li><p><strong>常数复杂度获取字符串长度</strong></p>
<p>获取一个Ｃ字符串的长度，操作复杂度为Ｏ(N)。</p>
<p>获取一个SDS的长度复杂度为O(1)，因为SDS在len属性中记录了SDS本身的长度。</p>
<p>通过使用SDS而不是C字符串，<strong><em>确保了获取字符串长度的工作不会成为Redis的性能瓶颈。</em></strong></p>
</li>
<li><p><strong>杜绝缓冲区溢出</strong></p>
<p>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改的需求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。</p>
</li>
<li><p><strong>减少修改字符串时带来的内存重新分配次数</strong></p>
<ul>
<li><strong><em>空间预分配</em></strong>，用于优化SDS的字符串增长操作：当需要进行空间扩展时，程序不仅会为SDS分配修改时所必须要的空间，还会为SDS分配额外的未使用空间。<ul>
<li>如果对SDS进行修改之后，SDS的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性将和free属性的值相同。</li>
<li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间.。</li>
</ul>
</li>
<li><strong><em>惰性空间释放</em></strong>，用于优化SDS的字符串缩短操作：当API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。与此同时，SDS也提供了相应的API，可以在有需要时真正地释放SDS的未使用空间。所以不用担心惰性空间释放策略会造成内存浪费。通过使用惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</li>
</ul>
</li>
<li><p><strong>二进制安全</strong></p>
<p>所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。</p>
<p>通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。</p>
</li>
<li><p><strong>兼容部分C字符串</strong></p>
</li>
</ul>
<hr>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。Redis构建了自己的链表实现。链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用了链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p>
<h4 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h4><p>每个链表节点使用一个adlist.h/listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure>
<p>多个listNode可以通过prev和next指针组成双端链表。</p>
<p>使用adlist.h/list来持有链表的话，操作起来会更方便：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/链表.png" alt="链表"></p>
<p>Redis的链表实现的特性可以总结如下；</p>
<ul>
<li>双端</li>
<li>无环</li>
<li>带表头指针和表尾指针</li>
<li>带链表长度计数器</li>
<li>多态：链表节点使用void *指针来保存节点值，并且可以通过list结构的dup、match、free三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li>
</ul>
<hr>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。</p>
<p>字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。除了用来表示数据库之外，字典还是哈希键的底层实现之一。</p>
<h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>Redis字典使用的哈希表有dict.h/dictht结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size；</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>
<h5 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h5><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>(</span><br><span class="line">    	<span class="keyword">void</span> *val;</span><br><span class="line">    	<span class="keyword">uint64_t</span> u64;</span><br><span class="line">    	<span class="keyword">int64_t</span> s64;</span><br><span class="line">    )v;</span><br><span class="line">    <span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
<h5 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h5><p>Redis中的字典由dict.h/dict结构来表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx; <span class="comment">/*rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>
<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p>
<ul>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数。</li>
<li>privdata属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈细致的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(keyDup)（<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(valueDup)（<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)（<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)（<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)（<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure>
<p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/字典.png" alt="字典"></p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用<strong>MurmurHash2</strong>算法来计算键的哈希值。</p>
<h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接骑起来，这就要解决了键冲突的问题。</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/链地址.png" alt="链地址法"></p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成。<em>最终结果是将ht[0]包含所有键值对都迁移到ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</em></p>
<p>但是为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。</p>
<p>渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作摊到对字典的每个添加、删除、查找和更新操作之上，从而避免了集中式rehash而带来的庞大计算量。</p>
<hr>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表（skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O(logN)，最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树媲美，并且因为跳跃表的实现比平衡树更为简单，所以有不少程序都用跳跃表来代替平衡树。</p>
<ul>
<li><p>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</p>
</li>
<li><p>每个跳跃表节点的层高都是1至32之间的随机数</p>
</li>
<li><p>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</p>
</li>
<li><p>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</p>
</li>
</ul>
<hr>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>
<p>每个intset.h/inttset结构表示一个整数集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</em></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/整数集合.png" alt="整数集合"></p>
<p><strong>contents数组的真正类型取决于encoding属性的值</strong></p>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>当新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要进行升级（upgrade)，然后才能将新元素添加到整数集合里面。</p>
<p>升级分为三部进行：</p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的孔家你大小，并为新元素分配空间</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素继续放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>升级的好处：</p>
<ul>
<li><p>提升整数集合的灵活性，因为C语言是静态类型语言，为了避免类型错误，通常不会将两种不同类型的值放在同一个数据结构里面。</p>
</li>
<li><p>尽可能地节约内存，只在有需要的时候进行升级。</p>
</li>
</ul>
<hr>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是是小整数值，要么就是长度比较长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<p><strong>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构</strong>。一个压缩列表可以包含 任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p>
<p>压缩列表和压缩列表节点的构成</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/压缩链表及节点.png" alt="压缩列表和节点"></p>
<hr>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每个对象都用到了至少一种数据结构。</p>
<p><strong>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，可以针对不同的使用场景，为对像设置多种不同的数据结构实现，从而优化对象在不同场景的使用效率。</strong></p>
<p><strong>Redis的对象系统还实现了基于引用技术技术的内存回收机制</strong>，当程序不再使用某个对象的时候，这个对象所占用的内存就会被释放；另外，<em>Redis还通过引用技术技术实现了对象共享机制</em>，在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p>
<p><em>Redis的对象带有访问时间记录信息。</em></p>
<p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据结构有关的三个属性分别是type属性、encoding属性和ptr属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4'</span></span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><ol>
<li><p><strong>字符串对象</strong></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/字符串对象编码转换.png" alt="字符串对象转换"></p>
</li>
</ol>
<ol start="2">
<li><p><strong>列表对象</strong></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/列表对象编码转换.png" alt="列表对象编码转换"></p>
</li>
</ol>
<ol start="3">
<li><p><strong>哈希对象</strong></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/哈希对象编码转换.png" alt="哈希对象编码转换"></p>
</li>
</ol>
<ol start="4">
<li><p><strong>集合对象</strong></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/集合对象编码转换.png" alt="集合对象编码转换"></p>
</li>
</ol>
<ol start="5">
<li><p><strong>有序集合对象</strong></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/有序集合编码对象转换.png" alt="有序集合对象编码转换"></p>
</li>
</ol>
<hr>
<h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以 通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>
<hr>
<h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>对象的引用计数属性还带有对象共享的作用。目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象 包含了从0到9999的所有整数值，当需要用到这些字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。</p>
<hr>
<h2 id="单机数据库的实现"><a href="#单机数据库的实现" class="headerlink" title="单机数据库的实现"></a>单机数据库的实现</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">    //..</span><br><span class="line">    //服务器的数据库数量</span><br><span class="line">    int dbnum；</span><br><span class="line">    //一个数组，保存着服务器中的所有数据库</span><br><span class="line">    redisDb *Db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录客户端当前正在使用的数据库</span></span><br><span class="line">    redisDb *db；</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisClient</span><br></pre></td></tr></table></figure>
<p>redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/客户端与服务器.png" alt="客户端与服务器数据库关联"></p>
<hr>
<h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中redisDb结构中的dict字典保存了数据库中的所有键值对，这个字典被称为键空间（key space）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">//过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expores;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redicDb;</span><br></pre></td></tr></table></figure>
<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种对象。</li>
<li>所有针对数据库的操作，增删改查，实际上都是对键空间字典进行操作来实现的。</li>
<li>其他键空间操作<ul>
<li>维护操作<ul>
<li>读取键之后，服务器会更新键空间的命中（hit）次数或键空间不命中（miss）次数。</li>
<li>更新键的LRU（最后一次使用）时间。</li>
<li>键过期，删除</li>
<li>键被WATCH命令监视，修改后将键标记为脏（dirty），进行通知</li>
<li>键修改后，按配置发送相应的数据库通知</li>
</ul>
</li>
<li>设置键的生存时间或过期时间</li>
</ul>
</li>
</ul>
<hr>
<h4 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h4><p>惰性删除+定期删除</p>
<h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>惰性删除策略对CPU时间来说是友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行 ，并且删除的目标仅限与当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</p>
<p>惰性删除的缺点是：它对内存是最不友好的，如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会被释放。有内存泄露的危险。</p>
<h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>定期删除策略每隔一段时间执行一次过期键操作，并通过限制删除键执行的时长和频率来减少删除操作对CPU时间的影响。</p>
<h5 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h5><p>过期键的惰性删除策略由db.c/expirIfNeeded函数实现。</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/惰性删除键.png" alt="惰性删除"></p>
<h5 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h5><p>过期键的定期删除策略由<strong><em>redis.c/activeExpireCycle函数</em></strong>实现，每当Redis服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle就会被调用，它在规定时间内，分多次遍历服务器中的多个数据库，从数据库的expires字典中随机检查一部分建的过期时间，并删除其中的过期键。</p>
<h5 id="其余重点"><a href="#其余重点" class="headerlink" title="其余重点"></a>其余重点</h5><ul>
<li>执 行SAVE命令或者BGSAVE命令所产生的新RDB未见不会包含已经过期的键</li>
<li>执行BGREWRITEAOF命令所产生的重写AOF未见不会包含已经过期的键</li>
<li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾</li>
<li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键</li>
<li>从服务器及时发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li>
<li>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li>
</ul>
<hr>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p>
<p>为了解决这个为题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p>
<p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行。</p>
<h4 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h4><ul>
<li><p>SAVE命令：阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SAVE  //等待直到RDB文件创建完毕</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>BGSAVE命令：派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> BGSAVE  //派生子进程，并由子进程创建RDB文件</span></span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/载入文件判断流程.png" alt="载入文件判断流程"></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/创建和载入RDB文件.png" alt="RDB"></p>
<ul>
<li>RDB文件是一个经过压缩的二进制文件，由多个部分组成</li>
<li>对不同类型的键值对，RDB文件会使用不同的方式来保存它们</li>
</ul>
<hr>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only FIle）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据状态的。</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/AOF.png" alt="AOF"></p>
<p>####　AOF持久化的实现分为三步</p>
<ul>
<li><p><strong>命令追加</strong></p>
<p>当AOF持久化功能处于打开时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾</p>
</li>
<li><p><strong>AOF文件的写入与同步</strong></p>
<p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件时间负责接收客户端的命令请求，以及客户端发送命令回复，而时间事件则负责执行serverCron函数这样需要定时运行的函数。</p>
<p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲去里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。</p>
</li>
</ul>
<h4 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h4><p>因为AOF文件里包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的命令，就可以还原服务器关闭之前的数据库状态。</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/AOF载入.png" alt="AOFload"></p>
<h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/AOF后台重写.png" alt="AOF后台重写"></p>
<hr>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p>
<ul>
<li>文件事件（fileevent）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p><strong><em>Redis基于Reactor模式开发了自己的网络事件处理其器</em></strong>：这个处理器被称为文件事件处理器（flie event handler）：</p>
<ul>
<li><em>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字</em>，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应到（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作像相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性</strong></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/文件事件处理器及IO多路.png" alt="文件事件处理器及I/O多路复用"></p>
<hr>
<h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p>Redis的时间事件分为以下两类：</p>
<ul>
<li><em>定时事件</em>：让一段程序在指定的时间之后执行一次。</li>
<li><em>周期性事件</em>：让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>服务器将所有时间事件都放在一个无序链表（不按when属性的大小排序）中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<hr>
<h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度。</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/事件处理流程.png" alt="事件处理流程"></p>
<hr>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li>服务器状态结构使用clients链表链接多个客户端状态，新添加的客户端状态会被放到链表的末尾</li>
<li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态</li>
<li>输入缓冲区记录了客户端发送的命令请求，这个缓冲去的大小不能超过1GB</li>
<li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数</li>
<li>客户端有固定大小缓冲和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲去的最大大小不能超过服务器设置的硬性限制值。</li>
<li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性设置，那么客户端会被立即关闭；除此之外，客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭</li>
<li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭</li>
<li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭</li>
<li>载入AOF文件时使用的为2客户端在载入工作开始时动态创建，载入工作完毕之后关闭</li>
</ul>
<hr>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ul>
<li>一个命令请求从发送到完成主要包括以下步骤：<ol>
<li>客户端将命令请求发送给服务器；</li>
<li>服务器读取命令请求，并分析出命令参数</li>
<li>命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复</li>
<li>服务器将命令回复返回给客户端</li>
</ol>
</li>
<li>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERN信号，管理客户端资源和数据库状态，检查并执行持久化操作等等</li>
<li>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：<ol>
<li>初始化服务器状态</li>
<li>载入服务器配置</li>
<li>初始化服务器数据结构</li>
<li>还原数据库状态</li>
<li>执行事件循环</li>
</ol>
</li>
</ul>
<hr>
<h2 id="多机数据库的实现"><a href="#多机数据库的实现" class="headerlink" title="多机数据库的实现"></a>多机数据库的实现</h2><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system)可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/服务器与Sentinel系统.png" alt="服务器与Sentinel系统"></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/主服务器下线.png" alt="主服务器下线"></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/故障转移.png" alt="故障转移"></p>
<p><img src="/2019/02/25/Redis设计与实现（笔记）/utur/图片/picture_for_note/Redis设计与实现/主服务器降级.png" alt="原主服务器降级"></p>
<hr>
<p>后续深入学习再作补充     </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/关于《python源码剖析》笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/关于《python源码剖析》笔记/" class="post-title-link" itemprop="url">关于《python源码剖析》笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:46:59" itemprop="dateModified" datetime="2019-07-06T17:46:59+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近学习python，时不时会感叹这门语言的简洁和实用，不由得会好奇python的底层实现。偶然得知有《python源码剖析》这本书，便想从中窥视一二，囫囵吞枣一翻，虽谈不上洞彻肺腑，但着实获益不少。正所谓“好记性不如烂笔头”，故作此笔记。</p>
<p>这里带着几个问题：</p>
<ul>
<li>python是用C实现的（虽然现在还有用JPython，Pypy），那么C是怎么实现python的面向对象的特性的呢？</li>
<li>什么叫<em>“<strong>python里的东西都是对象</strong>“</em>，这个对象又是什么？</li>
<li>python是门解释型语言，那么python是怎么执行代码的呢？</li>
</ul>
<p>(ps：《python源码剖析》里剖析的是python2.5版本，与目前最新的版本存在不少差异》）</p>
<h2 id="Python的总体架构"><a href="#Python的总体架构" class="headerlink" title="Python的总体架构"></a>Python的总体架构</h2><p>但凡认识一个事物，总得先有一个感性的认识，才能进而深入了解。python也如此，先看看python的总体架构。</p>
<p><img src="https://image.littlechao.top/20180924130852000006.jpg" alt="Architecture"></p>
<p>内核模块、库、用户模块 + Interpreter = Python 。通过加载一些模块，库，然后对源代码进行编译，最后再执行编译得到的字节码 ，python便完成了一次运行。</p>
<p>不难看出，python的核心便是他的解释器，而核心中的核心便是它的Code Evealuator（字节码执行器）。</p>
<h2 id="Python对象"><a href="#Python对象" class="headerlink" title="Python对象"></a>Python对象</h2><p>对象是python中最核心的一个概念，在python的世界中，一切都是对象，一个整数是一个对象，一个字符串也是一个对象，更为奇妙的是，类型也是一种对象，整数类型是一个对象，字符串也是一个对象（这与我在C++，java中的认知有很大不同，之前的认知是：这是一个什么<em>类型</em>的对象）。也就是说，面向对象理论中的“类”和“对象”这两个概念在Python中都是通过Python内的对象来实现的。不得不说，这很美妙，也很让人深思。</p>
<p><em>对象的本质</em></p>
<blockquote>
<p>在计算机中，一个对象实际上就是一片被分配的内存空间，这些内存可能是连续的，也可能是离散的，这都不重要，重要的是这片内存在更高的层次上可以作为一个整体来考虑，这个整体就是一个对象，在这片内存中，存储着一系列的数据以及可以对这些数据进行修改或读取操作的一系列代码。    </p>
</blockquote>
<p><em>在Python中，对象就是C中的结构体在堆上申请的一块内存</em>。为了确保对象能被正确的garbage-collected:<strong>对象是不能被静态初始化的，也不能在栈空间上生存</strong>（惟一的例外就是类型对象，Python中所有的内建的类型对象（如整数型对象，字符串类型对象）都是被静态初始化的。）；<strong>并且只能通过特殊的macros（宏）和方法来访问。</strong></p>
<p>在Python中，一个对象一旦被创建了，那么它在内存中的大小和地址就是确定的了。这意味着那些需要容纳可变长度数据的对象只能在对象内维护一个指向一下指向一块可变大小的内存区域的指针。<strong>遵循这样的规则可以使通过指针维护对象的工作变得十分简单。</strong> <em>优秀的设计</em></p>
<h3 id="对象机制的基石——PyObject"><a href="#对象机制的基石——PyObject" class="headerlink" title="对象机制的基石——PyObject"></a>对象机制的基石——PyObject</h3><p>可以说，PyObject是整个Python对象机制的核心。</p>
<p><strong>python2.5</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[object.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span>&#123;</span></span><br><span class="line">	PyObject_HEAD</span><br><span class="line">&#125;PyObject;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_HEAD            \</span></span><br><span class="line">	_PyObject_HEAD_EXTRA         \</span><br><span class="line">	<span class="keyword">int</span> ob_refcent;              \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>  \</span></span><br></pre></td></tr></table></figure>
<p><strong>python3.6.5</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span>&#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span>        </span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p><em>整型变量ob_refcnt与Python的内存管理机制有关，它实现了Python基于引用技术的垃圾收集机制。</em></p>
<p><em>而ob_type是一个指向_typeobject结构体的指针，实际上这个结构体对应着Python内部的一个特殊的对象，它用来指定一个对象类型的类型对象。</em></p>
<p>再来看看可变对象PyVarObject的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject</span><br></pre></td></tr></table></figure>
<p>可以看出，PyVarObject实际上只是对PyObject的一个扩展而已。</p>
<p>至此，可以明确看出，Python对象机制的核心非常简单：<strong>引用计数 + 类型信息</strong>。</p>
<p>关于类型信息，看一段源码的注释：</p>
<blockquote>
<p>An object has a ‘type’ that determins what ir represents and what kind of data it contains. An ovject ‘type’ is fixed when it is created. Types themselves are represented as objects; an object contains a pointer to the corresponding type object. The type itself has type pointer pointing to the object represnting the type ‘type’, which contains a pointer to itself</p>
</blockquote>
<h3 id="对象里的特殊对象，类型对象——PyTypeObject。"><a href="#对象里的特殊对象，类型对象——PyTypeObject。" class="headerlink" title="对象里的特殊对象，类型对象——PyTypeObject。"></a>对象里的特殊对象，类型对象——PyTypeObject。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_typeobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line">    </span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    ......   </span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>
<p>在_typeobject的定义中包含了许多信息，主要可以分为4类：</p>
<ul>
<li>类型名，tp_name，主要是Python内部以及调试的时候使用。</li>
<li>创建该类型对象时分配内存空间大小的信息，即tp_basecsize和tp_itemsize。</li>
<li>与该类型对象相关联的操作信息（诸如tp_print这样的许多的函数指针）。</li>
<li>类型的类型信息。</li>
</ul>
<p>在python3.6.5源码的object.h文件中有这么一段注释</p>
<blockquote>
<p>/<em> PyObject_HEAD defines the initial segment of every PyObject. </em>/</p>
</blockquote>
<p>换句话说，在Python内部，每一个对象都拥有相同的对象头部。这就使得在Python中，对对象的引用变得非常的统一，只需要用一个PyObject *指针就可以引用任意的一个对象。而不论该对象实际是一个什么对象。</p>
<h3 id="Python对象的多态性"><a href="#Python对象的多态性" class="headerlink" title="Python对象的多态性"></a>Python对象的多态性</h3><p>到这里，Pyhton底层如何用C实现<em>多态</em>的已经跃然纸上了。</p>
<p>通过PyObject和PyTypeObject，Pyhton利用C语言完成了C++所提供的对象的多态的特性。在Python创建一个对象，比如PyIntObejct对象时，会分配内存，进行初始化。然后Python内部用一个PyObject<em>变量来保存和维护这个对象。其他对象也于此类似，所以在Python内部各个函数之间传递的都是一种范型指针——PyObject </em>。这个指针所指的对象究竟是什么类型，只能从指针所指对象的ob_type域动态进行判断，而正是通过这个域，Python实现了多态机制。</p>
<p>说了这么多，现在用图来捋一捋。毕竟，一图胜万言。</p>
<p>​                                                                         <strong>各种Object之间的联系</strong></p>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/Utur_PyObject.png" alt="Object">​       </p>
<p>​                                                               <strong>通过PyInt_Type创建整数</strong></p>
<p><img src="https://image.littlechao.top/20180927032505000012.jpg" alt="jiaohu"></p>
<p>​                                                                  <strong>运行时整数对象及其类型之间的关系</strong>(对照上图)</p>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/Utur_Integer.png" alt="Integer"></p>
<h3 id="Python内对象分类"><a href="#Python内对象分类" class="headerlink" title="Python内对象分类"></a>Python内对象分类</h3><p>关于Python内对象的分类，这里提供几种角度，不保证正确性。</p>
<h4 id="从概念上的角度"><a href="#从概念上的角度" class="headerlink" title="从概念上的角度"></a>从概念上的角度</h4><ul>
<li>Fundamental对象：类型对象</li>
<li>Numeric对象：数值对象</li>
<li>Sequence 对象：容纳其他对象的序列集合对象</li>
<li>Mapping 对象：类似于C++中map的关联对象</li>
<li>Internal 对象：Python虚拟机在运行时内部使用的对象</li>
</ul>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/object.png" alt="对象分类"></p>
<h4 id="从内存上的角度"><a href="#从内存上的角度" class="headerlink" title="从内存上的角度"></a>从内存上的角度</h4><p><strong>定长对象</strong>:不包含可变长度数据的对象（es，整数对象）</p>
<p><strong>变长对象</strong>:包含可变长度数据的对象（es，字符串对象）</p>
<p><em>区别：</em>定长对象的不同对象占用的内存是一样的（es，1和100），而变长对象的不同对象占用的内存可能是不一样的。（es，”Python“和”Java“)</p>
<p>实际上，在变长对象中，还可分为<em>可变对象</em>和<em>不可变对象</em>。可变对象维护的数据在对象在创建后还能再变化，比如一个list被创建后，可以向其中添加元素或删除元素，这些操作都会改变其维护的数据；而不可变对象所维护的数据在对象创建之后就不能再改变了，比如string和tuple。    </p>
<p>到这里，对对象的结构性认识已经差不多了，接下来，就是各种对象在具体实现上一些差异化了。</p>
<h3 id="Python内建对象"><a href="#Python内建对象" class="headerlink" title="Python内建对象"></a>Python内建对象</h3><p>在Python中，已经预先定义了一些类型对象，比如int类型、string类型、dict类型等</p>
<h4 id="PyIntObject对象"><a href="#PyIntObject对象" class="headerlink" title="PyIntObject对象"></a>PyIntObject对象</h4><p>先看个图</p>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/2018-09-28 21-36-35屏幕截图3.png" alt="PyIntObject"></p>
<p>内置函数id()用来返回对象的身份(identity)，而这里的身份说白了就是该对象的内存地址。</p>
<p>下面给出总结：</p>
<ul>
<li><strong>处于对Python性能和运行效率的考虑，对于频繁使用的小整数对象，Python采用了对象池技术。在小整数对象池中完全缓存了其PyIntObject对象，这意味着每一个对象池里的每一个PyIntObject对象都能够被任意的共享。</strong></li>
<li>小整数的范围可以被用户通过源码修改，默认的是[-5, 257)</li>
<li>对于其他整数，设计者们在时间与空间的两难选择上，作出的妥协是：Python运行环境提供一块内存空间（通用整数对象池），这些内存空间由这些大整数轮流使用。这样免去了不断地malloc之苦，又在一定程度上考虑了效率问题。</li>
<li>对于通用整数对象池，Python通过定义一个PyIntBlock结构，在这个结构的基础上，实现了一个单向列表。</li>
</ul>
<h5 id="通用整数对象池的实现基础——PyIntBlock"><a href="#通用整数对象池的实现基础——PyIntBlock" class="headerlink" title="通用整数对象池的实现基础——PyIntBlock"></a>通用整数对象池的实现基础——PyIntBlock</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[intobject.c]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> *<span class="title">next</span>;</span></span><br><span class="line">    PyIntObject object[N_INTOBJCETS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> <span class="title">PyIntBlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntBlock *block_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> PyIntObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>PyIntBlock，顾名思义，就是一块保存了N_INTOBJECTS个PyIntobject对象的内存（block）。</p>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/IntBlock.png" alt="PyIntBlock"></p>
<p>这里存在一个隐患：两个PyIntBlock处于同一个链表当中，但是每一个PyIntBlock中至光重要的存放PyIntObject对象的objects却是分离的。 若真是这样，就意味着所有的内存只能使用一次，跟内存泄漏也就没什么区别了。</p>
<p>Python的设计者当然不会允许这样的存在，所以才有了free，_list的存在。</p>
<p>在一个PyIntObject对象被销毁的时候（tp_dealloc），不同PyIntBlock中空闲的内存块被链接free_list里了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[intobject.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_dealloc</span><span class="params">(PyIntObject *v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyInt_CheckExact(v)) &#123;</span><br><span class="line">        v-&gt;ob_type = (struct _typeobject *)free_list;</span><br><span class="line">        free_list = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	v-&gt;ob_type-&gt;tp_free(PyObjcet *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以真相如图：</p>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/block.png" alt="free_list"></p>
<p>但是，这里还隐藏着Python的整数对象系统实现中的一个惊天隐秘：当一个整数对象的引用计数变为0时，就会被Python回收，但是在int_dealloc中，只是将该内存重新加入自由内存链表中， 却不是向系统堆交还任何内存。那么，理论上，是可以利用这个漏洞将系统的内存全部吃光的。只要你定义足够多的大整数对象。</p>
<h4 id="PythonStringObject对象"><a href="#PythonStringObject对象" class="headerlink" title="PythonStringObject对象"></a>PythonStringObject对象</h4><p>在Python中，PyStringObject是对字符串对象的实现。PyStringObejct是一个拥有可变长度内存的对象，这一点毋庸置疑。但同时，其又是一个不变对象。因为当创建了一个PyStringObject对象之后，该对象内部维护的字符串就不能再被改变了。这一点特性使得PyStringObject对象可作为dict的键值，但同时也使得一些字符串操作的效率大大降低，比如多个字符串的连接。</p>
<p><strong>PythonStirngObejct</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[stringobejct.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObejct_VAR_HEAD</span><br><span class="line">    <span class="keyword">long</span> ob_shash;</span><br><span class="line">    <span class="keyword">int</span> ob_sstate;</span><br><span class="line">    <span class="keyword">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line">&#125; PyStringObject;</span><br></pre></td></tr></table></figure>
<ul>
<li>ob_shash：缓存该对象的hash值，避免每一次都重新计算该字符串对象的hash值。初始值为-1</li>
<li>ob_sstate：标记了该对象是否已经过intern机制的处理。</li>
<li>ob_sval：实际上是作为一个字符指针指向一段内存，这段内存保存着这个字符串对象所维护的实际字符串，显然，这段内存不会只是一个字节。而这段内存的实际长度（字节），正是有ob_size来维护，这个机制是Python中所有变长对象的实现机制。</li>
</ul>
<h5 id="intern机制"><a href="#intern机制" class="headerlink" title="intern机制"></a>intern机制</h5><p>对PyStringObject对象做intern操作目的在于：在Python运行期间，系统中只有一个与特定字符串对应的PyStringObject对象。当判断两个PyStringObject对象是否相同，如果都被intern处理过了，只需简单地检查对应PyObject *是否相同即可。这个机制既节省了空间，又简化了PyStringObejct对象的比较。</p>
<p><strong>Python会对简单的字符串进行intern，并将intern的结果放入对象缓存池中。</strong></p>
<p><strong><em>简单的字符串：空串，字符，只包含字母或数字</em></strong></p>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/string.png" alt="string"></p>
<p><strong><em>总结：类似于小整数对象，Python会选择性地对一些字符串进行池化，以减少对象的数量和对内存的占用。</em></strong></p>
<h5 id="PyStringObejct效率相关问题"><a href="#PyStringObejct效率相关问题" class="headerlink" title="PyStringObejct效率相关问题"></a>PyStringObejct效率相关问题</h5><p>一个严重影响python执行效率的问题——字符串连接”+”操作</p>
<p>根源 ：PyStringObject对象是一个不可变对象，若要连接<strong>N</strong>个PyStringObject对象，那么必须进行N-1次的内存申请及内存搬运的工作。可想而知，这是多大的工作量，必将严重影响Python的执行效率。</p>
<p>官方推荐的做法是通过利用join来对N个存在list或tuple的PyStringObejct对象进行连接操作，先统计一共有多少个PyStirngObejct对象，并统计这些对象所维护的字符串一共有多长，然后申请内存。这种做法只需要分配一次内存，执行效率将大大提高</p>
<p>看下实际运行情况：</p>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/time.png" alt="time">        </p>
<p><em>可以看出在N较小的情况下，”+”操作效率比join还高</em>。</p>
<p><strong>总结：”+”连接效率低是出现在字符串数目较多的情况，而在字符串数目较小的情况下，”+”比join执行效率还高。</strong></p>
<h4 id="PyListObject"><a href="#PyListObject" class="headerlink" title="PyListObject"></a>PyListObject</h4><p>PyListObject对象是Python提供的对列表的抽象，它可以有效地支持对元素的插入，添加，删除等操作，在Python的列表中无一例外存放的都是PyObject *指针。很明显，PyListObject是一个变长对象，而且还是个可变对象。</p>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated</span><br><span class="line">&#125; PylistObject</span><br></pre></td></tr></table></figure>
<ul>
<li>**ob_item：指针指向元素列表所在的内存块的首地址</li>
<li>allocated：维护了当前列表的可容纳的元素的总数</li>
<li>ob_size：实际被使用的内存的数量</li>
</ul>
<p>对于一个PyListObject对象，存在以下关系：</p>
<p><strong>0 &lt;= ob_size &lt;= allocated</strong></p>
<p><strong>len(list) == ob_size</strong></p>
<p><strong>ob_item == NULL 意味着 ob_size == allocated == 0</strong></p>
<p>由此可以窥探Python对PyListObejct所采的内存管理策略和C++中vector采取的内存管理策略是一致的：<strong>总会申请一大块内存，而不是存了多少就申请对应大小的内存。</strong></p>
<h5 id="PyListObject的创建"><a href="#PyListObject的创建" class="headerlink" title="PyListObject的创建"></a>PyListObject的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PyList_New(Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    PyListObject *op;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> initialized = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        Py_AtExit(show_alloc);</span><br><span class="line">        initialized = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为PyListObject对象申请空间</span></span><br><span class="line">     <span class="keyword">if</span> (numfree) &#123;</span><br><span class="line">        <span class="comment">// 缓冲池可用</span></span><br><span class="line">        numfree--;</span><br><span class="line">        op = free_list[numfree];</span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_ALLOC_COUNT		</span></span><br><span class="line">        count_reuse++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓冲池不可用</span></span><br><span class="line">        op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOW_ALLOC_COUNT</span></span><br><span class="line">        count_alloc++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        op-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, <span class="keyword">sizeof</span>(PyObject *));</span><br><span class="line">        <span class="keyword">if</span> (op-&gt;ob_item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(op);</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_SIZE(op) = size;</span><br><span class="line">    op-&gt;allocated = size;</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出PyListObject对象的创建主要分两步：</p>
<ul>
<li>为PyListObject对象申请空间：<ol>
<li>若缓冲池有可用对象，则使用这个可用对象</li>
<li>缓冲池无可用对象，通过PyObject_GC_New在系统堆中申请内存。</li>
</ol>
</li>
<li>为PyListObject对象中维护的元素列表申请空间</li>
</ul>
<p>PS:默认情况下，缓冲池free_lists中最多会维护80个PyListObject对象。</p>
<h5 id="PyListObject对象缓冲池"><a href="#PyListObject对象缓冲池" class="headerlink" title="PyListObject对象缓冲池"></a>PyListObject对象缓冲池</h5><p>同PyIntObject类似，PyListObject也是在被销毁的过程中加入缓冲池。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[listobject.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">list_dealloc(PyListObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject_GC_UnTrack(op);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(op)</span><br><span class="line">    / :销毁PyListObject对象维护的元素列表</span><br><span class="line">    <span class="keyword">if</span> (op-&gt;ob_item != <span class="literal">NULL</span>) &#123; </span><br><span class="line">        i = Py_SIZE(op);</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        PyMem_FREE(op-&gt;ob_item);</span><br><span class="line">    &#125;</span><br><span class="line">    / ：释放PyList自身</span><br><span class="line">    <span class="keyword">if</span> (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op))</span><br><span class="line">        free_list[numfree++] = op;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line">    Py_TRASHCAN_SAFE_END(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出，与创建相对应，销毁也主要分为两步：</p>
<ul>
<li>销毁PyListObject对象维护的元素列表，向系统堆归还内存，以时间换取空间</li>
<li>释放PyListObject自身：<ol>
<li>若缓冲池未满，则将该对象放入缓冲池，以备后用</li>
<li>若满了，则调用自身的tp_free方法进行释放</li>
</ol>
</li>
</ul>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/listcache.png" alt="list_cache"></p>
<h4 id="PyDictObject对象"><a href="#PyDictObject对象" class="headerlink" title="PyDictObject对象"></a>PyDictObject对象</h4><h2 id="Python虚拟机"><a href="#Python虚拟机" class="headerlink" title="Python虚拟机"></a>Python虚拟机</h2><p>关于Python，有一种说法：“Python是一种解释性的语言”。其实这种说法是不准确的，因为Python程序的执行原理和Java程序、C#程序的执行原理都可以用两个词囊括——<strong>虚拟机、字节码。</strong>实际上，Python解释器在执行任何一个Python程序文件时，都先对Python源代码进行编译，编译生成一组Python的byte code（字节码），然后由虚拟机按照顺序执行字节码，从而完成对Python程序的执行动作。</p>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/Pythonrun.png" alt="Python_run"></p>
<h3 id="PyCodeObject对象和pyc文件"><a href="#PyCodeObject对象和pyc文件" class="headerlink" title="PyCodeObject对象和pyc文件"></a>PyCodeObject对象和pyc文件</h3><p>在编译过程中，包含在Python源代码中的<strong>静态信息</strong>都会被Python编译器收集起来，这些静态信息包括了<strong>字符串、常量值、字节码</strong>。在Python运行期间，<em>这些源文件提供的静态信息被存储在一个运行时的对象中——<strong>PyCodeObject</strong></em>。<em>当运行结束后，这个运行时对象所包含的信息被存储在一种文件中(当有import语句时）——<strong>pyc文件</strong></em></p>
<p>Python源码中对PyCodeObject的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">int</span> co_argcount;		<span class="comment">/* #arguments, except *args */</span></span><br><span class="line">    <span class="keyword">int</span> co_kwonlyargcount;	<span class="comment">/* #keyword only arguments */</span></span><br><span class="line">    <span class="keyword">int</span> co_nlocals;		<span class="comment">/* #local variables */</span></span><br><span class="line">    <span class="keyword">int</span> co_stacksize;		<span class="comment">/* #entries needed for evaluation stack */</span></span><br><span class="line">    <span class="keyword">int</span> co_flags;		<span class="comment">/* CO_..., see below */</span></span><br><span class="line">    <span class="keyword">int</span> co_firstlineno;   <span class="comment">/* first source line number */</span></span><br><span class="line">    PyObject *co_code;		<span class="comment">/* instruction opcodes */</span></span><br><span class="line">    PyObject *co_consts;	<span class="comment">/* list (constants used) */</span></span><br><span class="line">    PyObject *co_names;		<span class="comment">/* list of strings (names used) */</span></span><br><span class="line">    PyObject *co_varnames;	<span class="comment">/* tuple of strings (local variable names) */</span></span><br><span class="line">    PyObject *co_freevars;	<span class="comment">/* tuple of strings (free variable names) */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* tuple of strings (cell variable names) */</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *co_cell2arg; <span class="comment">/* Maps cell vars which are arguments. */</span></span><br><span class="line">    PyObject *co_filename;	<span class="comment">/* unicode (where it was loaded from) */</span></span><br><span class="line">    PyObject *co_name;		<span class="comment">/* unicode (name, for reference) */</span></span><br><span class="line">    PyObject *co_lnotab;	<span class="comment">/* string (encoding addr&lt;-&gt;lineno mapping) See</span></span><br><span class="line"><span class="comment">				   Objects/lnotab_notes.txt for details. */</span></span><br><span class="line">    <span class="keyword">void</span> *co_zombieframe;     <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">    <span class="keyword">void</span> *co_extra;</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>
<p>Python编译器在Python源代码进行变异的时候，对于代码中的<em>Code Block</em>，会创建一个PyCodeObject对象与之对应。那么何为一个Code Block——当进入一个新名字空间，或者说作用域时，就是进入了一个新的Code Block。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[demo.py]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	def B():</span><br><span class="line">		pass</span><br><span class="line"></span><br><span class="line">def C():</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">C()</span><br></pre></td></tr></table></figure>
<p>对于demo.py，根据之前的说法就要产生4个PyCodeObject，但是Python运行环境只会对一个PyCodeObject对象调用PyMarshal_WriteObjectToFile操作。很显然，这里面存在一种嵌套关系，仔细观察，在demo.py源文件中作用域呈现出一种嵌套结构，而这种结构正是PyCodeObject对象之间的结构。</p>
<p><img src="/2019/02/25/关于《python源码剖析》笔记/utur/图片/picture_for_note/Python源码分析/ pycode.png" alt="PythonCode"></p>
<h3 id="Python虚拟机框架"><a href="#Python虚拟机框架" class="headerlink" title="Python虚拟机框架"></a>Python虚拟机框架</h3><p>Python的虚拟机是Python的核心，在.py源代码被编译为字节码指令序列后，Python虚拟机机开始接手整个工作。Python的虚拟机从编译得到的PyCodeObject对象中一次读入每一条字节码指令，并在<em>当前的上下文环境</em>中执行字节码指令。</p>
<p>Python的虚拟机实际上实在模拟操作系统运行可执行文件的过程</p>
<p><img src alt="可执行文件的运行时栈"></p>
<p>我们知道PyCodeObject对象中包含了最关键的的字节码指令，以及关于程序的所有静态信息。然而有一点，是PyCodeObject对象没有包含，也不可能包含的。那就是关于程序运行时的动态信息——<strong>执行环境</strong></p>
<p>什么是执行环境，参考下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[environment.py]</span><br><span class="line">i = <span class="string">'Python'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">	i = <span class="number">999</span></span><br><span class="line">	print(i) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">print(i) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p>在上面代码中的1和2两个地方，都是print(i)，它们所对应的字节码指令肯定是相同，但是它们的执行效果却是不同的。这样的结果正是在执行环境的影响下产生的。在执行#1处的print时，执行环境中，i的值为999；而在#2处，执行环境中的i的值为“Python”。<em>像这种同样的符号在程序运行的不同时刻对应不同的值，甚至不同类型的情况</em>，必须在运行时动态地被捕获和维护，而不可能在PyCodeObject对象中被静态的存储的。</p>
<p>仔细观察，这里的执行环境与之前提到的名字空间似乎是用一个东西，但实际上，名字空间仅仅是执行环境的一部分，除了名字空间，在执行环境中，还包含了其他的一些信息。</p>
<p><em>所以在Python执行的时候，虚拟机上面对的并不是PyCodeObject对象，而是另一个对象——<strong>PyFrameObject</strong>，也就是所谓的执行环境，是Pyhton对x86平台上栈帧的模拟。</em></p>
<h5 id="PyFrameObject对象"><a href="#PyFrameObject对象" class="headerlink" title="PyFrameObject对象"></a>PyFrameObject对象</h5><p>对于Python而言，PyFrameObject对象不仅仅是一个x86机器上看到的那个简简单单的栈帧，它实际上还包含了其他更多的信息。</p>
<p>Python源码中对PyFrameObject的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[frameobject.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span>      <span class="comment">/* previous frame, or NULL */</span></span><br><span class="line">    PyCodeObject *f_code;       <span class="comment">/* code segment */</span></span><br><span class="line">    PyObject *f_builtins;       <span class="comment">/* builtin symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_globals;        <span class="comment">/* global symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_locals;         <span class="comment">/* local symbol table (any mapping) */</span></span><br><span class="line">    PyObject **f_valuestack;    <span class="comment">/* points after the last local */</span></span><br><span class="line"></span><br><span class="line">    PyObject **f_stacktop;</span><br><span class="line">    PyObject *f_trace;          <span class="comment">/* Trace function */</span></span><br><span class="line"></span><br><span class="line">    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;</span><br><span class="line">    <span class="comment">/* Borrowed reference to a generator, or NULL */</span></span><br><span class="line">    PyObject *f_gen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f_lasti;                <span class="comment">/* Last instruction if called */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> f_lineno;               <span class="comment">/* Current line number */</span></span><br><span class="line">    <span class="keyword">int</span> f_iblock;               <span class="comment">/* index in f_blockstack */</span></span><br><span class="line">    <span class="keyword">char</span> f_executing;           <span class="comment">/* whether the frame is still executing */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* for try and loop blocks */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];  <span class="comment">/* locals+stack, dynamically sized */</span></span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure>
<ul>
<li>f_back: 在Python实际的执行中，会产生很多PyFrameObject对象，而这些对象会被链接起来，形成一条执行环境链条。正是对x86机器上栈帧间关系的模拟</li>
<li>f_code: 存放的是一个待执行的PyCodeObejct对象</li>
<li>f_builtins: builtin名字空间</li>
<li>f_globals: global名字空间</li>
<li>f_locals: local名字空间</li>
</ul>
<h5 id="名字、作用域、名字空间"><a href="#名字、作用域、名字空间" class="headerlink" title="名字、作用域、名字空间"></a>名字、作用域、名字空间</h5><h3 id="Python虚拟机中的函数机制"><a href="#Python虚拟机中的函数机制" class="headerlink" title="Python虚拟机中的函数机制"></a>Python虚拟机中的函数机制</h3><h4 id="PyFunctionObject对象"><a href="#PyFunctionObject对象" class="headerlink" title="PyFunctionObject对象"></a>PyFunctionObject对象</h4><h4 id="嵌套函数、闭包与decorater"><a href="#嵌套函数、闭包与decorater" class="headerlink" title="嵌套函数、闭包与decorater"></a>嵌套函数、闭包与decorater</h4><h3 id="Python虚拟机中的类机制"><a href="#Python虚拟机中的类机制" class="headerlink" title="Python虚拟机中的类机制"></a>Python虚拟机中的类机制</h3><h2 id="Python的多线程机制"><a href="#Python的多线程机制" class="headerlink" title="Python的多线程机制"></a>Python的多线程机制</h2><h3 id="GIL与线程调度"><a href="#GIL与线程调度" class="headerlink" title="GIL与线程调度"></a>GIL与线程调度</h3><h3 id="Python线程的调度"><a href="#Python线程的调度" class="headerlink" title="Python线程的调度"></a>Python线程的调度</h3><h3 id="Python线程的用户级互斥与同步"><a href="#Python线程的用户级互斥与同步" class="headerlink" title="Python线程的用户级互斥与同步"></a>Python线程的用户级互斥与同步</h3><h2 id="Python的内存管理"><a href="#Python的内存管理" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><h3 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h3><h3 id="小块空间的内存池"><a href="#小块空间的内存池" class="headerlink" title="小块空间的内存池"></a>小块空间的内存池</h3><h3 id="循环引用的垃圾收集"><a href="#循环引用的垃圾收集" class="headerlink" title="循环引用的垃圾收集"></a>循环引用的垃圾收集</h3><h3 id="Python中的垃圾收集"><a href="#Python中的垃圾收集" class="headerlink" title="Python中的垃圾收集"></a>Python中的垃圾收集</h3><h2 id><a href="#" class="headerlink" title=" "></a> </h2>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Linux内核（学习笔记）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Linux内核（学习笔记）/" class="post-title-link" itemprop="url">深入理解Linux内核</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:18:46" itemprop="dateModified" datetime="2019-07-06T17:18:46+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux-的优势"><a href="#Linux-的优势" class="headerlink" title="Linux 的优势"></a>Linux 的优势</h2><ol>
<li>Linux是免费的。除硬件之外，无需任何花费就能安装一套玩整的Linux系统</li>
<li>Linux的所有成分都可以充分地定制。通过内核编译选项，你可以选择自己真正需要的特征来定制内核。</li>
<li>Linux可以运行在低档、便宜的硬件平台上。</li>
<li>Linux是强大的，由于充分挖掘了硬件部分的特点，使得Linux系统速度非常块，Linux的主要目标是效率</li>
<li>Linux的开发者都是非常出色的程序员。</li>
<li>Linux内核非常小，而且紧凑。</li>
<li>Linux与很多通用操作系统高度兼容。</li>
<li>Linux有很好的技术支持</li>
</ol>
<p><strong>内核控制路径（Kernel control path）</strong>表示内核处理系统调用、异常或中断所执行的指令序列。</p>
<p>最简单的情况下，CPU从第一条指令到最后一条指令顺序地执行内核控制路径。然而当下述事件之一发生时，CPU交错执行内核控制路径：</p>
<ol>
<li>运行在用户态的进程调用一个系统调用。</li>
<li>当运行一个内核控制路径时，CPU检测到一个异常（例如，访问一个不在RAM中的页）。</li>
<li>当CPU正在运行一个启用了中断的内核控制路径时，一个硬件中断发生。</li>
<li>在支持抢占式调度的内核中，CPU正在运行，而一个更高优先级的进程加入就绪队列，则中断发生。</li>
</ol>
<p><img src="/2019/02/25/Linux内核（学习笔记）/utur/图片/picture_for_note/Linux源码/内核控制路径.png" alt="内核控制路径"></p>
<p><strong>同步内核路径</strong></p>
<ol>
<li><strong><em>非抢占式内核</em></strong>，当进程在内核态执行时，它不能被任意挂起，也不能被另一个进程代替。因此，在单处理器系统上，中断或异常处理程序不能修改的所有内核数据结构，内核对它们讷的访问都是安全的</li>
<li><strong><em>禁止中断</em></strong>，单处理器系统上的另一种同步机制是：在进入一个临界区之前禁止所有硬件中断，离开时再重新启动中断。</li>
<li><strong><em>信号量</em></strong>,信号量仅仅是与一个数据结构相关的计数器。所有内核线程在试图访问这个数据结构之前，都要检查这个信号量。可以把每个信号量看成一个对象，其组成如下：<ul>
<li>一个整数变量</li>
<li>一个等待进程的链表</li>
<li>两个原子方法：down()和up()</li>
</ul>
</li>
<li><strong><em>自旋锁</em></strong>,如果修改数据结构所需的时间比较段，那么，信号量可能是低效的。为了检查信号量，内核必须把进程插入到信号量链表中，然后挂起它。因为这两种操作比较费时，完成这些操作时，其他的内核控制路径可能已经释放了信号量。在这些情况下，多处理器操作系统使用了自旋锁（spin lock）。自旋锁与信号量非常相似，但没有进程链表，当一个进程发现锁被另一个进程锁着时，它就不停地“旋转”，执行一个紧凑的循环指令直到锁打开。当然，自旋锁在单处理器环境下是无效的。</li>
</ol>
<h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><p><strong>随机访问存储器（RAM）的使用</strong></p>
<p>所有的Unix操作系统都将RAM毫无疑义地划分为两部分，其中若干兆字节专门用于存放内核映像（也就是内核代码和内核静态数据结构）。RAM的其余部分通常有虚拟内存系统来处理，并且用在以下三种可能的方面：</p>
<ul>
<li>满足内核对缓冲去、描述符及其他动态内核数据结构的请求</li>
<li>满足进程对一般内存区的请求及对文件内存映射的请求</li>
<li>借助于高速缓存从磁盘及其他缓冲设备获得较好的性能</li>
</ul>
<p><strong>内核内存分配器</strong></p>
<p>内存内核分配其（Kernel Memory Allocator, KMA）是一个子系统，它试图满足系统中所有部分对内存的请求。</p>
<p>基于各种不同的算法技术，已经提出了集中KMA，包括：</p>
<ul>
<li><em>资源图分配算法（allocator）</em></li>
<li><em>2的幂次方空间链表</em></li>
<li><em>McKusick-Karels分配算法</em></li>
<li><em>伙伴（Buddy）系统</em></li>
<li><em>Mach的区域（Zone）分配算法</em></li>
<li><em>Dynix分配算法</em></li>
<li><em>Solaris的Slab分配算法</em></li>
</ul>
<p><strong>物理内存布局</strong></p>
<p>在初始化阶段，内核必须建立一个物理地址映射来指定哪些物理地址范围对内核可用而哪些不可用（或者因为它们映射硬件设备I/O的共享内存，或者因为相应的页框含有BIOS数据）。</p>
<p>内核将下列页框记为保留：</p>
<ul>
<li>在不可用的物理地址范围内的页框。</li>
<li>含有内核代码和已初始化的数据结构的页框</li>
</ul>
<p>保留页框中的页绝不嫩被动态分配或交换到磁盘上。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程链表</strong></p>
<p>Linux的进程链表是一个双向链表，进程链表把所有进程的描述符链接起来。每个task_struct结构都包含一个list_head类型的tasks字段，这个类型的prev和next字段分别指向前面和后面的task_struct元素。</p>
<p>进程链表的头是init_task描述符，它是所谓的0进程（process 0）或swapper进程的进程描述符。init_task的tasks.prev字段指向链表中最后插入的进程描述符tasks字段。</p>
<p><img src="/2019/02/25/Linux内核（学习笔记）/utur/图片/picture_for_note/Linux源码/进程链表.png" alt="进程链表"></p>
<p><strong>TASK_RUNNING状态的进程链表</strong></p>
<p>当内核寻找一个新进程在CPU上运行时，必须只考虑可运行进程（即处在TASK_RUNNING状态的进程）。</p>
<p>早期的Linux版本把所有的可运行进程都放在同一个叫作运行队列（runqueue）的链表中，由于维持链表中的进程按优先级排序开销过大，因此，早期的调度程序不得不为选择“最佳”可运行进程而扫描整个队列。</p>
<p>Linux 2.6实现的运行队列有所不同。其目的是让点读程序能在固定的时间内选出“最佳”可运行程序，与队列中可运行的进程数无关。提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先权对应一个不同的链表。这是一个通过使数据结构更复杂来改善性能的典型例子：调度程序的操作效率的确更高了，但运行队列的链表却为此而被拆分成140(0-139）个不同的队列。——空间换时间</p>
<p><strong>进程间的关系</strong></p>
<p>程序创建的进程具有父/子关系。如果一个进程创建多个子进程时，则子进程之间具有兄弟关系。</p>
<p>图3-4显示了一组进程间的亲属关系。进程P0接连创建了P1，P2，和P3。进程P3又创建了P4。</p>
<p><img src="/2019/02/25/Linux内核（学习笔记）/utur/图片/picture_for_note/Linux源码/进程间的关系.png" alt="进程间的关系"></p>
<p><strong>pidhash表及链表</strong></p>
<p>在几种情况下，内核必须能从进程的PID到处对应的进程描述符指针。</p>
<p>顺序扫描进程链表并检查进程描述符的pid字段是可行但相当低效的。为了加速查找，引入了4个散列表。需要4个散列表是因为进程描述符包含了表示不同类型pid的字段，而且每种类型的PID需要它自己的散列表。</p>
<p><img src="/2019/02/25/Linux内核（学习笔记）/utur/图片/picture_for_note/Linux源码/4种PID.png" alt="四种PID"></p>
<p>正如计算机科学的基础课程所阐述的那样，散列（hash）函数并不总能确保PID与表的索引一一对应。两个不同的PID散列（hash）到相同的表索引称为冲突（colliding）</p>
<p>Linux利用链表来处理冲突的PID：每一个表项是由冲突的进程描述符组成的双向链表。</p>
<p><img src="/2019/02/25/Linux内核（学习笔记）/utur/图片/picture_for_note/Linux源码/pidhash表及链表.png" alt="pidhash表"></p>
<p>具有链表的散列法比从PID到表索引的线性转换更优越，这是因为在任何给定的实例中，系统中的进程数总是远远小于32768（所允许的进程PID的最大数）。如果在任何给定的实例中大部分表项都不使用的话，那么把表定义为32768项会是一种存储浪费。</p>
<p>由于需要跟踪进程间的关系，PID散列表中使用的数据结构非常复杂。</p>
<p>PID散列表的数据结构解决了所有这些难题，因为他们可以为包含在一个散列表中任意PID号定义进程链表。</p>
<p><strong>等待队列</strong></p>
<p>等待队列在内核中有很多用途，尤其用在中断处理、进程同步及定时。等待队列表示一组睡眠的进程，当某一条件变为真时，由内核唤醒它们。</p>
<p>等待队列由双向链表实现，其元素包括指向进程描述符的指针。因为等待队列是由中断处理和主要内核函数修改的，因此必须对其双向链表进行保护以免对其进行同事访问，因为同事访问会导致不可预测的后果。</p>
<p>注：雷鸣般兽群问题：即唤醒多个进程只为了竞争一个资源，而这个资源只能有一个进程访问，结果是其他进程必须再次回去睡眠。</p>
<p>非互斥进程插入等待队列链表的第一个位置。互斥进程插入等待队列链表的最后一个位置。</p>
<p>因为所有的非互斥进程总是在双向链表的开始位置，而所有的互斥进程在双向链表的尾部，所以函数总是先唤醒非互斥进程然后再唤醒互斥进程，如果有进程存在的话。</p>
<p><strong>进程切换</strong></p>
<p><strong><em>硬件上下文</em></strong></p>
<p>进程恢复执行前必须转股寄存器的一组数据称为硬件上下文（hardware context)。硬件上下文是进程可执行上下文的一个子集。在Linux中，进程硬件上下文的一部分存放在TSS段，而剩余部分存放在内核太堆栈中。</p>
<p><strong><em>任务状态段(TSS)</em></strong></p>
<p>80x86体系结构包括了一个特殊的段类型，叫任务状态段（Task State Segment, TSS)来存放硬件上下文。尽管Linux并不使用硬件上下文切换，但是强制它为系统中每个不同的CPU创建一个TSS。</p>
<p><strong>thread字段</strong></p>
<p>在每次进程切换时，被替换进程的硬件上下文必须保存在别处。不能像Intel原始设计那样把它保存在TSS中，因为Linux为每个处理器而不是为每个进程使用TSS。</p>
<p>因此，每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。</p>
<p><strong>执行进程切换</strong></p>
<p>从本质上说，每个进程切换由两步组成：</p>
<ol>
<li>切换页全局目录以安装一个新的地址空间</li>
<li>切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包括CPU寄存器。</li>
</ol>
<p><strong>创建进程</strong></p>
<p>Unix操作系统紧紧依赖进程创建来满足用户的需求。</p>
<p>传统的Unix操作系统以统一的方式对待所有的进程：子进程复制父进程所拥有的资源。这种方法使进程的创建非常慢且效率低，因为子进程需要拷贝父进程的整个个、地址空间。</p>
<p>现代Unix内核通过引入三种不同的机制解决了这个问题：</p>
<ul>
<li>写时复制技术允许父子进程读相同的物理页。只要两者中有一个试图写一个物理页，内核就把这个页的内容拷贝到一个新的物理页，并把这个新的物理页分配给正在写的进程。</li>
<li>轻量级进程允许父子进程共享进程在内核的很多数据结构，如页表、打开文件表及信号处理。</li>
<li>vfork()系统调用创建的进程能共享其父进程的内存地址空间。为了防止父进程重写子进程需要的数据，阻塞父进程的执行，一直到到子进程退出或执行一个新的程序为止。</li>
</ul>
<p><strong><em>clone()、fork()及vfork()系统调用</em></strong></p>
<p>在Linux中、轻量级进程是由名为clone()的函数创建的。</p>
<p>实际上，clone()是在C语言库中定义的一个封装（wrapper）函数，它负责建立新轻量级进程的堆栈并且调用对编程者隐藏的clone()系统调用。</p>
<p>传统的fork()系统调用和vfork()系统调用在Linux中也是用clone()实现的。</p>
<p><strong>内核线程</strong></p>
<p>因为一些系统进程只运行在内核太，所以现代操作系统把它们的函数委托给内核线程（kernel thread），内核线程不受不必要的用户态上下文的拖累。</p>
<p><strong><em>进程 0</em></strong></p>
<p>所有进程的祖先叫作进程0，idle进程，或因为历史的原因叫作swapper进程，它是在Linux的初始化阶段从无到有创建的一个内核线程。这个祖先进程使用下列静态分配的数据结构（所有其他进程的数据结构都是动态分配的）：</p>
<ul>
<li>存放在init_task变量中的进程描述符，由INIT_TASK宏完成对它的初始化</li>
<li>存放在init_thread_union变量中的thread__info描述符和内核堆栈，由INIT_THREAD_INFO宏完成对它们的初始化。。</li>
<li>由进程描述符指向的下列表：<ul>
<li>init_mm</li>
<li>init_fs</li>
<li>init_files</li>
<li>init_signals</li>
<li>init_sighand</li>
</ul>
</li>
<li>主内核页全局目录存放在swapper_pg_dir中。</li>
</ul>
<p>start_kernel()函数初始化内核需要的所有数据结构，激活中断，创建另一个叫进程1的内核线程（一般叫作init进程）。新创建内核线程的PID为1，并与进程0共享每个进程所有的内核数据结构。此外，当调度程序选择到它时，init进程开始执行init（）函数。</p>
<p>在多处理器系统中，每个CPU都有一个进程0.只要打开机器电源，计算机的BIOS就启动某一个CPU，同时禁用其他CPU。运行在CPU0还是上的swapper进程初始化内核数据结构，然后激活其他的CPU，并通过copy_process()函数创建另外的swapper进程，把 0 传递给新创建的swapper进程作为它们的新PID。</p>
<p><strong><em>进程 1</em></strong></p>
<p>由进程 0 创建的内核线程执行init()函数，init()依次完成内核初始化。init()调用execve()系统调用装入可执行程序init。结果，init内核线程变为一个普通进程，且拥有自己的每进程（per-process）内核数据结构。在系统关闭之前，init进程一直存活，因为它创建和监控在操作系统外层执行的所有进程的活动。</p>
<p><strong><em>其他内核线程</em></strong></p>
<p>Linux使用很多其他内核线程。其中一些在初始化阶段创建，一直运行奥系统关闭，而其他一些在内核必须执行一个任务时“按需”创建，这种任务在内核的执行上下文中得到很好的执行。</p>
<p><strong>进程删除</strong><br>Unix允许进程查询内核以获得其父进程的PID，或者其任何子进程的执行状态。</p>
<p>为了遵循这些设计选择，不允许Unix内核在进程一终止后就丢弃包含在进程描述符字段中的数据。只有父进程发出了与被终止的进程相关的wait（）类系统调用之后，才允许这样做。这就是引入僵死状态的原因：尽管从技术上来说进程已死，但必须保存它的描述符，直到父进程得到通知。</p>
<p>如果父进程在子进程结束之前结束会发生什么情况呢？在这种情况下，系统中会到处是僵死的进程，而且它们的进程描述符永久占据这RAM。所以这必须强迫所有的孤儿进程成为init进程的子进程来解决这个问题。这样，init进程在用wait（）类系统调用检查其合法的子进程终止时，就会撤销僵死的进程。</p>
<p>对僵死进程的处理有两种可能的方式：</p>
<ol>
<li>如果父进程不需要接收来自子进程的信号，就调用do_exit()。</li>
<li>如果已经给父进程发送了一个信号，就调用wait4（）或waitpid（）系统调用。</li>
</ol>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断通常分为<em>同步（synchronous）中断</em>和<em>异步（asynchronous）中断</em>：</p>
<ul>
<li>同步中断是指当指令执行时有CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。</li>
<li>异步中断是由其他硬件设备依照CPU时钟信号随机产生的。</li>
</ul>
<p>在Intel微处理器手册中，把同步和异步中断分别称为异常（exception）和中断（interrupt）。</p>
<p><strong><em>中断</em></strong></p>
<ul>
<li>可屏蔽中断（maskable interrupt）</li>
<li>非屏蔽中断（nonmaskable interrupt）</li>
</ul>
<p><strong><em>异常</em></strong></p>
<ul>
<li>故障（fault）</li>
<li>陷阱（trap）</li>
<li>异常中止（abort）</li>
<li>编程异常（programmed exception)</li>
</ul>
<p><strong>中断描述符表</strong></p>
<p>中断描述符表（Interrupt Descriptor Table, IDT）是一个系统表，它与灭一个中断或异常向量相联系，每一个向量在表中有相应的中断或异常处理程序的入口地址。</p>
<p>IDT包含三种类型的描述符。</p>
<p><img src="/2019/02/25/Linux内核（学习笔记）/utur/图片/picture_for_note/Linux源码/门描述符的格式.png" alt="门描述符"></p>
<p>这些描述符是：</p>
<p>任务门（task_gate)</p>
<p>​    当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。</p>
<p>中断门（interrupt gate)</p>
<p>​    包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，                             处理器清IF标志，从而关闭将来会发生的可屏蔽中断。</p>
<p>陷阱门（Trap gate）</p>
<p>​    与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志。</p>
<p><strong><em>Linux利用中断门处理中断，利用陷阱门处理异常</em></strong></p>
<p><strong>中断和异常处理程序的嵌套执行</strong></p>
<p>每个中断或异常都会引起一个内核控制路径，或者说代表当前进程在内核态执行单独的指令序列。内核控制路径可以任意嵌套：一个中断处理程序可以被另一个中断处理程序“中断”，因此引起内核控制路径的嵌套执行。如图所示。</p>
<p><img src="/2019/02/25/Linux内核（学习笔记）/utur/图片/picture_for_note/Linux源码/内核控制路径嵌套执行.png" alt="内核控制路径嵌套执行"></p>
<p>允许内核控制路径嵌套执行必须付出代价，那就是中断处理程序必须永不阻塞，换句话说，中断处理程序运行期间不能发生进程切换。事实上，嵌套的内核控制路径恢复执行时需要的所有数据都存放在内核态堆栈栈中，这个栈毫无疑义的属于当前进程。</p>
<p>一个中断处理程序既可以抢占其他的中断处理程序，也可以抢占异常处理程序。相反，异常处理程序从不抢占中断处理程序。</p>
<p>基于以下两个主要原因，Linux交错执行内核控制路径：</p>
<ul>
<li>为了提高可编程中断控制器和设备控制器的吞吐量。</li>
<li>为了实现一种没有优先级的中断模型。简化了内核代码，提高了内核的可移植性。</li>
</ul>
<p><strong>IRQ在多处理器系统上的分发</strong></p>
<p>Linux遵循对称多处理模型（SMP），这意味着，内核从内本质上对任何一个CPU都不应该有</p>
<p>偏爱。因而，内核试图以轮转的方式把来自硬件设备的IRQ信号在所有CPU之间分发。因此，所有CPU服务于I/O中断的执行时间片几乎相同。</p>
<p>在系统启动的过程中，引导CPU执行setup_IO_APIC_irqs()函数来初始化I/O APIC芯片。芯片的中断重定向表的24项被填充，以便根据“最低优先级”模式把来自I/O硬件设备的所有信号都传递给系统中的每个CPU。此外，在系统启动期间，所有的CPU都执行setup_local_APIC()函数，该函数处理本地APIC的初始化。特别是，每个芯片的任务优先级寄存器（TPR）都初始化为一个固定的值，这就意味着CPU愿意处理任何类型的IRQ信号，而不管优先级。Linux内核启动后再也不修改这个值。</p>
<p>因为所有的任务优先级寄存器都包含相同的值，因此，有所CPU总是具有相同的优先级。为了突破这种约束，多APIC系统使用本地APIC仲裁优先级寄存器中的值。因为这样的值在每次中断后都自动改变，因此，IRQ信号就公平地在所有CPU之间分发。</p>
<p>简而言之，当硬件设备发生了一个中断信号时，多APIC系统就选择其中的一个CPU，并把该信号传递给相应的本地APIC，本地APIC又依次中断它的CPU。这个事件不通报给其他所有的CPU。</p>
<hr>
<h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><p>可以把内核看作是不断对请求进行响应的服务器，这些请求可能来自在CPU上执行的进程，也可能来自发出中断请求的外部设备。这个类比强调内核的各个部分并不是严格按照顺序依次执行的，而是采用交错执行的方式。因此，这些请求可能引起竞争条件,而我们必须采用适当的同步机制对这种情况进行控制。</p>
<p><strong>内核抢占</strong></p>
<p>如果进程执行内核函数时，即它在内核态运行时，允许发生内核切换（被替换的进程是正执行内核函数的进程），这个内核就是抢占的。</p>
<p>使内核可抢占的目的是减少用户态进程的分派延迟（dispatch latency），即从进程变为可执行状态到它实际开始运行之间的时间间隔。</p>
<p><strong>内核使用的各种同步技术</strong></p>
<ul>
<li><p><strong>每CPU变量</strong></p>
<p>最好的同步技术是把设计不需要同步的内核放在首位。最简单也是最最重要的同步技术包括把内核变量声明为每CPU变量（per-cpu variable)。每CPU变量主要是数据结构的数组，系统的每个CPU对应数组的一个元素。</p>
<p>一个CPU不应该访问与其它CPU对应的数组元素，另外，它可以随意读或修改它自己的元素而不用担心出现竞争条件。但是，这也意味着每CPU变量基本上只能在特殊情况下使用，也就是当它确定在系统的CPU上的数据在逻辑上是独立的时候。</p>
<p>每CPU的数组元素在主存中被排列以使每个数据结构存放在硬件高速缓存的不同行，因此，对每CPU数组的并发访问不会导致高速缓存行的窃用和失效。</p>
<p>此外，在单处理器和多处理器系统中，内核抢占都可能使每CPU变量产生竞争条件。总的原则是内核控制路径应该在禁用抢占的情况下访问每CPU变量。</p>
</li>
<li><p><strong>原子操作</strong></p>
<p>若干汇编语言指令具有“读—修改—写”类型——也就是说，它们访问内存单元两次，第一次读原值，第二次写新值。</p>
<p>避免由于“读—修改—写”指令引起的竞争条件的最容易的方法，就是确保这样的操作在芯片级是原子的。任何一个这样 的操作都必须以单个指令执行，中间不嫩中断，且避免其他的CPU访问同一存储器单元。这些很小的原子操作（atomic opreations)可以建立在其他更灵活机制的基础之上以创建临界区。    </p>
<p>操作码前缀是lock字节（0xf0）的“读—修改—写”汇编语言指令即使在多处理器系统中也是原子的。当控制大暖检测到这个前缀时，就“锁定”内存总线，直到这条指令执行完成为止。因此，当枷锁的指令执行时，其他处理器不能访问这个内存单元。</p>
</li>
<li><p><strong>优化和内存屏障</strong></p>
<p>当使用优化的编译器时，编译器可能重新安排汇编语言指令以使寄存器以最优的方式使用。此外，现代CPU通常并行地执行若干条指令，且可能重新安排内存访问。这种重新排序可以极大地加速程序的执行。</p>
<p>然而，当处理同步时，必须避免指令重新排序。如果发放在同步原语之后的一条指令在同步原语本身之前执行，事情很快就会变得失控。事实上，所有的同步原语起优化和内存屏障的作用。</p>
<p><strong>优化屏障（memory barrier）</strong>原语保证编译程序不会混淆放在原语操作之前的汇编语言指令和放在原语操作之后的汇编语言指令。在Linux中，优化屏障就是barrier（）宏，它展开为asm volatile(“:::”memory”)。volatile关键字禁止编译器把asm指令与程序中的其他指令重新组合。memory关键字强制编译器假定RAM中的所有内存单元已经被汇编语言指令修改。因此，编译器不能使用存放在CPU寄存器中的内存单元的值来优化asm指令前的代码。</p>
<p><strong>内存屏障（memory barrier）</strong>原语确保，在原语之后的操作开始执行之前，原语之前的操作已经完成。因此，内存屏障类似于防火墙，让任何汇编语言指令都不能通过。</p>
<p>Linux使用六个内存屏障原语：</p>
<ul>
<li>rm()</li>
<li>rmb()</li>
<li>wmb()</li>
<li>smp_mb()</li>
<li>smp_rmb()</li>
<li>smp_wmb()</li>
</ul>
<p>这些原语也被当做优化屏障，因为我们必须保证编译程序不在屏障前后移动汇编语言指令。内存屏障原语的实现依赖与系统的体系机构。在80x86微处理器上，如果CPU支持lfence汇编语言指令，就把rmb（）宏展开为asm volatile（”lfence”)，否则就展开为asm volatile（”lock;addl $0,0(%%esp)”:::”memory”)。</p>
</li>
<li><p><strong>自旋锁</strong></p>
<p>一种广泛使用的同步技术是加锁（locking）。当内核控制路径必须访问共享数据结构或进入临界区时，就需要为自己获取一把”锁“。</p>
<p><img src="/2019/02/25/Linux内核（学习笔记）/utur/图片/picture_for_note/Linux源码/自旋锁.png" alt="自旋锁"></p>
<p>自旋锁（spin lock）是用来在多处理器环境中工作的一种特殊的锁。如果内核控制路径发现自旋锁”开着“，就获取锁并继续自己的执行。相反，如果内核控制路径发现锁由运行在另一个CPU上的内核控制路径”锁着“，就在周围”旋转“，反复执行一条紧凑的循环指令，直到锁被释放。</p>
<p>自旋锁的循环指令表示”忙等“。及时等待的内核控制路径无事可做（除了浪费时间），它也在CPU上保持运行。不过自旋锁通常非常方便，因为很多内核资源只锁1毫秒的时间片段。</p>
<p>一般来说，由自旋锁所保护的每个临界区都是禁止内核抢占的。在单处理器系统上，这种锁本身不起锁的作用，自旋锁原语仅仅是禁止或启用内核抢占。在自旋锁忙等期间，内核抢占还是有效的，因此，等待自旋锁释放的进程有可能被更高优先级的进程替代。</p>
<p>在Linux中，每个自旋锁都用spin_lock_t结构表示，其中包含两个字段：</p>
<p><strong>slock</strong>：该字段表示自旋锁的状态，值为1表示”未加锁“状态，而任何负数和0都表示”加锁“状态。</p>
<p><strong>break_lock</strong>：表示进程正在忙等自旋锁（只在内核支持SMP和内核抢占的情况下使用该标志）。</p>
</li>
<li><p><strong>读/写自旋锁</strong></p>
<p>读/写自旋锁的引入是为了增加内核的并发能力。只要没有内核控制路径对数据结构进行修改，读/写自旋锁就允许多个内核控制路径同时读同一数据结构。如果一个内核控制路径想对这个结构进行写操作，那么它必须首先获取读/写锁的写锁，写锁授权独占访问这个资源。当然，允许对数据结构并发读可以提高系统性能。</p>
</li>
<li><p><strong>顺序锁</strong></p>
<p>Linux2.6中引入了顺序锁（seqlock），它与读/写自旋锁非常相似，只是它为写着赋予了较高的优先级：事实上，即使在读者正在读的时候也允许写者继续运行。<em>这种策略的好处是写者永远不会等待（除非另一个写者正在写），缺点是有些时候读者不等不反复多次读相同的数据直到它获得有效的副本。</em></p>
<p>每个顺序所都是包括两个字段seqlock_t结构：一个类型为spin_lock_t的lock字段和一个整型的sequence字段，第二个字段是一个顺序计数器。**每个读者都必须在读数据前后两次读顺序计数器，并检查两次读到的值是否相同，如果不相同，说明新的写者已经开始写并增加了顺序计数器，因此暗示读者刚读到的数据是无效的。</p>
</li>
<li><p><strong>读—拷贝—更新（RCU）</strong></p>
<p>读—拷贝—更新（RCU）是为了保护在多数情况下被多个CPU读的数据结构而设计的另一种同步技术。RCU允许多个读者和写者并发执行。而且，RCU是不适用锁的，就是说，它不适用被所有CPU共享的锁或计数器，在这一点上与读/写自旋锁和顺序锁（由于高速缓存行窃用和失效而有很高的开销）相比，RCU具有更大的优势。</p>
<p>其关键思想包括限制RCU的范围：</p>
<ol>
<li>RCU只保护被动态分配并通过指针引用的数据结构</li>
<li>在被RCU保护的临界区中，任何内核控制路径都不能失眠。</li>
</ol>
</li>
<li><p><strong>信号量</strong></p>
<p>实际上，Linux提供两种信号量：</p>
<ul>
<li>内核信号量，由内核控制路径使用</li>
<li>System V IPC信号量，由用户态进程使用</li>
</ul>
<p>内核信号量类似于自旋锁，因为当锁关闭着时，它不允许内核控制路径继续进行。然而，当内核控制路径试图获取内核信号量所保护的忙资源时，相应的进程被挂起。只有在资源被释放时，进程才再次变为可运行的。因此，只有可以睡眠的的函数才能获取内核信号量，中断处理程序和可延迟函数都不能使用内核信号量。</p>
</li>
<li><p><strong>禁止本地中断</strong></p>
<p>确保一组内核语句被当做一个临界区处理的主要机制之一就是中断禁止。即使当硬件设备产生了一个IRQ信号时，中断禁止也让内核控制路径继续执行，因此，这就提供了一中有效的方式 ，确保中断处理程序访问的数据结构也受到保护。然而禁止本地中断并不保护运行在另一个CPU上的中断处理程序对数据结构的并发访问，因此，在多处理器系统上，禁止本地中断经常与自旋锁结合使用。</p>
</li>
<li><p><strong>禁止和激活可延迟函数</strong></p>
<p>禁止可延迟函数在一个CPU上执行的一种简单方式就是禁止在那个CPU上的中断。因为没有中断处理程序被激活，因此，软中断操作就不能异步地开始。</p>
</li>
<li><p>总结</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>技术</th>
<th>说明</th>
<th>使用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>每CPU变量</td>
<td>在CPU之间复制数结构</td>
<td>所有CPU</td>
</tr>
<tr>
<td>原子操作</td>
<td>对一个计数器原子地”读—修改—写“的指令</td>
<td>所有CPU</td>
</tr>
<tr>
<td>内存屏障</td>
<td>避免指令重新排序</td>
<td>本地CPU或所有CPU</td>
</tr>
<tr>
<td>自旋锁</td>
<td>加锁时忙等</td>
<td>所有CPU</td>
</tr>
<tr>
<td>信号量</td>
<td>加锁时阻塞等待（睡眠）</td>
<td>所有CPU</td>
</tr>
<tr>
<td>顺序锁</td>
<td>基于访问计数器的锁</td>
<td>所有CPU</td>
</tr>
<tr>
<td>本地中断的禁止</td>
<td>禁止单个CPU上的中断处理</td>
<td>本地CPU</td>
</tr>
<tr>
<td>本地软中断的禁止</td>
<td>禁止单个CPU上的可延迟函数处理</td>
<td>本地CPU</td>
</tr>
<tr>
<td>读—拷贝—更新（RCU)</td>
<td>通过指针而不是锁来访问共享数据结构</td>
<td>所有CPU</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="定时测量"><a href="#定时测量" class="headerlink" title="定时测量"></a>定时测量</h2><ul>
<li><p><strong>Linux计时体系结构</strong></p>
<p>Linux必定执行于定时相关的操作。例如，内核周期性地：</p>
<ul>
<li>更新自系统启动以来所经过的时间</li>
<li>更新时间和日期</li>
<li>确定当前进程在每个CPU上已运行了多长时间，如果已经超过了分配给它的时间，则抢占它。</li>
<li>更新资源使用统计数</li>
<li>检查每个软定时器的时间间隔是否已到。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>Linux与任何分时系统一样，通过一个进程到另一个进程的快速切换，达到表面上看来多个进程同时执行的神奇效果。</p>
<p>Linux的调度基于分时技术：多个进程以”时间多路服用“方式运行，因为CPU的时间被分成片”（slice）”，给每个可运行进程分配一片。如果当前运行进程的时间片或时限到期时，该进程还没有运行完毕，进程切换就可以发生。</p>
<p>传统上把进程分类为“<strong><em>I/O受限（I/O-bound）</em></strong>“或”<strong><em>CPU受限（CPU-bound）</em></strong>“。前者频繁地使用I/O设备，并花费很多时间等待I/O操作的完成；而后者则需要大量CPU时间的数据计算应用程序。</p>
<p>另一种分类法把进程分为三类：</p>
<ul>
<li><p><strong>交互式进程（interactive process）</strong></p>
<p>这些进程经常与用户进行交互，因此，要花很多时间等待键盘和鼠标操作。当接受了输入后，进程必须被很快唤醒，否则用户将发现系统反应迟钝。典型的交互式程序是命令shell、文本编辑程序及图形应用程序。</p>
</li>
<li><p><strong>批处理进程（batch process)</strong></p>
<p>这些进程不必与用户交互，因此经常在后台运行。典型的批处理进程是程序设计语言的编译程序、数据库搜索引擎及科学计算。</p>
</li>
<li><p><strong>实时进程（real-time process）</strong></p>
<p>这些进程有很强的调度需要。这样的进程绝不会被低优先级的进程阻塞，它们应该有一个很短的响应时间，更重要的是，响应时间的变化应该很小。典型的实时程序有视频和音频应用程序、机器人控制程序及从物理传感器上收集数据的程序。</p>
</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>每个Linux进程总是按照下面的调度类型被调度：</p>
<ul>
<li><p>SCHED_FIFO</p>
<p>先进先出的实时进程</p>
</li>
<li><p>SCHED_RR</p>
<p>时间片轮转的实时进程</p>
</li>
<li><p>SCHED_NORMAL</p>
<p>普通的分时进程</p>
</li>
</ul>
<h4 id="普通进程的调度"><a href="#普通进程的调度" class="headerlink" title="普通进程的调度"></a>普通进程的调度</h4><p>每个普通进程都有它自己的静态优先级，调度程序使用静态优先级来估计系统中这个进程与其他普通进程之间调度的程度。内核用从100（最高优先级）到139（最低优先级）的数表示普通进程的静态优先级。</p>
<p>基本时间片：</p>
<p><img src="/2019/02/25/Linux内核（学习笔记）/utur/图片/picture_for_note/Linux源码/普通进程基本时间片.png" alt="时间片"></p>
<p>与优先级低的进程相比，通常优先级较高的进程获得更长额CPU时间片。</p>
<h4 id="实时进程的调度"><a href="#实时进程的调度" class="headerlink" title="实时进程的调度"></a>实时进程的调度</h4><p>每个实时进程都与一个实时优先级相关，实时优先级是一个范围从1（最高优先级）～99（最低优先级）的值。调度程序总是让优先级高的进程运行，换句话说，实时进程运行的过程中，禁止低优先级进程的执行。与普通进程相反，实时进程总是被当成活动进程。</p>
<p>只有在下述事件之一发生时，实时进程才会被另外一个进程取代：</p>
<ul>
<li>进程被另外一个具有更高实时优先级的实时进程抢占</li>
<li>进程执行了阻塞操作并进入睡眠</li>
<li>进程停止或被杀死</li>
<li>进程通过调用系统调用sched_yield()自愿放弃CPU</li>
<li>进程是基于时间片轮转的实时进程，而且用完了它的时间片。</li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>​    </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Utur</p>
              <div class="site-description motion-element" itemprop="description">木龟想做一个哈皮程序猿。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Turtle-knight" title="GitHub &rarr; https://github.com/Turtle-knight" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:turtle.mugui@gmail.com" title="E-Mail &rarr; mailto:turtle.mugui@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://plus.google.com/木龟" title="Google &rarr; https://plus.google.com/木龟" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Utur</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
