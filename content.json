{"meta":{"title":"Utur的个人博客","subtitle":"天天学习，好好向上","description":"木龟想做一个哈皮程序猿。","author":"Utur","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-07-06T07:21:40.000Z","updated":"2019-07-06T08:31:44.957Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-06T07:21:58.000Z","updated":"2019-07-06T08:31:30.648Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Flask学习笔记","slug":"Flask_Web","date":"2019-04-10T16:00:00.000Z","updated":"2019-07-06T09:04:27.482Z","comments":true,"path":"2019/04/11/Flask_Web/","link":"","permalink":"http://yoursite.com/2019/04/11/Flask_Web/","excerpt":"","text":"FlaskFlask是使用Python编写的Web微框架，Web框架可以让开发者不用关心底层的请求响应处理，更方便更高效地编写Web程序。Flask有两个主要依赖，一个是WSGI（Web Server Gateway Interface，Web服务器网关接口）工具集——Werkzeug，另一个是Jinja2模板引擎。 搭建开发环境 安装pip和pipenv 1$ pip install pipenv 创建虚拟环境 在Python中虚拟环境（virtual environment）就是隔离的Python解释器环境。通过创建虚拟环境，你可以拥有一个独立的Python解释器环境。这样做的好处是可以为每一个项目创建独立的Python解释器环境，因为不同的项目常常会话依赖不同版本的库或Python版本。使用虚拟环境可以保持全局Python解释器环境的干净，避免包和版本的混乱，并且可以方便地区分和记录每个项目的依赖，以便在新环境下复现依赖环境。 123$ pipenv install # 为当前目录的项目创建虚拟环境$ pipenv shell # 显式激活虚拟环境 安装Flask 1$ pipenv install flask # 在虚拟环境中安装Flask 注册路由在一个Web应用里，客户端和服务器上的Flask程序的交互可以简单概括为以下几步： 1）用户在浏览器中输入URL访问某个资源 2）Flask接收用户请求并分析请求的URL 3）为这个URL找到对应的处理函数 4）执行函数并生成响应，返回给浏览器 5）浏览器接收并解析响应，将信息显示在页面中 在以上步骤中，大部分都由Flask完成，开发者要做的只是建立处理请求的函数，并定义对应的URL规则。只需为函数附加app.route()装饰器，并传入URL规则作为参数，就可以让URL与函数建立联系。这个过程称为注册路由（route），路由负责管理URL和函数之间的映射，而这个函数则被称为视图函数（view function）。 例如： 123@app.route('/')def index(): return '&lt;h1&gt;Hello, World&lt;/h1&gt;' 在这个程序里，app.route()装饰器把根地址/和index()函数绑定起来，当用户访问这个URL时就会触发index()函数。这个视图函数可以像其他普通函数一样执行任意操作，最后，视图函数返回的值作为响应的主体。 为视图绑定多个URL 一个视图函数可以绑定多个URL。 例： 1234@app.route('/hi')@app.route('/hello')def say_hello(): return '&lt;h1&gt;Hello, Flask!&lt;/h1&gt;' 动态URL 123@app.route('/greet/&lt;name&gt;')def greet(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % name 启动开发服务器1$ flask run flask run命令启动内置的开发服务器。 自动发现程序实例 一般来说，在执行flask run命令运行程序前，需要提供程序实例所在模块的位置。若无提供，Flask会自动探测程序实例，自动探测存在以下规则： 从当前目录寻找app.py和wsgi.py模块，并从中寻找名为app或application的程序实例。 从环境变量FLASK_APP对应的值寻找名为app或application的程序实例。 管理环境变量 Flask的自动发现程序实例机制还有第三条规则：如果安装了python-dotenv，那么在使用flask run或其他命令时会使用它自动从.flaskenv文件和.env文件中加载环境变量。 为了避免频繁设置环境变量，可以使用python-dotenv管理项目的环境变量。 1$ pipenv install python-dotenv .flaskenv文件用来存储和Flask相关的公开环境变量，比如FLASK_APP; .env文件用来存储包含敏感信息的环境变量，比如账户名和密码。 环境变量以键值对的形式定义。 Flask与HTTP请求响应循环 HTTP请求Request对象这个请求对象封装了从客户端发来的请求报文，能从它获取请求报文中的所有数据。 在Flask中处理请求 设置监听的HTTP方法 123@app.route('/hello', method=['GET', 'POST'])def hello(): return '&lt;h1&gt;Hello, Flask!&lt;/h1&gt; 请求钩子有时需要对请求进行预处理（preprocessing）和后处理（postprocessing）。这时可以使用Flask提供的一些请求钩子（Hook），它们可以用来注册在请求处理的不同阶段执行的处理函数。这些请求钩子用装饰器实现，通过程序实例app调用。 ​ 请求钩子 钩子 说明 before_first_request 注册一个函数，在处理第一个请求前运行 before_request 注册一个函数，在处理每个请求前运行 after_request 注册一个函数，如果没有未处理的异常抛出，会在每个请求结束后运行 teardown_request 注册一个函数，即使有未处理的异常抛出，会在每个请求结束后运行 after_this_request 在视图函数内注册一个函数，会在这个请求结束后运行 HTTP响应响应格式在HTTP响应中，数据可以通过多种格式传输。大多数情况下，我们会使用HTML格式，这是Flask中的默认设置。在特定的情况下，也会使用其他格式。不同的响应数据格式需要设置不同的MIME类型。 纯文本 MIME类型： text/plain HTML MIME类型：text/html XML MIME类型：application/xml JSON MIME类型：application/json CookieHTTP是无状态协议。在一次响应结束后，服务器不会留下任何关于对方状态的信息。 Cookie是Web服务器为了存储某些数据（比如用户信息）而保存在浏览器上的小型数据。浏览器会在一定时间内保存它，并在下一次向同一个服务器发送请求时附带这些数据。Cookie通常被用来进行用户会话管理（比如登录状态），保存用户的个性化信息以及记录和收集用户浏览数据以用来分析用户行为等。 在Flask中，想要在响应中添加一个cookie，最方便的方法是使用Response类提供的set_cookie() 方法。 1234567from flask import Flask, make_response...@app.route('/set/&lt;name&gt;')def set_cookie(name): response = make_response(redirect(url_for('hello'))) response.set_cookie('name', name) return response Session：安全的Cookie在编程中，session指用户会话，又称为对话，即服务器和客户端/浏览器之间或桌面程序和用户之间建立的交互活动。而在Flask中，session对象用来加密Cookie。默认情况下，它会把数据存储在浏览器上一个名为session的cookie里。 session通过密钥对数据进行签名以加密数据。因此，得先社会一个密钥。 1234567# 程序的密钥可以通过Flask.secret_key属性或配置变量SECRET_KEY设置app.secret_key = 'secret string'# 更安全的做法是把密钥写进系统环境变量或是保存在.env文件中SECRET_KEY = secret string# 然后在陈旭脚本中使用os模块提供的getenv()方法获取app.secret_key = os.getenv('SECRET_KEY', ‘secret string') HTTP进阶重定向回上一个页面要重定向回上一个页面，最关键的是获取上一个页面的URL。上一个页面的URL一般可以通过两种方法获取。 HTTP referer HTTP referer是一个用来记录请求发源地的HTTP首部字段，即访问来源。当用户在某个站点单击链接，浏览器向新链接所在的服务器发起请求，请求的数据中包含的HTTP_REFERER字段记录了用户所在的原站点URL。 1return redirect(request.referrer) 查询参数 在URL中手动加入包含当前URL的查询参数，这个查询参数一般命名为next。 12345@app.route('/foo')def foo(): return '&lt;h1&gt;Foo page&lt;/h1&gt;&lt;a href=\"%s\"&gt;Do somthing and redirect&lt;/a&gt;' % url_for('do something', next=request.full_path) return redirect(request.args.get('next')) Ajax技术发送异步请求AJAX指异步JavaScript和XML，它不是编程语言或通信协议，而是一系列技术的组合体。简单来说，Ajax基于XMLHttpRequest让我们可以在不重载页面的情况下和服务器进行数据交换。加上JavaScript和DOM，就可以在接收到数据后局部更新页面。 使用JQuery发送Ajax请求 jQuery是流行的JavaScript库，它包装了JavaScript，让我们可以通过更简单的方式编写JavaScript代码。对于Ajax，它提供了多个相关的方法，使用它可以很方便的实现Ajax操作。更重要的是，jQuery处理了不同浏览器的Ajax兼容问题，只需要编写一套代码，就可以在所有主流的浏览器正常运行。 JQuery中和Ajax相关的方法及具体用法访问http://api.jquery.com/category/ajax/ 模板在动态Web程序中，视图函数返回的HTML数据往往需要根据相应的变量（比如查询函数）动态生成。当HTML代码保存到单独的文件中时，没法再使用字符串格式化或拼接字符串的方式来在HTML代码中插入变量，这时，需要使用模板引擎（template engine），借助模板引擎，可以在HTML文件中使用特殊的语法来标记处变量，这类包含固定内容和动态部分的可重用文件称为模板（template）。 模板引擎的作用就是读取并执行模板中的特殊语法标记，并根据传入的数据将变量替换为实际值，输出最终的HTML页面，这个过程被称为渲染（rendering）。 模板基本用法（1）语句 比如 if 判断、for 循环等： {/% for %/}注：因为hexo缘故，实际使用不需要斜杠。 （2）表达式 比如字符串、变量、函数调用等 {/{ xxx.xx }/}注：因为hexo缘故，实际使用不需要斜杠。 （3）注释 {/# xxx #/}注：因为hexo缘故，实际使用不需要斜杠。 模板语法渲染模板在视图函数中，不直接使用Jinja2提供的函数，而是使用Flask提供的渲染函数render_template()。 123@app.route('/example')def example_for_render(): return render_templae('example.html', arg1=xxx, arg2=yyy) 在render_template() 函数中，首先传入模板的文件名作为参数，以关键字参数的形式传入模板中使用的变量值。其他类型的变量通过相同的方式传入。传入Jinja2中的变量值可以使字符串、列表、和字典，也可以是函数、类和类实例。 模板辅助工具上下文 内置上下文变量 Flask在模板上下文中提供了一些内置变两个，可以在模板中直接使用 ​ 标准模板全局变量 变量 说明 config 当前的配置对象 request 当前的请求对象，在已激活的请求环境下可用 session 当前的会话对象，在已激活的请求环境下可用 g 与请求绑定的全局变量，在已激活的请求环境下可用 自定义上下文 如果多个模板都需要使用同一变量，那么较好的方法是能够设置一个模板全局变量。Flask提供了一个app.context_processor()装饰器，可以用来注册模板上下文处理函数，它可以完成统一传入变量的工作。 1234567@app.context_processo()def inject_foo(): foo = 'I am foo.' return dict(foo=foo) # 等同于return &#123;'foo': foo&#125;# 直接将app.context_processor作为方法调用app.context_processor(inject_foo) 当调用render_template()函数渲染任意一个模板时，所有使用app.context_processor装饰器注册的模板上下文处理函数（包括Flask内置的上下文处理函数）都会被执行，这些函数的返回值会被添加到模板中，因此可以在模板中直接使用变量。 全局对象全局对象是指在所有的模板中都可以直接使用的对象，包括在模板中导入的模板。 内置全局函数 ​ Jinja2内置模板全局函数(部分) | 函数 | 说明 || ————————————– | ————————— || range([start,]stop[, step]) | 和python中的range()用法相同 || lipsum(n=5, html=True, min=20,max=100) | 生成随机文本（lorem ipsum） || dict(**items) | 和python中的dict()用法相同 | ​ Flask内置模板全局函数 | 函数 | 说明 || ———————- | ———————– || url_for() | 用于生成URL的函数 || get_flashed_message(0) | 用于获取flash消息的函数 | 自定义全局函数 使用app.template_global()装饰器直接将函数注册为模板全局函数 123@app.template_global()def bar(): return 'I am bar' 过滤器在Jinja2中，过滤器（filter）是一些可以用来修改和过滤变量值的特殊函数，过滤器和变量用一个竖线（管道符号）隔开，需要参数的过滤器可以像函数一样使用括号传递。 例如： 内置过滤器 Jinja2提过了许多内置过滤器，访问http://jinjia.pocoo.org/docs/2.10/template/#builtin-filters 自定义过滤器 使用app.template_filter()装饰器可以自定义过滤器 12345from flask import Markup@app.template_filter()def miscal(s): return s + Markup(' &amp;#9835;') 测试器在Jinja中，测试器（Test）是一些用来测试变量或表达式，返回值（True或False）的特殊函数。比如，number测试器用来判断一个变量或变大时是否数字。使用 is 连接变量和测试器 12345&#123;% if age is number %&#125; &#123;&#123; age * 365&#125;&#125;&#123;% else %&#125; 无效数字&#123;% endif %&#125; 内置测试器 Jinja2提供了许多内置测试器，访问http://jinjia.pocoo.org/docs/2.10/template/#list-of-builtin-tests 自定义测试器 使用app.template_test()装饰器自定义测试器 12345@app.template_test()def baz(n): if n == 'baz': return True return False 模板环境对象在jinja2中，渲染行为有jinja2.Environment类控制，所有的配置选项，上下文变量、全局函数、过滤器和测试器都存储在Environment实例上。当与Flask结合后，我们并不单独创建Environment对象，而是使用Flask创建的Environment对象，它存储在app.jinja_env属性上。 在程序中，可以使用app.jinja_env更改Jinja2设置。 模板环境中的全局函数、过滤器和测试器分别存储在Environment对象的globals、filters和tests属性中，这三个属性都是字典对象。可以直接操作这三个字典来添加相应的函数或变量。 添加自定义全局对象 123456def bar(): return 'I am bar'foo = 'I am foo'app.jinja_env.globals['bar'] = barapp.jinja_env.globals['foo'] = foo 添加自定义过滤器 1234def smiling(s): return s + ':)' app.jinja_env.filters['smiling'] = smiling 添加自定义测试器 123456def baz(n): if n == 'baz': return True return False app.jinja_env.tests['baz'] = baz 模板结构组织 局部模板 当多个独立模板总都会使用同一块HTML代码时，可以把这部分代码抽离出来，存储到局部模板中。这样一方面可以避免重复，另一方面也可以方便统一管理。 1&#123;% include &apos;xxx.html&apos; %&#125; 模板继承 Jinja2的模板继承允许定义一个基模板，把网页上的导航栏、页脚等通用内容放在基模板中，而每一个继承基模板的子模板在被渲染时都会自动包含这些部分。 为了能够让子模板方便地覆盖或插入内容到基模板中，需要在基模板中定义块(block)，在子模板中可以通过定义同名的块来执行继承操作。 模板进阶加载静态文件一个Web项目不仅需要HTML模板，还需要虚度静态文件，比如CSS、JavaScript文件、图片及音频等。在Flask程序中，默认需要将静态文件存储在与主脚本（包含程序实例的脚本）同级目录的static文件夹中。 为了在HTML文件中引用静态文件，需要使用url_for() 函数获取静态URL。Flask内置了用于获取静态文件的试图函数，端点值为static， 默认URL规则为 static/path:filename，URL变量filename是相对于static文件夹根目录的文件路径。 例如： 123&lt;img src=\"&#123;&#123; url_for('static', filename='xxx.jpg') &#125;&#125;\" &gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"&#123;&#123; url_for('static', filename='styles.css') &#125;&#125;\" &gt; 使用CSS框架在编写Web程序时，手动编写CSS比较麻烦，常见的做法是使用CSS框架来为程序添加样式。CSS框架内置了大量可以直接使用的CSS样式类和JavaScript函数，使用它们可以非常快速地让程序页面变得美观和易用，同时也可以定义自己的CSS文件来进行补充和调整。 12345678&#123;% block sysles %&#125; &lt;link ref=\"stylesheet\" href=\"&#123;&#123; url_for('static', filename='css/bootstrap.min.css') &#125;&#125;\" &gt;&#123;% endblock %&#125;...&#123;% block script %&#125; &lt;script scr=\"&#123;&#123; url_for('static', filename='js/jquery.min.js') &#125;&#125;\"&gt;&lt;/script&gt; &lt;script src=\"&#123;&#123; url_fro('static', filename='js/popper.min.js') &#125;&#125;\"&gt;&lt;/script&gt;&#123;% endblock %&#125; 消息闪现Flask提供了一个非常有用的flash() 函数，它可以用来“闪现”需要显示给用户的消息。在视图函数中调用flash()函数，传入消息内容即可“闪现”一条消息。发送的消息会存储在session中，需要在模板中使用全局函数get_flashed_messages() 获取消息并将其显示出来。 123456from flask import flash@app.route('/') def just_flash(): flash('I am flash, who is looking for me.') return redirect(url_for('index')) 表单HTML表单HTML表单的具体定义和用法访问http://www.w3.org/TR/html401/interact/forms.html 使用Flask-WTF处理表单在模板中渲染表单提交表单出于安全考虑，一般使用POST方法提交表单。使用POST方法时，按照默认的编码类型，表单数据会被存储在请求主体中。 为了支持接收表单提交发送的POST请求，必须在app.route()装饰器里使用methods关键字为路由指定HTTP方法。 1234@app.route('/', methods=['GET', 'POST'])def basic(): form = LoginForm() return render_template('basic.html', form=form) 验证表单数据 客户端验证和服务器端验证 客户端验证 指在客户端（比如Web浏览器）对用户的输入值进行验证。客户端方式可以实时动态提示用户输入是否正确，只有用户输入正确后才会将表单数据发送到服务器。客户端验证可以增强用户体验，降低服务器负载。 服务器端验证 指用户把输入的数据提交到服务器，在服务器端对数据进行验证。如果验证出错，就在返回的响应中加入错误信息。 客户端验证和服务器端验证都是必不可少的。 WTForms验证机制 WTForms验证表单字段的方式是在实例化表单类时传去表单数据，然后对表单实例调用validate() 方法。 表单进阶自定义验证器在WTForms中，验证器是指在定义字段时传入validators参数列表的可调用对象。 行内验证器 12345678910from wtforms import IntegerField, SubmitFieldfrom wtforms.validators import ValidationErrorclass FortyTwoForm(FlaskForm): answer = IntegerField('The Number') submit = SubmitField() def validate_answer(form, field): # 验证器在表单类中定义 if field.data != 42: raise ValidationError('Must be 42') 当表单类总包含以“validate_字段属性名“形式命名的方法时，在验证字段数据时会同时调用这个方法来验证对应的字段，这也是为什么表单类的字段属性名不能以validate开头。 全局验证器 123456789from wtforms.validators import ValidationErrordef is_42(form, field): # 验证器在表单类外定义 if filed.data != 42: raise ValidationError('Must be 42') class FortyTwoForm(FlaskForm): answer = IntegerField('The Number', validators=[is_42]) submit = SubmitField() 文件上传在HTML中，渲染一个文件上传字段只需要将标签的type属性设为file，即。这会在浏览器中渲染陈一个文件上传字段，单机文件选择按钮会打开文件选择窗口，选择对应的文件后，被选择的文件名会显示在文件选择按钮旁边。 定义上传表单 在Python表单类中创建文件上传字段时，使用扩展Flask-WTF提供的FileField类，它继承了WTForm提供的上传字段FileField，添加了对Flask的集成。 例： 1234from flask wtf.file import FileField, FileRequired, FileAllowedclass UploadForm(FlaskForm): photo = FileField('Upload Image', validators=[FileRequired(), FileAllowed(['jpg', 'jpeg', 'png', 'gif'])]) submit = SubmitField() 渲染上传表单 在创建的upload视图里，实例化表单类UploadForm，然后传入模板： 12345@app.route('/upload', methods=['GET', 'POST'])def upload(): form = UploadForm() ... return render_template('upload.html, form=form) 12345&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; &#123;&#123; form.csrf_token &#125;&#125; &#123;&#123; form_field(form.photo) &#125;&#125; &#123;&#123; form.submit() &#125;&#125;&lt;/form&gt; 处理上传文件 和普通的表单数据不同，当包含上传文件字段的表单提交后，上传的文件需要在请求对象的files属性（reuqest.files）中获取。 当使用Flask-WTF时，它会自动帮我们获取对应的文件对象。这里使用表单类属性的data属性获取上传文件。 123456789101112131415import osapp.config['UPLOAD_PATH'] = os.path.join(app.root_path, 'uploads')@app.route('/upload', methods=['GET', 'POST'])def upload(): form = UploadForm() if form.validate_on_submit(): f = form.photo.data filename = random_filename(f.filename) f.save(os.path.join(app.config['UPLOAD)PATH'], filename)) flash('Upload success.') session['filenames'] = [filename] return redirect(url_for('show_images')) return render_template('upload.html', form=form) 使用Flask-CKEditor集成富文本编辑器1$ pipenv install flask-ckeditor # 安装 1）实例化Flask-CkEditor提供的CkEditor类，传入程序实例 123from flask_ckeditor import CKEditorckeditor = CKEditor() 2）渲染富文本编辑器 123456789from flask_wtf import FlaskFormFrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequired, Lengthfrom flask_ckeditor import CKEditorFieldclass RichTextForm(FlaskForm): title = StringField('Title', validators=[DataRequired(), Length[1. 50]]) body = CKEditorField('Body', validators=[DataRequeired()]) submit= SubmitField('Publish') 123456789&#123;% block content %&#125;&lt;h1&gt;Integrate CKEditor with Flask-CKEditor&lt;/h1&gt;&lt;form method=\"post\"&gt; &#123;&#123; form.csrf_token &#125;&#125; &#123;&#123; form_field(form.title) &#125;&#125; &#123;&#123; form_field(form.body) &#125;&#125; &#123;&#123; form.submit &#125;&#125;&lt;/form&gt;&#123;% endblock %&#125; 单个表单多个提交按钮1234567891011121314class NewPostForm(FlaskForm): title = String('Title') ... save = SubmitField('Save') publish = SubmitField('Publish') @app.route('/xxx', methods=['GET', 'POST'])def two_submits(): form = NewPostForm() if form.validate_on_submit(): if form.save.data: .... elif form.publish.data: .... 数据库电子邮件Flask程序的自动化测试Flask程序性能优化部署FLask程序Flask的一些设计理念后续补充","categories":[{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/categories/Flask/"}],"tags":[{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/tags/Web开发/"},{"name":"Flask","slug":"Flask","permalink":"http://yoursite.com/tags/Flask/"}]},{"title":"Linux环境变量PATH","slug":"Linux_环境变量PATH","date":"2019-02-24T16:00:00.000Z","updated":"2019-07-06T09:07:58.988Z","comments":true,"path":"2019/02/25/Linux_环境变量PATH/","link":"","permalink":"http://yoursite.com/2019/02/25/Linux_环境变量PATH/","excerpt":"","text":"环境变量$PATH在Linux中，执行命令时，系统会按照PATH的设置，去每个PATH定义的路径下搜索执行文件，先搜索到的文件先执行。（From：《鸟哥的LINUX私房菜》） 改变PATH直接修改$PATH值：12echo $PATH //查看当前PATH的配置路径export PATH=$PATH:/xxx1:/xxx2 //将需要的配置路径加入$PATH 等号两边没有空格，path之间用':'间隔 生效方法：立即生效 有效期限：临时改变，只对当前终端有效，关闭后恢复原来的PATH 用户局限：仅当前用户 通过修改.bashrc文件：（.bashrc文件在根目录下）12345vim .bashrc // 编辑.bashrc文件// 在最后一行添加：export PATH=$PATH:/xxx/xxx // /xxx/xxx为需要加入的环境变量地址，等号两边无空格 生效方法：（有一下两种） 关闭当前终端窗口，重新打开一个新的终端窗口即可 输入 1source .bashrc 命令，立即生效。 有效期限：永久有效 用户局限：仅当前用户 通过修改profile文件：（profile文件在/etc目录下）12345vim /etc/profile // 编辑profile文件// 在最后一行添加：export PATH=$PATH:/xxx/xxx 生效方法：系统重启 有效期限：永久有效 用户局限：所有用户 通过修改environment文件：（environment文件在/etc目录下）123vim /etc/environment //编辑environment文件在PATH=/.......中加入“:/xxx/xxx” 生效方法：系统重启 有效期限：永久有效 用户局限：所有用户","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"http://yoursite.com/tags/环境变量/"}]},{"title":"Ubuntu环境","slug":"Ubuntu快速配置工作环境","date":"2019-02-24T16:00:00.000Z","updated":"2019-07-06T08:42:11.530Z","comments":true,"path":"2019/02/25/Ubuntu快速配置工作环境/","link":"","permalink":"http://yoursite.com/2019/02/25/Ubuntu快速配置工作环境/","excerpt":"","text":"Ubuntu工作环境快速配置首先更新一下 1sudo apt update &amp;&amp; sudo apt upgrade 更换软件源详情https://blog.csdn.net/JRRRJ/article/details/81082444 将阿里源添加到sources.list中 1deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 保存退出，然后更新。 安装显卡驱动在「软件和更新」-「附加驱动」选项卡中进行选择 基础软件安装VIM1sudo apt install vim vim 个人配置.vimrc (保存在个人百度网盘快速配置Ubuntu环境文件夹) 搜狗输入法https://blog.csdn.net/fx_yzjy101/article/details/80243710 Git1sudo apt install git PyCharmhttps://blog.csdn.net/qq_15192373/article/details/81091278 ipython1sudo apt install ipython3 flask安装详情见flask官网 Typora(Markdown编辑)安装详情见Typora官网 Shutter(截图软件)详情见https://blog.csdn.net/qq_19339041/article/details/80058892 WPS先卸载LibreOffice 1sudo apt-get remove --purge libreoffice* 下载安装访问WPS官网 MySQL &amp;&amp; Redis12sudo apt install mysql-serversudo apt install redis-server WechatUbuntu 18.04 安装微信（Linux通用）","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"配置","slug":"配置","permalink":"http://yoursite.com/tags/配置/"}]},{"title":"django开发问题整理","slug":"django_web_开发错误整理","date":"2019-02-24T16:00:00.000Z","updated":"2019-07-06T09:12:50.422Z","comments":true,"path":"2019/02/25/django_web_开发错误整理/","link":"","permalink":"http://yoursite.com/2019/02/25/django_web_开发错误整理/","excerpt":"","text":"在使用Django2.0进行Web开发过程中遇到的问题Django在根据models生成数据库表时报 _ init _()missing 1 required positional argument: ‘on_delete’ 原因 在django2.0后，定义外键和一对一关系的时候需要加on_delete选项，此参数为了避免两个表里的数据不一致问题，不然会报错：TypeError: _ init _() missing 1 required positional argument: ‘on_delete’ 解决方法 1234567# 以下代码报错user = models.OneToOneField(User)owner = models.ForeignKey(UserProfile)# 以下代码正确user = models.OneToOneField(User, on_delete=models.CASCADE)owner = models.ForergnKey(UserProfile, on_delete=models.CASCADE) 参数说明 on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值。CASCADE：此值设置，是级联删除。PROTECT：此值设置，是会报完整性错误。SET_NULL：此值设置，会把外键设置为null，前提是允许为null。SET_DEFAULT：此值设置，会把设置为外键的默认值。SET()：此值设置，会调用外面的值，可以是一个函数。一般情况下使用CASCADE就可以了。 Django2.0配置Mysql数据库后执行数据迁移时报错： 报错 1django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None 原因 MySQLclient目前只支持到python3.4 解决方法 因为要使用python3.6，所以修改下面路径的文件： 1$ vim /home/utur/.local/lib/python3.6/site-packages/django/db/backends/mysql 将以下代码注释即可： 12if version &lt; (1, 3, 3): raise ImproperlyConfigured(\"mysqlclient 1.3.3 or newer is required; you have %s\" % Database.__version__) MySQL: django.db.utils.OperationalError:( 1698, “Access denied for user ‘roo‘@’localhost’”) with correct username and pw 详情见：https://stackoverflow.com/questions/41542045/mysql-django-db-utils-operationalerror-1698-access-denied-for-user-root 解决方法 123create user &apos;django&apos;@&apos;localhost&apos; identified by &apos;django-user-password&apos;;grant usage on *.* to &apos;django&apos;@&apos;localhost&apos;;grant all privileges on django-database-1.* to &apos;django&apos;@&apos;localhost&apos;; AttributeError: ‘str’ object has no attribute ‘decode’ 报错 执行 1python3 manage.py makemigrations 报错 123 File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/Django-2.2-py3.7.egg/django/db/backends/mysql/operations.py\", line 146, in last_executed_query query = query.decode(errors='replace')AttributeError: 'str' object has no attribute 'decode' 原因 python在bytes和str两种类型转换，所需要的函数依次是encode(),decode() 解决方法 在报错路径下 1vim operations.py 找到错误代码 1query = query.decode(errors='replace') 修改为 12query = query.encode(errors='replace')# 保存并退出 include() got an unexpected keyword argument ‘app_name’ 原因 在Django2.0版本使用url()导致，推荐使用path() 解决方法 在xxx应用下的urls.py添加app_name变量 12345678910from django.contrib import adminfrom django.conf.urls import url,includeapp_name = xxxurlpatterns = [ # 路由规则 ...]","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/tags/Web开发/"}]},{"title":"消息队列Kafka学习笔记","slug":"Apache_Kafka","date":"2019-02-24T16:00:00.000Z","updated":"2019-07-06T08:50:18.649Z","comments":true,"path":"2019/02/25/Apache_Kafka/","link":"","permalink":"http://yoursite.com/2019/02/25/Apache_Kafka/","excerpt":"","text":"Kafka简介Kafka是一款由美国领英公司（LinkedIn）开源出来的高性能消息引擎系统（Messaging system）,其核心功能是——高性能的消息发送与高性能的消息消费。但随着Kafka的不断演进，在Kafka 0.10.0.0版本正式推出了Kafka Streams，即流式处理组件。自此Kafka正式成为了一个流式处理框架。 前置知识背景消息引擎系统消息引擎，又叫消息队列，消息中间件等。 根据维基百科的定义，企业消息引擎系统（EMS）是企业发布的一组规范。公司使用这组规范实现在不同系统之间传递语义准确的消息。在实际使用场景中，消息引擎系统通常以软件接口为主要形式，实现了松耦合的异步式数据传递语义。 消息引擎范型根据维基百科定义，一个消息引擎范型是一个基于网络的架构范型，描述了消息引擎系统的两个不同的子部分是如何互连且交互的。如果把消息引擎系统的这两个子系统比喻成两座城市，那么传输协议就是需要铺设的沥青公路，而引擎范型决定了来往穿梭与这两座城市的路线。 最常见的两种消息引擎范型是消息队列模型和发布/订阅模型。 消息队列（message queue）模型是基于队列提供消息传输服务的，多用于进程间通信以及线程间通信。该模型定义了消息队列、发送者和接收者，提供了一种点对点的消息传递方式，即发送者发送每条消息到队列的指定位置，接收者从指定位置获取消息。每条消息由一个发送者生产出来，且只被一个消费者处理。 发布/订阅模型(publish/subscribe),它有主题（topic）的概念：一个topic可以理解为逻辑语义相近的消息的容器。这种模型定义了类似于生产者/消费者这样的角色，即发布者和订阅者。发布者将消息生产出来发送到指定的topic中，所有订阅了该topic的订阅者都可以接收到该topic下的所有消息。 Kafka术语消息既然Kafka的核心功能就是消息引擎，那么对消息的设计日然是首当其冲的事情。Kafka在消息设计时特意避开了繁重的Java堆上内存分配，直接使用紧凑二进制字节数组ByteBuffer而不是独立的对象，因此至少能够访问多一倍的可用内存。 省去padding，java对对象保存的大开销以及可能的页缓存。 topic和partiiton从概念上来说，topic只是一个逻辑概念，代表了一类消息，也可以认为是消息被发送到的地方。通常可以使用topic来区分实际业务，比如业务A使用一个topic，业务B使用另一个topic。 Kafka中的topic通常都会被多个消费者订阅，出于性能的考量，Kafka并不是topic-message的两级结构，而是采取了topic-partition-message的三级结构来分散负载。从本质上来说，每个Kafka topic都由若干个partition组成。 topic是由多个partition组成的，而Kafka的partition是不可修改的有序消息队列，也可以说是有序的消息日志。每个partition都有自己专属的partition号。用户对partition唯一能做的操作就是在消息序列的尾部追加写入消息。partition上的每条消息都会被分配一个唯一的序列号-该序列号被称为位移（offset）。位移信息可以唯一定位到某partition下的一条消息 offset实际上，Kafka消费者也有位移（offset）的概念，但这两个offset属于不同的概念。 每条消息在某个partition的位移是固定的，但消费该partition的消费者的位移会随着消费进度不断前移，但不能超过该分区最新一条消息的位移。 从本质上看，Kafka中的一条消息其实就是一个&lt;topic,partition,offset&gt;三元组（tuple），通过该元组，可以在Kafka集群中找到位移对应的那条消息。 replica为了实现高可靠性，通过冗余机制——备份多份日志。这些备份日志在Kafka中被称为副本（replica），它们存在的唯一目的就是防止数据丢失。 副本分为两类：领导者副本（leader replica）和追随者副本（follower replica）。follower replica是不能提供服务给客户端的，它只是被动地向领导者副本（leader replica）获取数据，一旦leader replica所在的broker宕机，Kafka会从剩余的replica中选举出新的leader继续提供服务。 ISRISR的全称是 in-sync replica，就是与leader replica保持同步的replica集合。 Kafka为partition动态维护一个replica集合。该集合中的所有replica保存的消息日志都与leader replica保护同步状态。只有这个集合中的replica才能被选举为leader，也只有该集合中所有replica都接收到了同一条消息，Kafka才会将该消息置于“已提交”状态，即认为这条消息发送成功。Kafka承诺只要这个集合中至少存在一个replica，那些”已提交“状态的消息就不会丢失。 Kafka使用场景 消息传输 网站行为日志追踪 审计数据收集 日志收集 Event Sourcing 流式处理 Kafka设计原理broker端设计架构broker是Apache Kafka最重要的组件，本质上它是一个功能载体（或服务载体），承载了绝大多数的Kafka服务。事实上，大多数的消息队列框架都有broker或已知类似的角色。一个broker通常是以服务器的形式出现的。 消息设计 消息格式 V2版本分为消息和消息集合两个维度，不过消息集合的提法被消息批次所取代。V2版本中，它有一个专门的属于：RecordBatch。 V2版本消息格式 “可变长度”表示Kafka会根据具体的值来确定到底需要几字节保存。为了在序列化时降低使用的字节数，V2版本借鉴了Google ProtoBuffer中的Zig-zag编码方式，使得绝对值较小的整数占用字节数较少的字节。 消息batch CRC值从消息层面被移除，放入batch这一层 PID、producer epoch和序列号等消息都是0.11.0.0版本为了实现幂等性producer和支持事务而一如的。 通过使用mirco-batch，批次地发送消息，能大幅度地提高Kafka的吞吐量。 集群管理Kafka是分布式的消息引擎集群环境，支持自动化的服务发现与成员管理。依赖于Apache Zookeeper实现，每当一个broker启动，它会将自己注册到Zookeeper下的一个节点。 首先，每个broker在Zookeper下注册节点的路径是chroot/brokers/ids/&lt;broker.id&gt;。如果没有配置chroot，则路径是/broker/ids/&lt;broker.id&gt;。 其次，broker向Zookeeper中的注册消息以JSON格式保存。 12345678910111213141516&#123; \"version\": 4, \"host\": \"loacalhost\", \"port\": 9092, \"jmx_port\": 9999, \"timestamp\": 1499737197, \"endpoints\": [ \"CLIENT\"://host1:9092\", \"REPLICATION://HOST1:9093\" ], \"listener_security_protocol_map\": &#123; \"CLIENT\": \"SSL\", \"REPLICATION\": \"PLAINTEXT\" &#125;, \"rack\": \"dc1\"&#125; 最后，Zookeeper临时节点的生命周期和客户端会话绑定。如果客户端会话失效，该临时节点就会自动被清除掉。Kafka正是利用Zookeeper临时节点来管理broker生命周期的。broker启动时在Zookeeper中创建对应的临时节点，同时还会创建一个监听器（listener）监听该临时节点的状态；一旦broker启动后，监听器会自动同步整个集群消息到该broker上；而一旦broker崩溃，它与Zookeeper的会话就会失效，导致临时节点被删除，监听器被触发，然后处理broker崩溃的后续事宜。这就是Kafka管理集群及其成员的主要流程。 副本与ISR设计一个Kafka分区本质上就是一个备份日志，即利用多份相同的备份共同提供冗余机制来保持系统高可用性。这些备份在Kafka中被称为副本（replica）。 follower副本同步 起始位移（base offset）：表示该副本当前所含第一条消息的位移 高水印值（high watermark，HW）：副本高水印值。它保存了该副本最新一条已提交消息的位移。leader分区的HW值决定了副本中已提交消息的范围，也确定了consumer能够获取消息的消息上限。任何一个副本对象的HW值一定不大于其LEO值。Kafka对leader副本和follower副本的HW值更新机制是不同的。 日志末端位移（log end offset，LEO）：副本日志中下一条待写入消息的offset。所有副本都需要维护自己的LEO信息。只有ISR中的所有副本都更新了对应的LEO之后，leader副本才会向右移动HW值表明消息写入成功。Kafka对leader副本和follower副本的LEO值更新机制也是不同的。 水印（watermark）和leader epoch 水印被称为高水印或高水位，通常被用在流水式处理领域，以表征元素或时间在基于时间层面上的进度。在Kafka中，水印的概念与时间无关，而与位置信息相关。严格来说，它表示的就是位置信息，即位移（offset）。 LEO更新机制 follower follower副本不停地向leader副本所在broker发送FETCH请求，一旦获取消息，便写入自己的日志中进行备份。 Kafka设计了两套follower副本LEO属性：一套LEO属性保存在follower副本所在broker的缓存上；另一套LEO值保存在leader副本所在broker的缓存上。换句话说，leader副本所在broker的缓存上保存了该分区下所有follower副本的LEO属性值。 follower副本端LEO更新 每当在底层日志新写入一条消息，其LEO值就会加1. leader副本端的follower副本LEO更新 一旦leader接收到follower发送的FETCH请求，它首先会从自己的log中读取相应的数据，但是在给follower返回数据之前它先去更新follower的LEO。 leader 每当在底层日志新写入一条消息，其LEO值就会加1. HW更新机制 前面说过，leader broker上保存了一套follower副本的LEO以及它自己的LEO。当尝试确定分区HW时，它会选出所有满足条件的副本，比较它们的LEO，并选择最小的LEO值作为HW值。 图解Kafka备份原理 基于水印机制的缺陷 数据丢失：使用HW值来确定备份进度时其值的更新是在下一轮RPC中完成的。延迟一轮FETCH请求更新HW的值的设计使得followerHW值是异步延迟更新的，若在这个过程中leader发生变更，那么称为新leader的follower的HW值就有可能是过期的，使得clients端认为成功提交的消息被删除了。 数据不一致/数据离散：leader端log和follower端的log数据不一致 leader epoch 上述两个问题的根本原因在于HW值被用于衡量副本备份的成功与否，以及在出现崩溃时作为日志截断的依据，但HW值的更新是异步延迟的，特别是需要额外的FETCH请求处理流程才能更新，这中间发生的任何崩溃都可能导致HW值的过期 leader epoch，实际上是一对值(epoch，offset)。epoch表示leader的版本号，从0开始，当leader变更过1次时，epoch就会+1，而offset则对应于该epoch版本的leadre写入第一条消息的位移。 通信协议 协议设计 所谓通信协议，就是实现client-server间或server-server间数据传输的一套规范。Kafka通信协议是基于TCP之上的二进制协议，这套协议提供的API表现为服务于不同功能的多种请求类型以及对应的相应。所有类型的请求和响应都是结构化的，有不同的初始类型构成。 常见请求类型 PRODUCE请求 FETCH请求 METADATA请求 请求处理流程 clients端 broker端 controller设计 controller概览 在一个Kafka集群中，某一个broker会被选举出来承担特殊的角色，即控制器。一如controller就是用来管理和协调Kafka集群的。具体来说，就是管理集群中所有分区的状态并执行相应的管理操作。 controller管理状态 controller维护的状态分为两类：每台broker上的分区副本和每个分区的leader副本信息。从维度上看，这些状态可分为副本状态和分区状态。 副本状态机 分区状态机 controller职责 更新集群元数据信息 创建topic 删除topic 分区重分配 preferred leader副本选举 topic分区扩展 broker加入集群 broker崩溃 受控关闭 controller leader选举 broker请求处理 Reactor模式 Kafka broker处理请求的模式就是Reactor设计模式。Reactor设计模式是一种事件处理模式，旨在处理多个输入源同时发送过来的请求。Reactor模式中的服务处理器或分发器将入站请求按照多路复用的方式分发到对应的请求处理器。 Kafka broker请求处理 Kafka broker请求处理实现了Reactor模式。在Kafka中，每个broker都有一个acceptor线程和若干个processor线程。processor线程的数量是可以配置的。 producer端设计架构producer端基本数据结构 ProducerRecord 一个ProducerRecord封装了一条待发送的消息（或称为记录）。 ProducerRecord由5个字段构成: topic：该消息所属的topic partition：该消息所属的分区 key：消息key value：消息体 timestamp：消息时间戳 RecordMetadata 该数据结构表示Kafka服务器端返回给客户端的消息的元数据 offset：消息在 分区日志中的位移信息 timesstamp：消息时间戳 topic/partition checksum：消息CRC32码 serializedKeySize：序列化后消息的key字节数 serializedValueSize：序列化后消息value字节数 工作流程如果把producer统一看成一个盒子，那么整个producer端的工作原理便如图所示。大体来说，用户首先构建待发送的消息对象ProducerRecord，然后调用KafkaProducer#send方法进行发送。KafkaProducer接收到消息后首先对其进行序列化，然后结合本地缓存的元数据信息一起发送给partitioner去确定目标分区，最后追加写入内存中的消息缓冲池。 调用KafkaProducer.send执行的操作： 序列化+计算目标分区 追加写入消息缓冲区 Sender线程预处理及消息发送 consumer端设计架构consumer group 状态机新版本consumer依赖于broker端的组协调者coordinator来管理组内的所有consumer实例并负责把分配方案发到每个consumer上。分配方案由组内的leader consumer根据指定的分区分配策略指定的。 分区分配的操作在consumer端执行而非broker端的好处： 便于维护与升级：如果在broker端实现，那么分配策略的变动势必要重启整个Kafka集群。生产环境中重启服务器的代价是很高的。 便于实现自定义策略：不同的策略由不同的逻辑实现。coordinator端代码不容易实现灵活可定制的分配逻辑 解耦了组管理与分区分配，coordinator负责组管理工作，而consumer程序负责分区分配。 Kafka为每个consumer group定义了5个状态： Empty：表明group下没有任何active consumer，但可能包含位移信息。 PreparingRebalance：该状态表明group正在准备进行group rebalance。 AwaitingSync：该状态表明所有成员都已经加入组并等待leader consumer发送分区分配方案。 Stable：该状态表明group开始正常消费。此时group必须响应clients发送过来的任何请求。 Dead：该状态表明group已经彻底废弃，group内没有任何成员并且group的所有元数据都已被删除。 实现精确一次处理语义(exactly-once semanties, EOS)clients端常见的3种消息交付语义： 最多一次（ai most once）：消息可能丢失也可能被处理，但最多只会被处理一次 至少一次（at last once）：消息不会丢失，但可能被多次处理 精确一次（exactly once）：消息被处理且只会被处理一次。 幂等性producer（idempotent producer）幂等性producer是Apache Kafka 0.11.0.0版本用于实现EOS的一个利器。若一个操作执行多次的结果与只运行一次的结果是相同的，那么称该操作为幂等操作。引入幂等producer表示它的发送操作是幂等。瞬时的发送错可能导致produecer端出现重试，同一个消息被producer发送多次，但在broker端这条消息只会被写入日志一次。 幂等性producer的设计思路类似于TCP的工作方式。发送到broker端的每批消息都会被赋予一个序列号（sequence number）用于消息去重。但是和TCP不同的是，这个序列号不会被丢弃，相反Kafka会把它们保存在底层日志中，这样即使分区的leader副本挂掉，新选出来的leader broker也能执行消息去重工作。 事务（transaction）对事务的支持是Kafka实现EOS的第二个利器。引入事务使得clients端程序（无论是producer还是consumer）能够将一组消息放入一个原子性单元中统一处理。 处于事务中的这组消息能够从多个分区中消费，也可以发送到多个分区中。重要的是不论是发送还是消费，Kafka都能保证它们是原子性，即所有的写入操作幺妹全部成功，要么全部失败。 Kafka为实现事务要求应用程序必须提供一个唯一的id来表征事务。这个id被称为事务id，它必须在应用程序所有的会话上是唯一的。 PS：未完待续，后续深入学习再做补充","categories":[{"name":"Kafka","slug":"Kafka","permalink":"http://yoursite.com/categories/Kafka/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://yoursite.com/tags/Kafka/"}]}]}