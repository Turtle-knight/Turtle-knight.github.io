<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="木龟想做一个哈皮程序猿。">
<meta property="og:type" content="website">
<meta property="og:title" content="Utur的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Utur的个人博客">
<meta property="og:description" content="木龟想做一个哈皮程序猿。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Utur的个人博客">
<meta name="twitter:description" content="木龟想做一个哈皮程序猿。">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Utur的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Utur的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">天天学习，好好向上</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Linux_环境变量PATH/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Linux_环境变量PATH/" class="post-title-link" itemprop="url">Linux环境变量PATH</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:07:58" itemprop="dateModified" datetime="2019-07-06T17:07:58+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="环境变量-PATH"><a href="#环境变量-PATH" class="headerlink" title="环境变量$PATH"></a>环境变量$PATH</h2><p>在Linux中，执行命令时，系统会按照PATH的设置，去每个PATH定义的路径下搜索执行文件，先搜索到的文件先执行。（From：《鸟哥的LINUX私房菜》）</p>
<h2 id="改变PATH"><a href="#改变PATH" class="headerlink" title="改变PATH"></a>改变PATH</h2><h3 id="直接修改-PATH值："><a href="#直接修改-PATH值：" class="headerlink" title="直接修改$PATH值："></a>直接修改$PATH值：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH //查看当前PATH的配置路径</span><br><span class="line">export PATH=$PATH:/xxx1:/xxx2 //将需要的配置路径加入$PATH 等号两边没有空格，path之间用':'间隔</span><br></pre></td></tr></table></figure>
<ul>
<li>生效方法：立即生效</li>
<li>有效期限：临时改变，只对当前终端有效，关闭后恢复原来的PATH</li>
<li>用户局限：<strong>仅当前用户</strong></li>
</ul>
<h3 id="通过修改-bashrc文件：（-bashrc文件在根目录下）"><a href="#通过修改-bashrc文件：（-bashrc文件在根目录下）" class="headerlink" title="通过修改.bashrc文件：（.bashrc文件在根目录下）"></a>通过修改.bashrc文件：（.bashrc文件在根目录下）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc  // 编辑.bashrc文件</span><br><span class="line"></span><br><span class="line">// 在最后一行添加：</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/xxx/xxx    // /xxx/xxx为需要加入的环境变量地址，等号两边无空格</span><br></pre></td></tr></table></figure>
<ul>
<li><p>生效方法：（有一下两种）</p>
<ol>
<li><p>关闭当前终端窗口，重新打开一个新的终端窗口即可</p>
</li>
<li><p>输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>
<p>命令，立即生效。</p>
</li>
</ol>
</li>
<li><p>有效期限：永久有效</p>
</li>
<li>用户局限：<strong>仅当前用户</strong></li>
</ul>
<h3 id="通过修改profile文件：（profile文件在-etc目录下）"><a href="#通过修改profile文件：（profile文件在-etc目录下）" class="headerlink" title="通过修改profile文件：（profile文件在/etc目录下）"></a>通过修改profile文件：（profile文件在/etc目录下）</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile    // 编辑profile文件</span><br><span class="line"></span><br><span class="line">// 在最后一行添加：</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/xxx/xxx</span><br></pre></td></tr></table></figure>
<ul>
<li>生效方法：系统重启</li>
<li>有效期限：永久有效</li>
<li>用户局限：<strong>所有用户</strong></li>
</ul>
<h3 id="通过修改environment文件：（environment文件在-etc目录下）"><a href="#通过修改environment文件：（environment文件在-etc目录下）" class="headerlink" title="通过修改environment文件：（environment文件在/etc目录下）"></a>通过修改environment文件：（environment文件在/etc目录下）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/environment    //编辑environment文件</span><br><span class="line"></span><br><span class="line">在PATH=/.......中加入“:/xxx/xxx”</span><br></pre></td></tr></table></figure>
<ul>
<li>生效方法：系统重启</li>
<li>有效期限：永久有效</li>
<li>用户局限：<strong>所有用户</strong></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/编程范式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/编程范式/" class="post-title-link" itemprop="url">编程范式</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:39:05" itemprop="dateModified" datetime="2019-07-06T17:39:05+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>编程范式的英语是 programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格。</p>
<p>编程语言发展到今天，出现了好多不同的代码编写方式，<strong><em>但不同的方式解决的都是同一个问题，那就是如何写出更为通用、更具可重用性的代码或模块</em></strong>。</p>
<p>下面给一张表格说明以下世界上四大编程范式的类别，它们的特性和主要的编程语言。</p>
<p><img src="/home/utur/图片/picture_for_note/编程范式/programming paradigm.png" alt="programming paradigm"></p>
<h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>为了讲清楚这个问题，需要从C语言开始讲起。因为C语言历史悠久，而几乎现在看到的所有编程语言都是以C语言为基础来拓展的，不管是C++、Java、C#、Go、Python、PHP、JavaScript，还会Shell。</p>
<p>自C语言问世40多年来，其影响了太多太多的编程语言，到现在还一直被广泛使用，不得不佩服它的生命力。但是，我们也要清楚地直到，大多数C Like编程语言其实都是在改善C语言带来的问题。</p>
<p>C语言特性：</p>
<ol>
<li>C语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换。</li>
<li>不同的变量类型可以用结构体（struct）组合在一起，以此来生命新的数据类型。</li>
<li>C语言可以用typedef关键字来定义类型的别名，以此来达到变量类型的抽象。</li>
<li>C语言是一个结构化程序设计、具有变量作用域以及递归功能的过程式语言。</li>
<li>C语言传递参数一般是以值传递，也可以传递指针。</li>
<li>用过指针，C语言可以容易地对内存进行低级控制，然而这引入了非常大的贬称复杂度。</li>
<li>编译预处理让C语言的编译更具有弹性，比如跨平台。</li>
</ol>
<p>C语言的这些特性，可以让程序员在微观层面写出非常惊喜和精确的编程操作,让程序员可以在底层和系统细节上非常自由、灵活和精准地控制代码。</p>
<p>然而，在代码组织和功能编程上，C语言的上述特性，却不那么美妙。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据类型与现实世界类比（后续补充）</li>
</ul>
<p>可以看到，无论是传统世界，还是编程世界，我们都在干一件事情——<strong>那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的“世界”变得简单一些。</strong>（好好琢磨这句话)</p>
<p>要做到抽象，对于C语言这样的类型来说，首当其冲的就是抽象类型（这是个动词），这就是所谓的——泛型编程。</p>
<p>虽然对于C语言来说，类型可以转换，编译器会使用一切方式来做类型转换，这让相近的类型可以做到一点点的泛型，但这样的类型转换会出很多问题。</p>
<h3 id="C语言的泛型"><a href="#C语言的泛型" class="headerlink" title="C语言的泛型"></a>C语言的泛型</h3><p>C语言的类型泛型基本上来说就是使用void *关键字或是使用宏定义。</p>
<p><strong>void *泛型版本的swap函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">void</span>* x, <span class="keyword">void</span>* y, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> tmp[size];</span><br><span class="line">     <span class="built_in">memcpy</span>(tmp, y, size);</span><br><span class="line">     <span class="built_in">memcpy</span>(y, x, size);</span><br><span class="line">     <span class="built_in">memcpy</span>(x, tmp, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现方式有三个重点：</p>
<ul>
<li><strong>函数接口中增加了一个size参数。</strong>使用了void *后，类型被“抽象”掉了，编译器不能通过类型得到类型的尺寸了，所以，需要人为地加上一个类型长度的标识。</li>
<li><strong>函数的实现中使用了memcpy()函数。</strong>因为类型被“抽象”掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体。因此，为了要交换这些负责类型的值，只能使用内存复制的方法。</li>
<li><strong>函数的实现中使用了一个temp[size]数组。</strong>这就是交换数据时需要用的buffer，用buffer来做临时的空间存储。</li>
</ul>
<p><em>新增的size参数，使用memcpy内存拷贝以及一个buffer，这增加了编程的复杂度。这就是C语言的类型抽象所带来的复杂度的提升。</em></p>
<p>除了使用void *来做泛型，在C语言中，还可以用宏定义来做泛型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(x, y, size) &#123;\</span></span><br><span class="line">	<span class="keyword">char</span> temp[size]; \</span><br><span class="line">	<span class="built_in">memcpy</span>(temp, &amp;y, size); \</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;y,   &amp;x, size); \</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;x, temp, size); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换的，所以会导致代码膨胀，导致编译出的执行文件比较大。</p>
<p>除此之外，还有一个最大的问题就是<strong>有可能会有重复执行</strong>的问题。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(foo(), bar())  （foo()&gt;bar() ? foo() : bar()）</span></span><br></pre></td></tr></table></figure>
<p>本意是比较foo() 和 bar()函数的返回值，然而，经过宏替换后，foo()和bar()会被调用两次，这回带来很多问题。</p>
<p>另外，这种“泛型”太过宽松，完全不做类型检查， 就是在内存上对拷，直接操作内存，是比较危险的。</p>
<p>C语言的这种泛型，让我们根本没有办法检查传入的参数size，导致我们只能增加接口复杂度，加入一个size参数，然后把这个问题抛给调用者了。</p>
<h3 id="一个更为复杂的泛型示例-Search函数"><a href="#一个更为复杂的泛型示例-Search函数" class="headerlink" title="一个更为复杂的泛型示例-Search函数"></a>一个更为复杂的泛型示例-Search函数</h3><p>写一个search函数，传入一个int数组，搜索target，搜到返回数组下标，搜不到返回-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">size_t</span> size, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == target) &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型化：</p>
<ol>
<li>需要在函数接口上增及挨个element size，也就是数组里每个元素的size。这样遍历时，可以通过这个size正确地移动指针到下一个数组元素。</li>
<li>加个cmpFn。因为不同的数据类型的比较的实现不一样，所以，必须要自定义一个比较函数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">void</span>* a, <span class="keyword">size_t</span> size, <span class="keyword">void</span>* target, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">size_t</span> elem_size, <span class="keyword">int</span>(*cmpFn)(<span class="keyword">void</span>*, <span class="keyword">void</span>*) )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">		<span class="comment">// why not use memcmp()</span></span><br><span class="line">		<span class="comment">// use unsigned char * to calculate the address</span></span><br><span class="line">		<span class="keyword">if</span> ( cmpFn ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)a + elem_size * i, target) == <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽说看上去还行，但是，上面的这个search函数只能用于数组这样的顺序型的数据容器（数据结构）。如果这个search函数能支持一些非顺序型的数据容器，比如：堆、栈、哈希表、树、图。那么C语言来干基本上干不下去。对于像search（）这样的算法来说，数据类型的自适应问题就已经把事情搞得很复杂了。然而，数据结构的自适应就会把这个事的复杂度搞得上几个数量级。</p>
<p><strong>小结</strong></p>
<p>如果说，程序 = 算法 + 数据 ，那么C语言会有这么几个问题。</p>
<ol>
<li>一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C语言只能使用void *或宏替换的方式，这两种方式导致了类型过于宽松，并带来很多其他问题。</li>
<li>适配数据类型，需要C语言在泛型中加入一个类型的size。识别不了被泛型后的数据类型，而C语言没有运行时的类型识别，所以只能将这个工作抛给调用泛型算法的程序员来做。</li>
<li>算法其实实在操作数据结构，而数据则是放到数据结构中的。所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂度急剧上升。比如容器内存的分配和释放、对象之间的复制。</li>
</ol>
<p>总结来说，C语言设计目标是提供一种能以简易的方式编译、处理底层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C语言也很适合搭配汇编语言来使用。</p>
<p>C语言把非常底层的控制权交给了程序员，它设计的理念是：</p>
<ul>
<li>相信程序员；</li>
<li>不会阻止程序员做任何底层的事；</li>
<li>保持语言的最小和最箭的特性；</li>
<li>保证C语言的最快运行速度，哪怕牺牲移植性。</li>
</ul>
<p>从某种角度上来说，C语言的伟大之处在于——使用C语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制。这是C语言的强大和优雅之处，也有人说，C语言是高级语言中的汇编语言。</p>
<p>不过，这只是在针对底层指令控制和过程式的编程方式。而对于更高阶更为抽象的编程模型来说，C语言这种基于过程和底层的初衷设计方式就会称为它的短板。因为，在编程世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题。所以，我们需要更为贴近业务更为抽象的语言。</p>
<p>编程范式其实就是程序的指导思想，它代表了这门语言的设计方向，我们并不能说哪种范式更为超前，只能说各有千秋。</p>
<p>比如C语言就是过程是的编程语言，像C语言这样的过程式编程语言优点是底层灵活而且高j效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但在上述的问题上它在后来也没有试图去解决，因为编程范式的选择基本已经决定了它的”命运“。</p>
<hr>
<h3 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h3><p>作为一门高级语言，C语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的C语言已经无法满足更高层次的编程需要。于是，C++出现了。它既可以全面兼容C语言，又巧妙揉和了一些面向对象的编程理念。</p>
<p>从语言角度来说，实际上早期C++的许多工作是对C的强化和净化，并把完全兼容C作为强制性要求（这也是C++复杂晦涩的原因，这点java就干得比C++彻底得多）。</p>
<p>C++很大程度就是用来解决C语言中的各种问题和各种不方便的。比如：</p>
<ul>
<li>用引用来解决指针的问题</li>
<li>用namespace来解决名字空间冲突的问题</li>
<li>通过try-catch来解决检查返回值编程的问题</li>
<li>用class来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。</li>
<li>通过重载操作符来达到操作上的泛型。</li>
<li>通过模板template和虚函数的多态以及运行时识别来达到更高层次的泛型和多态</li>
<li>用RALL、智能指针的方式，解决了C语言中因为需要释放资源而出现的那些非常ugly也很容易出错的代码的问题</li>
<li>用STL解决了C语言中算法和数据结构中的N多种坑。</li>
</ul>
<h3 id="C-泛型编程"><a href="#C-泛型编程" class="headerlink" title="C++泛型编程"></a>C++泛型编程</h3><p>C++是支持编程范式最多的一门语言。    </p>
<p>理想情况下，算法应是和数据结构和类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。<strong>而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？</strong></p>
<p>C++是如何有效解决程序泛型问题的，有三点是关键：</p>
<ul>
<li><p><strong>第一，它通过类的方式来解决</strong></p>
<ul>
<li>类里面会有构造函数、析构函数表示这个类的分配和释放</li>
<li>还有它的拷贝构造函数，表示了对内存的复制</li>
<li>重载操作符</li>
</ul>
<p>这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致了。</p>
</li>
<li><p><strong>第二，通过模板达到类型和算法的妥协</strong></p>
<ul>
<li>模板有点像DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。</li>
<li>模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换的问题。</li>
</ul>
<p>模板很好地取代了C时代宏定义带来的问题</p>
</li>
<li><p><strong>第三，通过虚函数和运行时类型识别</strong></p>
<ul>
<li>虚函数带来的多态在语义上可以支持”同一类”的类型泛型</li>
<li>运行时类型识别技术可以做到在泛型时对具体类型的特殊处理</li>
</ul>
<p>这样一来，就可以写出基于抽象接口的泛型。</p>
</li>
</ul>
<h3 id="C-泛型编程示例-Search函数"><a href="#C-泛型编程示例-Search函数" class="headerlink" title="C++泛型编程示例-Search函数"></a>C++泛型编程示例-Search函数</h3><p>就像C中的search()函数，只能适用于顺序性的数据结构，并不适用于非顺序型的数据结构。所以，如果找不到一个泛型的数据结构的操作方式（如遍历、查找、增加、删除、修改等），那么，任何的算法或是程序都不可能做到真正意义上的泛型。</p>
<p>除了“遍历操作之外”，还有search函数的返回值也应该做得泛型和通用一些。如果找到，返回找到的这个元素的一个指针（地址）会更靠谱一些。</p>
<p>所以，为了解决泛型的问题，需要动用以下几个C++的技术。</p>
<ol>
<li>使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）。</li>
<li>使用一个迭代器来遍历或是操作数据结构内的元素。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function">Iter <span class="title">search</span><span class="params">(Iter pStart, Iter pEnd, T target)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(Iter p = pStart; p != pEnd; p++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( *p == target ) </span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++的泛型版本中，可以看到：</p>
<ul>
<li>使用typename T抽象了数据结构中存储数据的类型</li>
<li>使用typename Iter，这是不同的数据结构需要自己实现的”迭代器“，这样也就抽象掉了不同类型的数据结构</li>
<li>然后，对数据结构的遍历使用了Iter中的++方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历</li>
<li>在函数的入参上使用了pStart和pEnd来表示遍历的起止。</li>
<li>使用<em>Iter来取得这个”指针“的内容。这也是通过重载 </em>取值操作符来达到的泛型</li>
</ul>
<p>所谓的Iter，在实际代码中，就是像vector<int>::iterator或map&lt;int, string&gt;::iterator这样得到东西。这是由相应的数据容器来实现和提供的。</int></p>
<h3 id="C-泛型编程的重要技术-迭代器"><a href="#C-泛型编程的重要技术-迭代器" class="headerlink" title="C++泛型编程的重要技术 - 迭代器"></a>C++泛型编程的重要技术 - 迭代器</h3><p>这里，先看以下sum()函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(Iter pStart, Iter pEnd)</span> </span>&#123;</span><br><span class="line">	T result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(Iter p=pStart; p!=pEnd; p++) &#123;</span><br><span class="line">		result += *p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代 码是有问题的。代码中最大的问题就是 T result = 0;这条语句：</p>
<ul>
<li>0假设了类型是int</li>
<li>T 假设了Iter中出来的类型是T</li>
</ul>
<p>我们知道Iter在实际调用者那会是一个具体的像vertor<int>::iterator这样的东西。在这个声明中，int已经被传入Iter中。所以，定义result的T应该可以从Iter中来。这样就可以保证类型的一样的，而且不会有被转型的问题。</int></p>
<p>所以，需要实现一个”迭代器”，以下为一个“精简版”的迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">container</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> iterator self_type;</span><br><span class="line">		<span class="keyword">typedef</span> T   value_type;</span><br><span class="line">		<span class="keyword">typedef</span> T*  pointer;</span><br><span class="line">		<span class="keyword">typedef</span> T&amp; 	reference;</span><br><span class="line"></span><br><span class="line">		reference <span class="keyword">operator</span>*();</span><br><span class="line">		pointer <span class="keyword">operator</span>-&gt;();</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self_type&amp; rhs)；</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self_type&amp; rhs)；</span><br><span class="line">		self_type <span class="keyword">operator</span>++() &#123; self_type i = *<span class="keyword">this</span>; ptr_++; <span class="keyword">return</span> i; &#125;</span><br><span class="line">		self_type <span class="keyword">operator</span>++(<span class="keyword">int</span> junk) &#123; ptr_++; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		pointer _ptr;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了这个迭代器，还要解决 T result = 0 后面这个 0 的问题。这个算法没办法搞定，最好由用户传入。于是出现了下面最终泛型的 sum() 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">Iter</span>:</span>:value_type</span><br><span class="line">sum(Iter start, Iter end, T init) &#123;</span><br><span class="line">	<span class="keyword">typename</span> Iter::value_type result = init;</span><br><span class="line">	<span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">		result = result + *start;</span><br><span class="line">		start++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>typename Iter::value_type result = init 这条语句是关键。</strong>它解决了所有的问题。</p>
<h3 id="更为复杂的需求——需要更多的抽象"><a href="#更为复杂的需求——需要更多的抽象" class="headerlink" title="更为复杂的需求——需要更多的抽象"></a>更为复杂的需求——需要更多的抽象</h3><p>还能不能做到更为泛型呢。我门可能还会有别的需求：求平均值average，最小值min，求中位数mean等等。然而，我们会发现，算法写出来基本上是一样，只是其中的“累加”操作变成了另外一个操作而已。那么面对这么多的需求，我们如何解决呢？</p>
<p>要解决这个问题，我们需要明确：这个算法只管遍历，具体要干什么，那是业务逻辑，由外面的调用方来定义就好了，和算法无关。这样一来，代码的重用度就更高了。</p>
<p>因此，我们需要更高维度的抽象，这个版本不再叫sum了，这个版本应该是reduce——用于把一个数组reduce成一个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Op</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">reduce</span> (<span class="title">Iter</span> <span class="title">start</span>, <span class="title">Iter</span> <span class="title">end</span>, <span class="title">T</span> <span class="title">init</span>, <span class="title">Op</span> <span class="title">op</span>) &#123;</span></span><br><span class="line">	T result = init;</span><br><span class="line">	<span class="keyword">while</span> ( start != end ) &#123;</span><br><span class="line">		result = op( result, *start );</span><br><span class="line">		start++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">double</span> sum_salaries = </span><br><span class="line">  reduce( staff.begin(), staff.end(), <span class="number">0.0</span>,		  </span><br><span class="line">		    &#123;<span class="keyword">return</span> s + e.salary;&#125;  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> max_salary =</span><br><span class="line">  reduce( staff.begin(), staff.end(), <span class="number">0.0</span>,</span><br><span class="line">		    &#123;<span class="keyword">return</span> s &gt; e.salary? s: e.salary; &#125; );</span><br></pre></td></tr></table></figure>
<p>上面的代码中，需要传入一个函数。在STL中，它是个函数对象，result不像前面那样去加，而是把整个迭代器值给你一个operation，然后由它来做。可以很清楚地看到，reduce这个函数更通用了。具体要干什么样的事情？放在匿名函数里，它会定义如何做，算法本身只做一个reduce。</p>
<p>在C++STL中，与这个reduce函数对应的函数名叫accumulate()。</p>
<hr>
<h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组具有特定的意义和目的。</p>
<p>一般来说，编程语言还有两种类型，一种是内建类型，如int、float和char等，一种是抽象类型，如struct、class和function等。抽象类型在程序运行中，可能不表示为值。类型系统在各种语言之间有非常大的不同也许，最主要的差异在于编译时期的语法，以及运行时期的操作实现方式。</p>
<p>程序语言的类型系统主要提供如下的功能：</p>
<ul>
<li><strong>程序语言的安全性</strong>。使用类型可以让编译器侦测一些代码的错误。强类型语言提供更多的安全性，但是并不能保证绝对的安全。</li>
<li><strong>利于编译器的优化</strong>。静态类型语言的类型生命，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。</li>
<li><strong>代码的可读性。</strong>有类型的编程语言，可以让代码更易读和更易维护。代码的语义也更清楚，代码模块的接口（如函数）也更丰富和清楚。</li>
<li><strong>抽象化</strong>。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。</li>
</ul>
<p>但是，正如前面所讨论的，<strong>类型带来的问题就是作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。</strong></p>
<p>对此，这个世界出现了两类语言，一类是<strong>静态类型语言</strong>，如C、C++、Java，一类是<strong>动态类型语言</strong>，如Python、PHP、JavaScript等。</p>
<p>看一段动态类型语言的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line">x = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>
<p>如果在静态类型的语言中写出这样的代码，那么就会在编译器出错。而在动态类型的语言中，会以类型标记维持程序所有数值的“标记”，并在运算任何数值之前检查标记。所以，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态地和底层的计算机指令或内存布局对应起来。</p>
<p>再看一段代码，在弱类型或是动态类型的语言中，下面得到代码的执行会有不确定的结结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="string">"37"</span></span><br><span class="line">z = x + y</span><br></pre></td></tr></table></figure>
<ul>
<li>在Visual Basic语言中结果是42</li>
<li>在JavaScript语言中结果是“537”</li>
<li>在Python中则会产生一个运行时错误</li>
</ul>
<p><strong>我们需要清楚地知道，无论那种程序语言，都避免不了一个特定的类型系统。</strong>哪怕是可随意改变变量类型的动态类型的语言，我们在读代码的过程中也需要脑补某个变量在运行时的类型。</p>
<p>所以，每个语言都需要一个类型检查系统。</p>
<ul>
<li>静态类型检查是在编译器进行语义分析时进行的。如果一个语言强制实行类型规则（即通常只允许以不丢失信息为前期的自动类型转换），那么称此处理为强类型，反之称为弱类型</li>
<li>动态类型检查系统更多地是在运行时期做动态类型标记和相关检查。所以，动态类型的语言必然要给出一堆诸如：is_array()，is_int()，is_string()或是typeof()这样额运行时类型检查函数。</li>
</ul>
<p>总之，“类型”有时候是一个有用的东西，有时候又是一个很讨厌的事情。因为类型会对底层内存布局的一个抽象，会让我们的代码要关注于这些非业务逻辑上的东西。而且，我们的代码需要在不同类型的数据间做处理。</p>
<p>我们需要清楚地明白，<strong>任何语言都有类型系统</strong>，只是动态类型语言在运行时做类型检查。动态语言的代码复杂度较低，并可以更容易地关注业务，在某些场景下是对的，但有些情况却不见得。</p>
<h3 id="泛型的本质"><a href="#泛型的本质" class="headerlink" title="泛型的本质"></a>泛型的本质</h3><p>要了解泛型的本质，就需要了解类型的本质。</p>
<ul>
<li><strong>类型是对内存的一种抽象。不同的类型，会有不同内存布局和内存分配的策略。</strong></li>
<li>不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。</li>
</ul>
<p>所以，要做到泛型，需要做下面的事情。</p>
<ul>
<li>标准化掉类型的内存分配、释放和访问。</li>
<li>标准化掉类型的操作。比如：比较操作、I/O操作、复制操作…</li>
<li>标准化点数据容器的操作。比如：查找算法、过滤算法、聚合算法…..</li>
<li>标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作。</li>
</ul>
<p>所以，C++动用了非常繁多和复杂的技术来达到泛型编程的目标。</p>
<ul>
<li>通过类中的构造、析构、拷贝构造、重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。</li>
<li>通过重载操作符，可标准化类型的比较等操作。</li>
<li>通过isotream，标准化类型的输入输出控制</li>
<li>通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。</li>
<li>通过迭代器来标准化数据容器的遍历操作。</li>
<li>通过面向对象的接口依赖（虚函数技术），来标准化特定类型在特定算法上的操作。</li>
<li>通过函数式（函数对象），来标准化不同类型的特定操作。</li>
</ul>
<p>通过学习C++，我们可以看到一个比较完整的泛型编程里所涉及的编程范式。</p>
<p>泛型编程于1985年在论文 Generic Programming中被这样定义：</p>
<blockquote>
<p>Generic programming centers around the idea of abstractingfrom concee,efficient algorithms to obtiain generic algorithms that can be combined with different data representations to produce a wide variety of useful software</p>
<p>—Musser, David R.;Stepanov,Alexander A., Generic Programming</p>
</blockquote>
<p>其本质就是——<strong>屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。</strong></p>
<p><strong>小结：</strong></p>
<p>我们需要明白，编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注于业务逻辑代码。但是因为，编程语言作为机器代码和业务逻辑的粘合层，实在让程序员可以更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全的，是需要trade-off的事。</p>
<p>所以，不同的语言在设计上都会做相应的取舍。比如：C语言偏向于让程序眼可以控制更多的底层细节，而Java和Python则让程序员更多地关注业务功能的实现。而C++则是两者都想要，导致语言在设计上非常复杂。</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>C++ 很大程度上解决了C语言中的各种问题和不便，尤其是通过类、模板、虚函数和运行时识别解决了C语言的泛型编程问题。然而，如何做更为抽象的泛型呢？答案就是函数式编程（Functional Programming）。</p>
<p>相对于计算机的历史而言，函数式编程其实是一个非常古老的概念。它是由Alonzo Church和 Stephen Cole Kleene在20世纪30年代引入的一套研究函数定义、函数应用和递归的形式系统。</p>
<p>如Alonzo所说，像booleans、integers或其他的数据结构都可以被函数取代掉。</p>
<p>它的理念来自于数学中的代数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = 5x^2+4x+3</span><br><span class="line">g(x) = 2f(x)+5 = 10x^2+8x+11</span><br><span class="line">h(x) = f(x) + g(x) = 15x^2+12x+14</span><br></pre></td></tr></table></figure>
<p>假设f(x)是一个函数，g(x)是第二个函数，把f(x)这个函数套下来，并展开。</p>
<p>对于函数式编程来说，它只关心定<strong>义输入数据和输出数据相关的关心，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，使用函数来定义的。</strong></p>
<p>函数式编程有以下特点。</p>
<p><strong>特征</strong></p>
<ul>
<li><strong>stateless</strong>：函数不维护任何状态。函数式编程的核心精神是stateless，简而言之就是它不能存在状态，打个比方，，你给我数据我处理完扔出来，里面的数据是不变的。</li>
<li><strong>immutable</strong>：输入数据是不能动的，动了输入数据就与危险，所以要返回新的数据集。</li>
</ul>
<p><strong>优势</strong></p>
<ul>
<li>没有状态就灭有伤害</li>
<li>并行执行无伤害</li>
<li>Copy-Paste重构代码无伤害</li>
<li>函数的执行没有顺序上的问题</li>
</ul>
<p>函数式编程还带来了以下一些好处。</p>
<ul>
<li><strong>惰性求值</strong>。这需要编译器的支持。表达式不在它被绑定到变量之后就立即求职，而是在该值被取用的时候求值</li>
<li><strong>确定性</strong>。所谓确定性，就是像在数学中那样，f(x) = y 这个函数无论在什么场景下，都会得到同样的结果，而不是像程序中的很多函数那样，同一个参数，在不同的场景下会计算出不同的结果，这个我们称之为函数的确定性。</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>数据复制比较严重</li>
</ul>
<h3 id="函数式编程用到的技术"><a href="#函数式编程用到的技术" class="headerlink" title="函数式编程用到的技术"></a>函数式编程用到的技术</h3><ul>
<li><strong>first class function（头等函数）</strong>：这个技术可以让你的函数就像变量一样来使用。也就是说，函数可以像变量一样被创建、修改，并当成变量一样传递、返回，或是在函数中嵌套函数。</li>
<li><strong>tail recursion optimization（尾递归优化）：</strong>每次递归时都会重用stack，这样能够提升性能。当然，这需要语言或编译器的支持。</li>
<li><strong>map &amp; reduce：</strong>函数式编程最常见的技术就是对一个集合做Map和Reduce操作。</li>
<li><strong>pipeline（管道）</strong>：将函数实例成一个一个的action，然后将一组action放到一个数组或是列表中，再把数据传给这个action list，数据就像一个pipeline一样顺序地被各个函数所操作，最终得到我们想要的结果。</li>
<li><strong>recursing（递归）</strong>：递归最大额好处就是简化代码。注意：递归的精髓是描述问题，而这正式函数式编程的精髓。</li>
<li><strong>currying（柯里化）：</strong>将一个函数的多个参数分解成多个函数，然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数。</li>
<li><strong>higer order function（高阶函数）</strong>：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。</li>
</ul>
<p>下面以代码做讲解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非函数式，不是 pure funciton，有状态</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个全局变量，调这个全局函数变量++，这里面是有状态的，这个状态在外部。所以，如果是多线程的话，这里面的代码是不安全的。</p>
<p>写成纯函数式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式，pure function， 无状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cnt+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码可以随便拷，而且与线程无关，代码在并行时不用锁，因为是复制了原有的数据，并返回了新的数据。</p>
<p>再看另一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incx</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    <span class="keyword">return</span> incx</span><br><span class="line"> </span><br><span class="line">inc2 = inc(<span class="number">2</span>)</span><br><span class="line">inc5 = inc(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> inc2(<span class="number">5</span>) <span class="comment"># 输出 7</span></span><br><span class="line"><span class="keyword">print</span> inc5(<span class="number">5</span>) <span class="comment"># 输出 10</span></span><br></pre></td></tr></table></figure>
<p>上面这段Python代码，开始有点复杂了。可以看到上面的例子中 inc() 函数返回了另一个函数 incx() ，于是可以用 inc() 函数来构造各种版本的inc() 函数。这个技术其实就是上面所说的currying技术。从这个技术山，可以体会到函数式编程的理念。</p>
<ul>
<li><strong>把函数当成变量来用，关注描述问题而不是怎么实现，这样可以让代码更易读</strong></li>
<li><strong>因为函数返回里面的这个函数，所以函数关注的是表达式，关注的是描述这个问题，而不是怎么实现这个事情。</strong></li>
</ul>
<h3 id="函数式编程的思维方式"><a href="#函数式编程的思维方式" class="headerlink" title="函数式编程的思维方式"></a>函数式编程的思维方式</h3><p>函数式编程关注的是：describe what to do，rather than how to do it。于是，我们把以前的过程式编程范式叫作 Imperative Programming - 指令式编程，而把函数式编程范式叫作 Declarative Programming - 声明式编程。</p>
<p><strong>传统方式的写法</strong></p>
<p>下面我们看一下相关的示例。比如问题：有3辆车比赛，简单起见，分别给这3辆车70 %的概率让它们可以往前走一步，一共有5次机会，然后打出每一次这3辆车的前行状态。</p>
<p>对于 Imperative Programming来说，代码如下（Python）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_cars</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i, _ <span class="keyword">in</span> enumerate(car_positions):</span><br><span class="line">        <span class="keyword">if</span> random() &gt; <span class="number">0.3</span>:</span><br><span class="line">            car_positions[i] += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_car</span><span class="params">(car_position)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'-'</span> * car_position</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_step_of_race</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> time</span><br><span class="line">    time -= <span class="number">1</span></span><br><span class="line">    move_cars()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> car_position <span class="keyword">in</span> car_positions:</span><br><span class="line">        draw_car(car_position)</span><br><span class="line"> </span><br><span class="line">time = <span class="number">5</span></span><br><span class="line">car_positions = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> time:</span><br><span class="line">    run_step_of_race()</span><br><span class="line">    draw()</span><br></pre></td></tr></table></figure>
<p>上面的代码，从主循环开始，我们可以很清楚地看到程序的主干，因为我们把程序的逻辑分成了几个函数。这样一来，代码逻辑就会变成几个小碎片，于是我们读代码时要考虑的上下文就少了很多，阅读代码也会更容易。</p>
<p>但是，我们发现，封装成函数后，这些函数都会依赖于共享的变量来同步其状态。也就是说，这些函数必须直到其他函数是怎么修改它们之间的共享变量的，所以，这些函数是有状态的。</p>
<p><strong>函数式写法</strong></p>
<p>我们知道，有状态并不是一件很好的事情，无论是对代码重用，还是对代码的并行来说，都是有副作用的。为了把这些状态搞掉，于是出现了函数式编程的编程范式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_cars</span><span class="params">(car_positions)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> map(<span class="keyword">lambda</span> x: x + <span class="number">1</span> <span class="keyword">if</span> random() &gt; <span class="number">0.3</span> <span class="keyword">else</span> x,</span><br><span class="line">               car_positions)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">output_car</span><span class="params">(car_position)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'-'</span> * car_position</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_step_of_race</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'time'</span>: state[<span class="string">'time'</span>] - <span class="number">1</span>,</span><br><span class="line">            <span class="string">'car_positions'</span>: move_cars(state[<span class="string">'car_positions'</span>])&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n'</span>.join(map(output_car, state[<span class="string">'car_positions'</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">race</span><span class="params">(state)</span>:</span></span><br><span class="line">    draw(state)</span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">'time'</span>]:</span><br><span class="line">        race(run_step_of_race(state))</span><br><span class="line"> </span><br><span class="line">race(&#123;<span class="string">'time'</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="string">'car_positions'</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码依然把程序的逻辑分成了函数。不过这些函数都是函数式，它们有三个特点：1）它们之间没有共享的变量；2）函数间通过参数和返回值来传递数据；3）在函数里没有临时变量。</p>
<p>我们还可以看到，for循环被递归取代了——递归是函数式编程中常用到的技术，正如前面所说的，递归的本质是描述问题是什么。</p>
<h3 id="函数式语言的三套件"><a href="#函数式语言的三套件" class="headerlink" title="函数式语言的三套件"></a>函数式语言的三套件</h3><p>函数式语言有三套件，<strong>Map、Reduce 和 Filter。</strong></p>
<p><strong>Map示例</strong>：</p>
<p>对于需求：把一个字符串数组中的字符串都转成小写。</p>
<p>用常规的面向过程的方式，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统的非函数式</span></span><br><span class="line">upname =[<span class="string">'HAO'</span>, <span class="string">'CHEN'</span>, <span class="string">'COOLSHELL'</span>]</span><br><span class="line">lowname =[] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(upname)):</span><br><span class="line">    lowname.append( upname[i].lower() )</span><br></pre></td></tr></table></figure>
<p>写成函数式，用map() 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toUpper</span><span class="params">(item)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> item.upper()</span><br><span class="line"> </span><br><span class="line">upper_name = map(toUpper, [<span class="string">"hao"</span>, <span class="string">"chen"</span>, <span class="string">"coolshell"</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> upper_name</span><br><span class="line"><span class="comment"># 输出 ['HAO', 'CHEN', 'COOLSHELL']</span></span><br></pre></td></tr></table></figure>
<p>在函数式版本中，我们定义了一个函数 toUpper，这个函数没有改变传进来的值，只是把传进来的值做个简单的操作，然后返回。（？？？）然后，把它用在map函数中，就尅很清楚地描述出我们想要干什么，而不是去理解一个在循环中怎么实现的代码，最终在读了很多循环的逻辑才发现是什么意思。</p>
<p><strong>Reduce 和 Filter示例</strong></p>
<p>需求：计算数组平均值</p>
<p>非函数式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算数组中正数的平均值</span></span><br><span class="line">num =  [<span class="number">2</span>, <span class="number">-5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">-2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-3</span>, <span class="number">8</span>]</span><br><span class="line">positive_num_cnt = <span class="number">0</span></span><br><span class="line">positive_num_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</span><br><span class="line">    <span class="keyword">if</span> num[i] &gt; <span class="number">0</span>:</span><br><span class="line">        positive_num_cnt += <span class="number">1</span></span><br><span class="line">        positive_num_sum += num[i]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> positive_num_cnt &gt; <span class="number">0</span>:</span><br><span class="line">    average = positive_num_sum / positive_num_cnt</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> average</span><br></pre></td></tr></table></figure>
<p>函数式下使用 filter/reduce 函数的玩法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算数组中正数的平均值</span></span><br><span class="line">positive_num = filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span>, num)</span><br><span class="line">average = reduce(<span class="keyword">lambda</span> x,y: x+y, positive_num) / len( positive_num )</span><br></pre></td></tr></table></figure>
<p>首先，使用filter函数把整数过滤出来，保存在一个新的数组中——positive_num。然后，使用reduce函数对数组positive_num求和后，再除以其个数，就得到正数的平均值了。</p>
<p>可以看到， <strong>隐藏了数组遍历并过滤数组控制流程的 filter和reduce，不仅让代码更为简洁，因为代码里只有业务逻辑了，而且让我们更容易地理解代码。</strong>。</p>
<p>感觉代码更亲切了，因为：</p>
<ul>
<li>数据集、对数据的操作和返回值都放在了一起。</li>
<li>没有了循环体，皆可以少了些临时用来控制程序执行逻辑的变量，也少了把数据倒来倒去的控制逻辑。</li>
<li><strong>代码变成了在描述你要干什么，而不是怎么干。</strong></li>
</ul>
<p>对于函数式编程的思路，下图是一个比较形象的例子，面包和蔬菜 map 到切碎的操作上，在把结果给 reduce 成汉堡。</p>
<p>在这个图中，<strong>我们可以看到 map 和 reduce 不关心源输入数据，它们只是控制，并不是业务。控制是描述怎么干，而业务是描述要干什么。</strong></p>
<h3 id="函数式的-pipeline-模式"><a href="#函数式的-pipeline-模式" class="headerlink" title="函数式的 pipeline 模式"></a>函数式的 pipeline 模式</h3><p>pipeline（管道）借鉴于 Unix Shell 的管道操作——把若干个命令串起来，前面的命令的输出称为后面命令的输入，如此完成一个流式计算。</p>
<p>接下来，用一个简单的示例来看一下如何实现 pipeline。</p>
<p>程序的 process() 有三个步骤：</p>
<p>1.找出偶数；2.乘以3;  3.转成字符串返回。</p>
<p>传统的非函数式的实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="comment"># filter out non-evens</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    num = num * <span class="number">3</span></span><br><span class="line">    num = <span class="string">'The Number: %s'</span> % num</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"> </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">print</span> process(num)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># The Number: 6</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># The Number: 12</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># The Number: 18</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># The Number: 24</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># The Number: 30</span></span><br></pre></td></tr></table></figure>
<p>pipeline版本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">even_filter</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> num</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_by_three</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">yield</span> num * <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_string</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'The Number: %s'</span> % num</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">pipeline = convert_to_string(multiply_by_three(even_filter(nums)))</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> pipeline:</span><br><span class="line">    <span class="keyword">print</span> num</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># The Number: 6</span></span><br><span class="line"><span class="comment"># The Number: 12</span></span><br><span class="line"><span class="comment"># The Number: 18</span></span><br><span class="line"><span class="comment"># The Number: 24</span></span><br><span class="line"><span class="comment"># The Number: 30</span></span><br></pre></td></tr></table></figure>
<p>上面，我们动用了 Python 的关键字 yield，它是一个类似 return 的关键字，只是这个函数返回的是 Generator（生成器）。所谓生成器，指的是 yield 返回的是一个可迭代的对象，并没有真正的执行函数。也就是说，只有其返回的迭代对象被迭代时，yield函数才会真正运行。运行到 yield 语句时就会挺住，然后等下一次迭代。这就是 lazy evluation （懒惰加载）。</p>
<p>使用 Map &amp; Reduce 版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">even_filter</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> filter(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">0</span>, nums)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_by_three</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> map(<span class="keyword">lambda</span> x: x*<span class="number">3</span>, nums)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_string</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> map(<span class="keyword">lambda</span> x: <span class="string">'The Number: %s'</span> % x,  nums)</span><br><span class="line"> </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">pipeline = convert_to_string(</span><br><span class="line">               multiply_by_three(</span><br><span class="line">                   even_filter(nums)</span><br><span class="line">               )</span><br><span class="line">            )</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> pipeline:</span><br><span class="line">    <span class="keyword">print</span> num</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<p>函数式编程是个非常古老的概念，它的核心思想是键运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做，因而被称为声明式编程。以 Stateless（无状态）和 lmmutable（不可变）为主要特点，代码简洁，抑郁理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性——无论在什么场景下都会得到同样的结果。</p>
<hr>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p><strong>面向对象的编程有三大特性：封装、继承和多态。</strong></p>
<p>面向对象编程是一种具有对象概念的程序编程发型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性、灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。</p>
<p>面向对象程序设计可以看作一种在程序中包含各种队里而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者是直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其他对象，因此它们都可以被看作一个小型的“机器”，即对象。</p>
<p>鉴于对面向对象比较熟悉，这里不再详述。</p>
<p><strong>小结</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>能和真实的世界交相辉映，符合人的直觉</li>
<li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计</li>
<li>强调于“名词”而不是“动词”，更多地关注对象和对象间的接口</li>
<li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增加了可重用性和可扩展性。</li>
<li>拥有大量非常优秀的设计原则和设计模式</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>代码都需要附着在一个类上，从另一个角度来说，其鼓励了类型。</li>
<li>代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。</li>
<li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现了很多问题。</li>
</ul>
<hr>
<h2 id="基于原型的编程范式"><a href="#基于原型的编程范式" class="headerlink" title="基于原型的编程范式"></a>基于原型的编程范式</h2><p>基于原型（prototype）的编程其实也是面向对象编程的一种方式。没有class化，直接使用对象。又叫，基于实例的编程。其主流的语言是 JavaScript。</p>
<p>与传统的面向对象编程的比较如下：</p>
<ul>
<li>在基于类的编程中，对象总共有两种类型。类定义了对象基本布局和函数特性，而接口是可以使用的对象，它基于特定类的样式。在此模型中，类表现行为和结构的集合，对所有接口来说这些类的行为和结构都是相同的。</li>
<li>原型编程提倡程序员关注一系列对象实例的行为，而之后才关心如何将这些对象划分到最近的使用方式相似的原型对象，而不是分类。</li>
<li>在基于原型的系统中构造对象有两种方法，通过复制已有的对象或者通过扩展对象创建。</li>
</ul>
<h3 id="JavaScipt的原型概念"><a href="#JavaScipt的原型概念" class="headerlink" title="JavaScipt的原型概念"></a>JavaScipt的原型概念</h3><p>先看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">name</span>: <span class="string">"foo"</span>, <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;<span class="attr">three</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>每个对象都有一个 _ <em>proto</em> <em>的属性，这个就是“原型”。对于上面的两个对象，如果我们把foo赋值给bar.__proto</em> _,那就意味着，bar的原型就成了foo的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.__proto__ = foo; <span class="comment">// foo is now the prototype of bar.</span></span><br></pre></td></tr></table></figure>
<p>于是，我们就可以在 bar 里面访问 foo 的属性了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we try to access foo's properties from bar </span></span><br><span class="line"><span class="comment">// from now on, we'll succeed. </span></span><br><span class="line">bar.one <span class="comment">// Resolves to 1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The child object's properties are also accessible.</span></span><br><span class="line">bar.three <span class="comment">// Resolves to 3.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Own properties shadow prototype properties</span></span><br><span class="line">bar.name = <span class="string">"bar"</span>;</span><br><span class="line">foo.name; <span class="comment">// unaffected, resolves to "foo"</span></span><br><span class="line">bar.name; <span class="comment">// Resolves to "bar"</span></span><br></pre></td></tr></table></figure>
<p>再来看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一种构造函数写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改 Foo 的 prototype，加入一个成员变量 x</span></span><br><span class="line">Foo.prototype.x = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改 Foo 的 prototype，加入一个成员函数 calculate</span></span><br><span class="line">Foo.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y + z;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 现在，我们用 Foo 这个原型来创建 b 和 c</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Foo(<span class="number">30</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用原型中的方法，可以得到正确的值</span></span><br><span class="line">b.calculate(<span class="number">30</span>); <span class="comment">// 60</span></span><br><span class="line">c.calculate(<span class="number">40</span>); <span class="comment">// 80</span></span><br></pre></td></tr></table></figure>
<p>那么，在内存中的布局大概是下面这个样子。</p>
<p><img src="/home/utur/图片/picture_for_note/编程范式/javascript.png" alt="javascript"></p>
<p>上述就是基于原型的面向对象编程的玩法了。</p>
<p><strong>小结</strong></p>
<p>可以看到，这种玩法就是一种委托的方式。在使用委托的基于原型的语言中，运行时语言可以“仅仅通过序列的指针找到匹配”这样的方式来定位属性或者寻找正确的数据。所有的这些创建行为共享的行为需要的是委托指针。</p>
<p>不像是基于类的面向对象语言中类和接口的关系，原型和它的分支之间的关系并不要求对象有相似的内存结构，因为如此，子对象可以继续修改而无需像基于类的系统那样整理结构。</p>
<p>这种在对象里直接修改的玩法，虽然这个特性可以带来运行时的灵活性，我们可以在运行时修改一个 prototype，给它增加甚至删除属性和方法。但是其带来了执行的不确定性，也有安全性的问题，而代码还变得不可预测，这就有点黑科技的味道了。因为这些不想静态类型系统，没有一个不可变的契约对代码的确定性有保证，所以，需要使用者来自己保证。</p>
<hr>
<h2 id="编程本质"><a href="#编程本质" class="headerlink" title="编程本质"></a>编程本质</h2><h3 id="编程的本质"><a href="#编程的本质" class="headerlink" title="编程的本质"></a>编程的本质</h3><p><strong>两篇论文</strong></p>
<p>1976年，瑞士计算机科学家，Algol W，Wodula，Oberaon和Pascal语言的设计师NiklausEmil Wirth写了一本非常经典的书《<a href="http://www.ethoberon.ethz.ch/WirthPubl/AD.pdf" target="_blank" rel="noopener">Algorithms + Data Structures = Programs</a>》，即算法 + 数据结构 = 程序。</p>
<p>1979年，英国逻辑学家和计算机学家Robert Kowalski发表论文 <a href="https://www.doc.ic.ac.uk/~rak/papers/algorithm%20=%20logic%20+%20control.pdf" target="_blank" rel="noopener">Alogrithm = Logic + Control</a>，并且主要开发“逻辑编程”相关的工作。</p>
<p>Robert Kowalski在这篇论文里提到：</p>
<blockquote>
<p>An algorithm can be egarded as consisting of a logic componnent . which specifies the knowledge to be used in solving problems, and a control component, which determines the problem-solving strategies by means of which that knowledge is used. The logic component determines the meaning of the algorithm whereas the control component only affects its efficiency. The efficiency of an algorithm can often be imporved by improving the control component without changing the logic of the algorithm. We argue that computer programs would be more often correct and more easily improved and modified if their logic and control aspects were identified and separated in the program text.</p>
</blockquote>
<p>翻译过来的意思大概就是：</p>
<blockquote>
<p>任何算法都会有两个部分，一个是Logic部分，这是用来解决实际问题的。另一个是Control部分，这是用来决定用什么策略来解决问题。Logic部分是真正意义上的解决问题的算法，而Control部分只是影响解决这个问题的效率。程序运行的效率问题和程序的逻辑其实是没有关系的。我们认为，如果将Logic和Control部分有效地分开，那么代码就会变得更容易改进和维护。</p>
</blockquote>
<p>注意，最后一句话是重点——<strong>如果将Logic和Control部分有效地分开，那么代码就会变得更容易改进和维护。</strong></p>
<p><strong>编程的本质</strong></p>
<p>两位老先生的两个表达式：</p>
<ul>
<li>Programs = Algorithms + Data Structures</li>
<li>Algorithm = Logic + Control</li>
</ul>
<p>第一个表达式倾向于数据结构和算法，它是想把这两个拆分，早起都在走这条路。它们认为，如果数据结构设计的好，算法也会变得简单，而且一个好的通用算法应该可以用在不同的数据结构上。</p>
<p>第二个表达式则想表达的是数据结构不复杂，复杂的是算法，也就是我们的业务逻辑是复杂的。我们的算法由两个逻辑组成，一个是真正的业务逻辑，另外一种是控制逻辑。程序中有两种代码，一种是真正的业务逻辑代码，另一种是控制我们程序的代码，叫控制代码，这根本不是业务逻辑，业务逻辑不关心这个事情。</p>
<p>算法的效率往往可以通过提高控制部分的效率来实现，而无需改变逻辑部分，也就无需改变算法的意义。举个阶乘的例子：X(n)! = X(n) <em> X(n-1) </em> X(n-2) <em>… </em> 2 <em> 1。逻辑部分用来定义阶乘： 1) 1是0的阶乘；2) 如果v是x的阶乘，且u=v</em>(x+1)，那么u是x+1的阶乘。</p>
<p>用这个定义，既可以从上往下将x+1的阶乘缩小为先计算x的阶乘，再将结果乘以x+1（recursive，递归），也可以由下而上逐个计算一系列阶乘的结果（iteration，遍历）。</p>
<p>How控制部分用来描述如何使用逻辑。最粗略的看法可疑人物“控制”是解决问题额策略，而不会改变算法的意义，因为算法的意义是由逻辑决定的。对用一个逻辑，使用不同控制，所得到的算法，本质是等价的，因为它们解决同样的问题，并得到同样的结果。</p>
<p>因此，我们可以用过逻辑分析，来提高算法的效率，保持它的逻辑，而更好地使用这一逻辑。比如，有时用自上而下的控制代替自下而上，，能提高效率。而将自上而下的顺序执行改为并行执行，也会提高效率。</p>
<p>总之，通过这两个表达式，我们可以得出：</p>
<p><strong>Program = Logic + Control + Data Structure</strong></p>
<p>前面讲了这么多的编程范式，其实，都是在围绕着这三件事来做。比如：</p>
<ul>
<li>就像函数编程中的Map/Reduce/Filter，它们都是一种控制。而传给这些控制模块的那个Lambda表达式才是我们要解决问题的逻辑，它们共同组成了一个算法、最后，再把数据放在数据结构了进行处理，最终就成为了我们的程序。</li>
<li>就像面向对象中依赖于接口而不是实现一样，接口是对逻辑的抽象，真正的逻辑放在不同的具体类中，通过多态或是依赖注入这样的控制来完成对数据在不同情况下的不同处理。</li>
</ul>
<p>仔细地结合之前的各式各样的编程范式来思考上述这些概念，我们会发现，所有的语言或编程范式都在解决上面的这些问题。也就下面的这几个事。</p>
<ul>
<li>Control是可以标准化的。比如：遍历数据、查找数据、多线程、并发、异步等，都是可以标准化的。</li>
<li>因为Control需要处理数据，所以标准化Control，需要标准化Data Structure，我们可以通过泛型编程来解决这个事</li>
<li>而Control还要处理用户的业务逻辑，即Logic。所以，我们可以通过标准化接口/协议来实现，我们的Control模式可以适配与任何的Logic。</li>
</ul>
<p>上述三点，就是编程范式的本质。</p>
<ul>
<li><strong>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！</strong></li>
<li><strong>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！</strong></li>
<li><strong>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！</strong></li>
</ul>
<p>控制一个程序流转的方式，即程序执行的方式，并行还是串行，同步还是异步，以及调度不同执行路径或模块，数据之间的存储关系，这些和业务逻辑没有关系。</p>
<p><img src="/home/utur/图片/picture_for_note/编程范式/alogrithm=logic+control.png" alt="alogrithm"></p>
<p>那些混乱不堪的代码，你会发现其中最大的问题是我们把Logic和Control纠缠在一起了，所以导致代码很混乱，难以维护，Bug很多。绝大多数程序复杂的原因就是这个问题。</p>
<p><strong>小结：</strong></p>
<p>代码复杂度的原因：</p>
<ul>
<li>业务逻辑的复杂度据定了代码的复杂度；</li>
<li>控制逻辑的复杂度 + 业务逻辑的复杂度 ==&gt; 程序代码的混乱不堪；</li>
<li>绝大多数程序复杂混乱的根本原因：<strong>业务逻辑与控制逻辑的耦合</strong>。</li>
</ul>
<p>如何分离 control 和 logic呢》使用下面的这些技术来解耦：</p>
<ul>
<li><p><strong>State Machine</strong></p>
<ul>
<li>状态定义</li>
<li>状态变迁条件</li>
<li>状态的action</li>
</ul>
</li>
<li><p><strong>DSL -  Domain Specific Language</strong></p>
<ul>
<li>HTML，SQL，Unix shell Script，AWK，正则表达式</li>
</ul>
</li>
<li><strong>编程范式</strong><ul>
<li>面向对象：委托、策略、桥接、修饰、Ioc/DIP、MVC</li>
<li>函数式编程：修饰、管道、拼接</li>
<li>逻辑推导式编程：Prolog</li>
</ul>
</li>
</ul>
<p><strong>这就是编程的本质：</strong></p>
<ul>
<li><strong>Logic 部分才是真正有意义的（What）</strong></li>
<li><strong>Control 部分只是影响Logic部分的效率（How）</strong></li>
</ul>
<hr>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/django_web_开发错误整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/django_web_开发错误整理/" class="post-title-link" itemprop="url">django开发问题整理</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:12:50" itemprop="dateModified" datetime="2019-07-06T17:12:50+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/django/" itemprop="url" rel="index"><span itemprop="name">django</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在使用Django2-0进行Web开发过程中遇到的问题"><a href="#在使用Django2-0进行Web开发过程中遇到的问题" class="headerlink" title="在使用Django2.0进行Web开发过程中遇到的问题"></a>在使用Django2.0进行Web开发过程中遇到的问题</h1><h3 id="Django在根据models生成数据库表时报-init-missing-1-required-positional-argument-‘on-delete’"><a href="#Django在根据models生成数据库表时报-init-missing-1-required-positional-argument-‘on-delete’" class="headerlink" title="Django在根据models生成数据库表时报 _ init _()missing 1 required positional argument: ‘on_delete’"></a>Django在根据models生成数据库表时报 _ <em>init</em> _()missing 1 required positional argument: ‘on_delete’</h3><ul>
<li><p><strong>原因</strong></p>
<p>在django2.0后，定义外键和一对一关系的时候需要加on_delete选项，此参数为了避免两个表里的数据不一致问题，不然会报错：<br>TypeError: _ init _() missing 1 required positional argument: ‘on_delete’</p>
</li>
<li><p><strong>解决方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码报错</span></span><br><span class="line">user = models.OneToOneField(User)</span><br><span class="line">owner = models.ForeignKey(UserProfile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下代码正确</span></span><br><span class="line">user = models.OneToOneField(User, on_delete=models.CASCADE)</span><br><span class="line">owner = models.ForergnKey(UserProfile, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数说明</p>
<p>on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值。<br>CASCADE：此值设置，是级联删除。<br>PROTECT：此值设置，是会报完整性错误。<br>SET_NULL：此值设置，会把外键设置为null，前提是允许为null。<br>SET_DEFAULT：此值设置，会把设置为外键的默认值。<br>SET()：此值设置，会调用外面的值，可以是一个函数。<br><strong>一般情况下使用CASCADE就可以了。</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Django2-0配置Mysql数据库后执行数据迁移时报错："><a href="#Django2-0配置Mysql数据库后执行数据迁移时报错：" class="headerlink" title="Django2.0配置Mysql数据库后执行数据迁移时报错："></a>Django2.0配置Mysql数据库后执行数据迁移时报错：</h3><ul>
<li><p><strong>报错</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原因</strong></p>
<p>MySQLclient目前只支持到python3.4</p>
</li>
<li><p><strong>解决方法</strong></p>
<p>因为要使用<strong>python3.6</strong>，所以修改下面路径的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /home/utur/.<span class="built_in">local</span>/lib/python3.6/site-packages/django/db/backends/mysql</span></span><br></pre></td></tr></table></figure>
<p>将以下代码注释即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> version &lt; (<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>):</span><br><span class="line">	<span class="keyword">raise</span> ImproperlyConfigured(<span class="string">"mysqlclient 1.3.3 or newer is required; you have %s"</span> % Database.__version__)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="MySQL-django-db-utils-OperationalError-1698-“Access-denied-for-user-‘roo‘-’localhost’”-with-correct-username-and-pw"><a href="#MySQL-django-db-utils-OperationalError-1698-“Access-denied-for-user-‘roo‘-’localhost’”-with-correct-username-and-pw" class="headerlink" title="MySQL: django.db.utils.OperationalError:( 1698, “Access denied for user ‘roo‘@’localhost’”) with correct username and pw"></a>MySQL: django.db.utils.OperationalError:( 1698, “Access denied for user ‘roo‘@’localhost’”) with correct username and pw</h3><ul>
<li><p>详情见：<a href="https://stackoverflow.com/questions/41542045/mysql-django-db-utils-operationalerror-1698-access-denied-for-user-root" target="_blank" rel="noopener">https://stackoverflow.com/questions/41542045/mysql-django-db-utils-operationalerror-1698-access-denied-for-user-root</a></p>
</li>
<li><p><strong>解决方法</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user &apos;django&apos;@&apos;localhost&apos; identified by &apos;django-user-password&apos;;</span><br><span class="line">grant usage on *.* to &apos;django&apos;@&apos;localhost&apos;;</span><br><span class="line">grant all privileges on django-database-1.* to &apos;django&apos;@&apos;localhost&apos;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="AttributeError-‘str’-object-has-no-attribute-‘decode’"><a href="#AttributeError-‘str’-object-has-no-attribute-‘decode’" class="headerlink" title="AttributeError: ‘str’ object has no attribute ‘decode’"></a>AttributeError: ‘str’ object has no attribute ‘decode’</h3><ul>
<li><p><strong>报错</strong></p>
<p>执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py makemigrations</span><br></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/Django-2.2-py3.7.egg/django/db/backends/mysql/operations.py", line 146, in last_executed_query</span><br><span class="line">    query = query.decode(errors='replace')</span><br><span class="line">AttributeError: 'str' object has no attribute 'decode'</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原因</strong></p>
<p>python在bytes和str两种类型转换，所需要的函数依次是encode(),decode()</p>
</li>
<li><p><strong>解决方法</strong></p>
<p>在报错路径下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim operations.py</span><br></pre></td></tr></table></figure>
<p>找到错误代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query = query.decode(errors=<span class="string">'replace'</span>)</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query = query.encode(errors=<span class="string">'replace'</span>)</span><br><span class="line"><span class="comment"># 保存并退出</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="include-got-an-unexpected-keyword-argument-‘app-name’"><a href="#include-got-an-unexpected-keyword-argument-‘app-name’" class="headerlink" title="include() got an unexpected keyword argument ‘app_name’"></a>include() got an unexpected keyword argument ‘app_name’</h3><ul>
<li><p><strong>原因</strong></p>
<p><strong>在Django2.0版本使用url()导致，推荐使用path()</strong></p>
</li>
<li><p><strong>解决方法</strong></p>
<p>在xxx应用下的<strong>urls.py</strong>添加app_name变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url,include</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app_name = xxx</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">     <span class="comment"># 路由规则</span></span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/爬虫知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/爬虫知识点/" class="post-title-link" itemprop="url">爬虫基本知识</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:24:57" itemprop="dateModified" datetime="2019-07-06T17:24:57+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/爬虫/" itemprop="url" rel="index"><span itemprop="name">爬虫</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h3><ul>
<li><strong>URL</strong>:Uniform Resource Identifier,统一资源标志符</li>
<li><strong>URL</strong>:Universal Resource Locator,统一资源定位符</li>
</ul>
<h3 id="网页基础"><a href="#网页基础" class="headerlink" title="网页基础"></a>网页基础</h3><h4 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h4><p>网页可以分为三大部分——HTML、CSS和JavaScript。</p>
<ul>
<li><strong>HTML</strong>: HTML是用来描述网页的一种语言，全称叫作 Hyper Text Markup Language，即超文本标记语言。网页包括文字、按钮、图片和视频等各种复杂的元素，其基础=架构就是HTML。不同类型的文字通过不同类型的标签来表示。</li>
<li><strong>CSS</strong>：全称叫作Cascading Style Sheets，即层叠样式表。”层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。”样式”指网页中文字大小、颜色、元素间距、排列等格式。</li>
<li><strong>JavaScript</strong>：简称JS，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常是JavaScript的功劳。它的出现使得用户与信息之间不只是浏览与显示的关系，而是实现了一种实时、动态、交互的页面功能。</li>
</ul>
<h3 id="爬虫的基本原理"><a href="#爬虫的基本原理" class="headerlink" title="爬虫的基本原理"></a>爬虫的基本原理</h3><ol>
<li><p><strong>爬取网页</strong></p>
<p>爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息。</p>
</li>
<li><p><strong>提取信息</strong></p>
<p>获取网页源代码后，接下来就是分析网页源代码，从中提取想要的数据。</p>
</li>
<li><p><strong>保存数据</strong></p>
<p>提取信息后，一般会将提取到的数据和保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为TXT文本或JSON文本，也可以保存到数据库，如MySQL和MongoDB等。</p>
</li>
<li><p><strong>自动化程序</strong></p>
</li>
</ol>
<h3 id="会话和Cookies"><a href="#会话和Cookies" class="headerlink" title="会话和Cookies"></a>会话和Cookies</h3><ol>
<li><strong>无状态HTTP</strong>：HTTP的无状态是指HTTP协议对事务处理是没有一个记忆能力的，也就是说服务器不知道客户端是什么状态。当像服务器发送请求后，服务器解析词请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺乏状态记录。</li>
<li><strong>会话</strong>：在Web中，会话对象用来存储特定用户会话所需要的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在会话对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的Web页时，如果该用户还没有会话，则Web服务器讲自动创建一个会话对象。当会话过期或被放弃后，服务器讲终止该会话。</li>
<li><strong>Cookies</strong>：Cookies指某些网站为了辨别用户身份、进行会话跟踪而存储在 用户本地终端上的数据。<ul>
<li>Cookies字段：<ul>
<li>Name：Cookies的名称，一旦创建，名称便不可更改</li>
<li>Value： Cookies的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。</li>
<li>Domain：可以访问该Cookies的域名</li>
<li>Max Age：Cookies失效的时间，单位为秒，常和Expires一起使用，通过它可以计算出其有效时间</li>
<li>Path：Cookies的使用路径</li>
<li>Size：Cookies的大小</li>
<li>HTTP：Cookies的httponly属性。若此属性为true，则只有在HTTP头中会带有此Cookie的信息，而不能通过document.cookie来访问Cookie。</li>
<li>Secure：该Cookie是否被使用安全协议传输。安全协议有HTTPS和SSL等、、</li>
</ul>
</li>
<li>会话Cookie和持久Cookie<ul>
<li>会话Cookie：就是把Cookie放在浏览器内存里，浏览器在关闭之后该Cookie即失效</li>
<li>持久Cookie：Cookie会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。本质是Cookie的Max Age活Expires字段决定了过期的时间。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Cookies和会话需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录会话控制。</p>
<h3 id="代理的基本原理"><a href="#代理的基本原理" class="headerlink" title="代理的基本原理"></a>代理的基本原理</h3><ol>
<li><p><strong>基本原理</strong></p>
<p>实际上就是在本机和服务器之间搭建了一个桥，此时本机不是直接像Web服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，成功实现了IP伪装，这就是代理的基本原理。</p>
</li>
<li><p><strong>代理的作用</strong></p>
<ul>
<li>突破自身IP访问限制，访问一些平时不能访问的站点</li>
<li>访问一些单位或内部资源</li>
<li>2,提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲去，当有外界的信息通过时，同时也将其保存到缓冲区，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>
<li>隐藏真实IP：上网者可以通过这种方法隐藏自己的IP，免受攻击。对应爬虫来说，我们代理就是为了隐藏自身的IP，防止自身的IP被封锁。</li>
</ul>
</li>
</ol>
<h3 id="Ajax数据爬取"><a href="#Ajax数据爬取" class="headerlink" title="Ajax数据爬取"></a>Ajax数据爬取</h3><p>Ajax，全称为Asynchronous JavaScript and XML，即异步的JavaScript和XML。它不是一门编程语言，而是利用JavaScript在保证页面不被刷新、页面链接不改变的情况下与服务器变换数据并更新部分网页的技术。</p>
<ol>
<li><p><strong>基本原理</strong></p>
<ul>
<li><p>发送请求</p>
<p>实际上就是新建了XMLHttp&amp;Request对象，然后调用onreadystatechange属性设置了监听，然后调用open()和send()方法向某个链接（也就是服务器）发送了请求。</p>
</li>
<li><p>解析内容</p>
<p>得到响应之后，onreadystatechange属性对应的方法便会被触发，此时利用xmlhttp的responseText属性便可取到响应内容。</p>
</li>
<li><p>渲染网页</p>
<p>JavaScript有改变网页内容的能力，解析完响应内容之后，就可以调用JavaScript来针对解析玩的内容对网页进行下一步处理。</p>
</li>
</ul>
</li>
</ol>
<h3 id="验证码的识别"><a href="#验证码的识别" class="headerlink" title="验证码的识别"></a>验证码的识别</h3><ul>
<li><p>图形验证码（利用tesserocr库）</p>
</li>
<li><p>极验滑动验证码</p>
<ol>
<li>模拟点击验证按钮</li>
<li>识别滑动缺口的位置</li>
<li>模拟拖动滑块</li>
</ol>
</li>
<li><p>点触验证码（12306）</p>
<p>利用验证码服务平台辅助验证</p>
</li>
<li><p>微博宫格验证码</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Apache_Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Apache_Kafka/" class="post-title-link" itemprop="url">消息队列Kafka学习笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 16:50:18" itemprop="dateModified" datetime="2019-07-06T16:50:18+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p>Kafka是一款由美国领英公司（LinkedIn）开源出来的<strong>高性能消息引擎系统（Messaging system）</strong>,其核心功能是——<em>高性能的消息发送与高性能的消息消费</em>。但随着Kafka的不断演进，在Kafka 0.10.0.0版本正式推出了Kafka Streams，即流式处理组件。自此Kafka正式成为了一个流式处理框架。</p>
<hr>
<h2 id="前置知识背景"><a href="#前置知识背景" class="headerlink" title="前置知识背景"></a>前置知识背景</h2><h3 id="消息引擎系统"><a href="#消息引擎系统" class="headerlink" title="消息引擎系统"></a>消息引擎系统</h3><p>消息引擎，又叫消息队列，消息中间件等。</p>
<p>根据维基百科的定义，企业消息引擎系统（EMS）是企业发布的一组规范。公司使用这组规范实现在不同系统之间传递语义准确的消息。在实际使用场景中，消息引擎系统通常以软件接口为主要形式，实现了松耦合的异步式数据传递语义。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/消息引擎架构.png" alt="消息引擎"></p>
<hr>
<h3 id="消息引擎范型"><a href="#消息引擎范型" class="headerlink" title="消息引擎范型"></a>消息引擎范型</h3><p>根据维基百科定义，一个消息引擎范型是一个基于网络的架构范型，描述了消息引擎系统的两个不同的子部分是如何互连且交互的。如果把消息引擎系统的这两个子系统比喻成两座城市，那么传输协议就是需要铺设的沥青公路，而引擎范型决定了来往穿梭与这两座城市的路线。</p>
<p>最常见的两种消息引擎范型是<strong><em>消息队列模型</em></strong>和<strong><em>发布/订阅模型</em></strong>。</p>
<ul>
<li><p>消息队列（message queue）模型是基于队列提供消息传输服务的，多用于进程间通信以及线程间通信。该模型定义了消息队列、发送者和接收者，提供了一种点对点的消息传递方式，即发送者发送每条消息到队列的指定位置，接收者从指定位置获取消息。每条消息由一个发送者生产出来，且只被一个消费者处理。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/队列消息引擎模型.png" alt="消息队列模型"></p>
</li>
<li><p>发布/订阅模型(publish/subscribe),它有主题（topic）的概念：一个topic可以理解为逻辑语义相近的消息的容器。这种模型定义了类似于生产者/消费者这样的角色，即发布者和订阅者。发布者将消息生产出来发送到指定的topic中，所有订阅了该topic的订阅者都可以接收到该topic下的所有消息。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/发布订阅消息模型.png" alt="发布订阅"></p>
</li>
</ul>
<hr>
<h2 id="Kafka术语"><a href="#Kafka术语" class="headerlink" title="Kafka术语"></a>Kafka术语</h2><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>既然Kafka的核心功能就是消息引擎，那么对消息的设计日然是首当其冲的事情。Kafka在消息设计时特意避开了繁重的Java堆上内存分配，直接使用紧凑二进制字节数组ByteBuffer而不是独立的对象，因此至少能够访问多一倍的可用内存。</p>
<p>省去padding，java对对象保存的大开销以及可能的页缓存。</p>
<h3 id="topic和partiiton"><a href="#topic和partiiton" class="headerlink" title="topic和partiiton"></a>topic和partiiton</h3><p>从概念上来说，topic只是一个逻辑概念，代表了一类消息，也可以认为是消息被发送到的地方。通常可以使用topic来区分实际业务，比如业务A使用一个topic，业务B使用另一个topic。</p>
<p>Kafka中的topic通常都会被多个消费者订阅，出于性能的考量，Kafka并不是topic-message的两级结构，而是采取了topic-partition-message的三级结构来分散负载。从本质上来说，每个Kafka topic都由若干个partition组成。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/topic和partition.png" alt="topic和partition"></p>
<p>topic是由多个partition组成的，而Kafka的partition是不可修改的有序消息队列，也可以说是有序的消息日志。每个partition都有自己专属的partition号。用户对partition唯一能做的操作就是在消息序列的尾部追加写入消息。<strong>partition上的每条消息都会被分配一个唯一的序列号-该序列号被称为位移（offset）。位移信息可以唯一定位到某partition下的一条消息</strong></p>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>实际上，Kafka消费者也有位移（offset）的概念，但这两个offset属于不同的概念。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/消费者位移.png" alt="消费者位移"></p>
<p>每条消息在某个partition的位移是固定的，但消费该partition的消费者的位移会随着消费进度不断前移，但不能超过该分区最新一条消息的位移。</p>
<p><strong>从本质上看，Kafka中的一条消息其实就是一个&lt;topic,partition,offset&gt;三元组（tuple），通过该元组，可以在Kafka集群中找到位移对应的那条消息。</strong></p>
<h3 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h3><p>为了实现高可靠性，通过冗余机制——备份多份日志。这些备份日志在Kafka中被称为副本（replica），它们存在的唯一目的就是防止数据丢失。</p>
<p><strong>副本分为两类：领导者副本（leader replica）和追随者副本（follower replica）</strong>。follower replica是不能提供服务给客户端的，它只是被动地向领导者副本（leader replica）获取数据，一旦leader replica所在的broker宕机，Kafka会从剩余的replica中选举出新的leader继续提供服务。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/leadr-follower.png" alt="leader-follower"></p>
<h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p><strong>ISR的全称是 in-sync replica，就是与leader replica保持同步的replica集合。</strong></p>
<p>Kafka为partition动态维护一个replica集合。该集合中的所有replica保存的消息日志都与leader replica保护同步状态。<em>只有这个集合中的replica才能被选举为leader，也只有该集合中所有replica都接收到了同一条消息，Kafka才会将该消息置于“已提交”状态，即认为这条消息发送成功</em>。<strong>Kafka承诺只要这个集合中至少存在一个replica，那些”已提交“状态的消息就不会丢失。</strong></p>
<hr>
<h2 id="Kafka使用场景"><a href="#Kafka使用场景" class="headerlink" title="Kafka使用场景"></a>Kafka使用场景</h2><ul>
<li>消息传输</li>
<li>网站行为日志追踪</li>
<li>审计数据收集</li>
<li>日志收集</li>
<li>Event Sourcing</li>
<li>流式处理</li>
</ul>
<hr>
<h2 id="Kafka设计原理"><a href="#Kafka设计原理" class="headerlink" title="Kafka设计原理"></a>Kafka设计原理</h2><h3 id="broker端设计架构"><a href="#broker端设计架构" class="headerlink" title="broker端设计架构"></a>broker端设计架构</h3><p>broker是Apache Kafka最重要的组件，本质上它是一个功能载体（或服务载体），承载了绝大多数的Kafka服务。事实上，大多数的消息队列框架都有broker或已知类似的角色。一个broker通常是以服务器的形式出现的。</p>
<h4 id="消息设计"><a href="#消息设计" class="headerlink" title="消息设计"></a>消息设计</h4><ol>
<li><p><strong>消息格式</strong></p>
<p>V2版本分为<strong>消息</strong>和<strong>消息集合</strong>两个维度，不过消息集合的提法被消息批次所取代。V2版本中，它有一个专门的属于：RecordBatch。</p>
<p>V2版本消息格式</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/V2版本消息格式.png" alt="消息格式"></p>
<p>“可变长度”表示Kafka会根据具体的值来确定到底需要几字节保存。为了在序列化时降低使用的字节数，V2版本借鉴了Google ProtoBuffer中的Zig-zag编码方式，使得绝对值较小的整数占用字节数较少的字节。</p>
</li>
<li><p><strong>消息batch</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/V2版本消息batch格式.png" alt="消息batch"></p>
<ul>
<li>CRC值从消息层面被移除，放入batch这一层</li>
<li>PID、producer epoch和序列号等消息都是0.11.0.0版本为了实现幂等性producer和支持事务而一如的。</li>
</ul>
<p>通过使用mirco-batch，批次地发送消息，能大幅度地提高Kafka的吞吐量。</p>
</li>
</ol>
<hr>
<h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h4><p>Kafka是分布式的消息引擎集群环境，支持自动化的服务发现与成员管理。依赖于Apache Zookeeper实现，每当一个broker启动，它会将自己注册到Zookeeper下的一个节点。</p>
<ul>
<li><p>首先，每个broker在Zookeper下注册节点的路径是chroot/brokers/ids/&lt;broker.id&gt;。如果没有配置chroot，则路径是/broker/ids/&lt;broker.id&gt;。</p>
</li>
<li><p>其次，broker向Zookeeper中的注册消息以JSON格式保存。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"loacalhost"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">9092</span>,</span><br><span class="line">    <span class="attr">"jmx_port"</span>: <span class="number">9999</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="number">1499737197</span>,</span><br><span class="line">    <span class="attr">"endpoints"</span>: [</span><br><span class="line">        <span class="string">"CLIENT"</span>://host1:<span class="number">9092</span><span class="string">",</span></span><br><span class="line"><span class="string">        "</span>REPLICATION://HOST1:<span class="number">9093</span><span class="string">"</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    "</span>listener_security_protocol_map<span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>CLIENT<span class="string">": "</span>SSL<span class="string">",</span></span><br><span class="line"><span class="string">        "</span>REPLICATION<span class="string">": "</span>PLAINTEXT<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "</span>rack<span class="string">": "</span>dc1<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，Zookeeper临时节点的生命周期和客户端会话绑定。如果客户端会话失效，该临时节点就会自动被清除掉。Kafka正是利用Zookeeper临时节点来管理broker生命周期的。broker启动时在Zookeeper中创建对应的临时节点，同时还会创建一个监听器（listener）监听该临时节点的状态；一旦broker启动后，监听器会自动同步整个集群消息到该broker上；而一旦broker崩溃，它与Zookeeper的会话就会失效，导致临时节点被删除，监听器被触发，然后处理broker崩溃的后续事宜。这就是Kafka管理集群及其成员的主要流程。</p>
</li>
</ul>
<hr>
<h4 id="副本与ISR设计"><a href="#副本与ISR设计" class="headerlink" title="副本与ISR设计"></a>副本与ISR设计</h4><p>一个Kafka分区本质上就是一个备份日志，即利用多份相同的备份共同提供冗余机制来保持系统高可用性。这些备份在Kafka中被称为副本（replica）。</p>
<ul>
<li><p><strong>follower副本同步</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/副本位置信息.png" alt="副本位置信息"></p>
<ol>
<li><p>起始位移（base offset）：表示该副本当前所含第一条消息的位移</p>
</li>
<li><p><strong>高水印值（high watermark，HW</strong>）：副本高水印值。它保存了该副本最新一条已提交消息的位移。leader分区的HW值决定了副本中已提交消息的范围，也确定了consumer能够获取消息的消息上限。任何一个副本对象的HW值一定不大于其LEO值。Kafka对leader副本和follower副本的HW值更新机制是不同的。</p>
</li>
<li><p><strong>日志末端位移（log end offset，LEO）</strong>：副本日志中下一条待写入消息的offset。所有副本都需要维护自己的LEO信息。只有ISR中的所有副本都更新了对应的LEO之后，leader副本才会向右移动HW值表明消息写入成功。Kafka对leader副本和follower副本的LEO值更新机制也是不同的。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/副本同步流程.png" alt="副本同步流程"></p>
</li>
</ol>
</li>
<li><p><strong>水印（watermark）和leader epoch</strong></p>
<p>水印被称为高水印或高水位，通常被用在流水式处理领域，以表征元素或时间在基于时间层面上的进度。在Kafka中，水印的概念与时间无关，而与位置信息相关。严格来说，它表示的就是位置信息，即位移（offset）。</p>
<ul>
<li><p><strong>LEO更新机制</strong></p>
<ul>
<li><p><strong>follower</strong></p>
<p>follower副本不停地向leader副本所在broker发送FETCH请求，一旦获取消息，便写入自己的日志中进行备份。</p>
<p>Kafka设计了两套follower副本LEO属性：一套LEO属性保存在follower副本所在broker的缓存上；另一套LEO值保存在leader副本所在broker的缓存上。换句话说，leader副本所在broker的缓存上保存了该分区下所有follower副本的LEO属性值。</p>
<ol>
<li><p>follower副本端LEO更新</p>
<p>每当在底层日志新写入一条消息，其LEO值就会加1.</p>
</li>
<li><p>leader副本端的follower副本LEO更新</p>
<p>一旦leader接收到follower发送的FETCH请求，它首先会从自己的log中读取相应的数据，但是在给follower返回数据之前它先去更新follower的LEO。</p>
</li>
</ol>
</li>
<li><p><strong>leader</strong></p>
<p>每当在底层日志新写入一条消息，其LEO值就会加1.</p>
</li>
</ul>
</li>
<li><p><strong>HW更新机制</strong></p>
<p>前面说过，leader broker上保存了一套follower副本的LEO以及它自己的LEO。当尝试确定分区HW时，它会选出所有满足条件的副本，比较它们的LEO，并选择最小的LEO值作为HW值。</p>
</li>
<li><p><strong>图解Kafka备份原理</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/Kafka备份原理.png" alt="Kafka备份原理"></p>
</li>
<li><p><strong>基于水印机制的缺陷</strong></p>
<ul>
<li><strong>数据丢失</strong>：使用HW值来确定备份进度时其值的更新是在下一轮RPC中完成的。延迟一轮FETCH请求更新HW的值的设计使得followerHW值是异步延迟更新的，若在这个过程中leader发生变更，那么称为新leader的follower的HW值就有可能是过期的，使得clients端认为成功提交的消息被删除了。</li>
<li><strong>数据不一致/数据离散</strong>：leader端log和follower端的log数据不一致</li>
</ul>
</li>
<li><p><strong>leader epoch</strong></p>
<p><strong>上述两个问题的根本原因在于HW值被用于衡量副本备份的成功与否，以及在出现崩溃时作为日志截断的依据，但HW值的更新是异步延迟的，特别是需要额外的FETCH请求处理流程才能更新，这中间发生的任何崩溃都可能导致HW值的过期</strong></p>
<p>leader epoch，实际上是一对值(epoch，offset)。epoch表示leader的版本号，从0开始，当leader变更过1次时，epoch就会+1，而offset则对应于该epoch版本的leadre写入第一条消息的位移。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><ul>
<li><p><strong>协议设计</strong></p>
<p>所谓通信协议，就是实现client-server间或server-server间数据传输的一套规范。Kafka通信协议是基于TCP之上的二进制协议，这套协议提供的API表现为服务于不同功能的多种请求类型以及对应的相应。所有类型的请求和响应都是结构化的，有不同的初始类型构成。</p>
</li>
<li><p><strong>常见请求类型</strong></p>
<ol>
<li>PRODUCE请求</li>
<li>FETCH请求</li>
<li>METADATA请求</li>
</ol>
</li>
<li><p><strong>请求处理流程</strong></p>
<ul>
<li><p><strong>clients端</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/clients端处理流程.png" alt="cliens请求处理"></p>
</li>
<li><p><strong>broker端</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/broker端请求处理流程.png" alt="broker端请求处理"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="controller设计"><a href="#controller设计" class="headerlink" title="controller设计"></a>controller设计</h4><ul>
<li><p><strong>controller概览</strong></p>
<p>在一个Kafka集群中，某一个broker会被选举出来承担特殊的角色，即控制器。一如controller就是用来管理和协调Kafka集群的。具体来说，就是管理集群中所有分区的状态并执行相应的管理操作。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/controller架构.png" alt="controller架构"></p>
</li>
<li><p><strong>controller管理状态</strong></p>
<p>controller维护的状态分为两类：每台broker上的分区副本和每个分区的leader副本信息。从维度上看，这些状态可分为副本状态和分区状态。</p>
<ul>
<li><p><strong>副本状态机</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/副本状态机.png" alt="副本状态机"></p>
</li>
<li><p><strong>分区状态机</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/分区状态机.png" alt="分区状态机"></p>
</li>
</ul>
</li>
<li><p><strong>controller职责</strong></p>
<ol>
<li>更新集群元数据信息</li>
<li>创建topic</li>
<li>删除topic</li>
<li>分区重分配</li>
<li>preferred leader副本选举</li>
<li>topic分区扩展</li>
<li>broker加入集群</li>
<li>broker崩溃</li>
<li>受控关闭</li>
<li>controller leader选举</li>
</ol>
</li>
</ul>
<hr>
<h4 id="broker请求处理"><a href="#broker请求处理" class="headerlink" title="broker请求处理"></a>broker请求处理</h4><ul>
<li><strong>Reactor模式</strong></li>
</ul>
<p>Kafka broker处理请求的模式就是Reactor设计模式。Reactor设计模式是一种事件处理模式，旨在处理多个输入源同时发送过来的请求。Reactor模式中的服务处理器或分发器将入站请求按照多路复用的方式分发到对应的请求处理器。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/Reactor模式.png" alt="Reactor模式"></p>
<ul>
<li><p><strong>Kafka broker请求处理</strong></p>
<p>Kafka broker请求处理实现了Reactor模式。在Kafka中，每个broker都有一个acceptor线程和若干个processor线程。processor线程的数量是可以配置的。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/broker请求处理流程.png" alt="broker请求处理流程"></p>
</li>
</ul>
<hr>
<h3 id="producer端设计架构"><a href="#producer端设计架构" class="headerlink" title="producer端设计架构"></a>producer端设计架构</h3><h4 id="producer端基本数据结构"><a href="#producer端基本数据结构" class="headerlink" title="producer端基本数据结构"></a>producer端基本数据结构</h4><ul>
<li><p><strong>ProducerRecord</strong></p>
<p>一个ProducerRecord封装了一条待发送的消息（或称为记录）。</p>
<p>ProducerRecord由5个字段构成:</p>
<ol>
<li>topic：该消息所属的topic</li>
<li>partition：该消息所属的分区</li>
<li>key：消息key</li>
<li>value：消息体</li>
<li>timestamp：消息时间戳</li>
</ol>
</li>
<li><p><strong>RecordMetadata</strong></p>
<p>该数据结构表示Kafka服务器端返回给客户端的消息的元数据</p>
<ol>
<li>offset：消息在 分区日志中的位移信息</li>
<li>timesstamp：消息时间戳</li>
<li>topic/partition</li>
<li>checksum：消息CRC32码</li>
<li>serializedKeySize：序列化后消息的key字节数</li>
<li>serializedValueSize：序列化后消息value字节数</li>
</ol>
</li>
</ul>
<hr>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>如果把producer统一看成一个盒子，那么整个producer端的工作原理便如图所示。大体来说，用户首先构建待发送的消息对象ProducerRecord，然后调用KafkaProducer#send方法进行发送。KafkaProducer接收到消息后首先对其进行序列化，然后结合本地缓存的元数据信息一起发送给partitioner去确定目标分区，最后追加写入内存中的消息缓冲池。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/producer端的工作原理.png" alt="producer端的工作原理"></p>
<p>调用KafkaProducer.send执行的操作：</p>
<ol>
<li><p><strong>序列化+计算目标分区</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/producer序列化.png" alt="序列化"></p>
</li>
<li><p><strong>追加写入消息缓冲区</strong></p>
</li>
<li><p><strong>Sender线程预处理及消息发送</strong></p>
</li>
</ol>
<hr>
<h3 id="consumer端设计架构"><a href="#consumer端设计架构" class="headerlink" title="consumer端设计架构"></a>consumer端设计架构</h3><h4 id="consumer-group-状态机"><a href="#consumer-group-状态机" class="headerlink" title="consumer group 状态机"></a>consumer group 状态机</h4><p>新版本consumer依赖于broker端的组协调者coordinator来管理组内的所有consumer实例并负责把分配方案发到每个consumer上。分配方案由组内的leader consumer根据指定的分区分配策略指定的。</p>
<p>分区分配的操作在consumer端执行而非broker端的好处：</p>
<ol>
<li>便于维护与升级：如果在broker端实现，那么分配策略的变动势必要重启整个Kafka集群。生产环境中重启服务器的代价是很高的。</li>
<li>便于实现自定义策略：不同的策略由不同的逻辑实现。coordinator端代码不容易实现灵活可定制的分配逻辑</li>
<li>解耦了组管理与分区分配，coordinator负责组管理工作，而consumer程序负责分区分配。</li>
</ol>
<p>Kafka为每个consumer group定义了5个状态：</p>
<ul>
<li><strong>Empty</strong>：表明group下没有任何active consumer，但可能包含位移信息。</li>
<li><strong>PreparingRebalance</strong>：该状态表明group正在准备进行group rebalance。</li>
<li><strong>AwaitingSync</strong>：该状态表明所有成员都已经加入组并等待leader consumer发送分区分配方案。</li>
<li><strong>Stable</strong>：该状态表明group开始正常消费。此时group必须响应clients发送过来的任何请求。</li>
<li><strong>Dead</strong>：该状态表明group已经彻底废弃，group内没有任何成员并且group的所有元数据都已被删除。</li>
</ul>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/consumer group状态机.png" alt="consumer group状态机"></p>
<hr>
<h3 id="实现精确一次处理语义-exactly-once-semanties-EOS"><a href="#实现精确一次处理语义-exactly-once-semanties-EOS" class="headerlink" title="实现精确一次处理语义(exactly-once semanties, EOS)"></a>实现精确一次处理语义(exactly-once semanties, EOS)</h3><p>clients端常见的3种消息交付语义：</p>
<ol>
<li><strong>最多一次（ai most once）</strong>：消息可能丢失也可能被处理，但最多只会被处理一次</li>
<li><strong>至少一次（at last once）</strong>：消息不会丢失，但可能被多次处理</li>
<li><strong>精确一次（exactly once）</strong>：消息被处理且只会被处理一次。</li>
</ol>
<h4 id="幂等性producer（idempotent-producer）"><a href="#幂等性producer（idempotent-producer）" class="headerlink" title="幂等性producer（idempotent producer）"></a>幂等性producer（idempotent producer）</h4><p>幂等性producer是Apache Kafka 0.11.0.0版本用于实现EOS的一个利器。若一个操作执行多次的结果与只运行一次的结果是相同的，那么称该操作为幂等操作。引入幂等producer表示它的发送操作是幂等。瞬时的发送错可能导致produecer端出现重试，同一个消息被producer发送多次，但在broker端这条消息只会被写入日志一次。</p>
<p>幂等性producer的设计思路类似于TCP的工作方式。发送到broker端的每批消息都会被赋予一个序列号（sequence number）用于消息去重。但是和TCP不同的是，这个序列号不会被丢弃，相反Kafka会把它们保存在底层日志中，这样即使分区的leader副本挂掉，新选出来的leader broker也能执行消息去重工作。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/幂等性producer消息去重.png" alt="幂等性producer消息去重"></p>
<hr>
<h4 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h4><p>对事务的支持是Kafka实现EOS的第二个利器。引入事务使得clients端程序（无论是producer还是consumer）能够将一组消息放入一个原子性单元中统一处理。</p>
<p>处于事务中的这组消息能够从多个分区中消费，也可以发送到多个分区中。重要的是不论是发送还是消费，Kafka都能保证它们是原子性，即所有的写入操作幺妹全部成功，要么全部失败。</p>
<p>Kafka为实现事务要求应用程序必须提供一个唯一的id来表征事务。这个id被称为事务id，它必须在应用程序所有的会话上是唯一的。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/跨分区事务提交与读取.png" alt="跨分区事务提交与读取"></p>
<p>PS：未完待续，后续深入学习再做补充</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Utur</p>
              <div class="site-description motion-element" itemprop="description">木龟想做一个哈皮程序猿。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Turtle-knight" title="GitHub &rarr; https://github.com/Turtle-knight" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:turtle.mugui@gmail.com" title="E-Mail &rarr; mailto:turtle.mugui@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://plus.google.com/木龟" title="Google &rarr; https://plus.google.com/木龟" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Utur</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
