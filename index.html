<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="木龟想做一个哈皮程序猿。">
<meta property="og:type" content="website">
<meta property="og:title" content="Utur的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Utur的个人博客">
<meta property="og:description" content="木龟想做一个哈皮程序猿。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Utur的个人博客">
<meta name="twitter:description" content="木龟想做一个哈皮程序猿。">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Utur的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Utur的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">天天学习，好好向上</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Linux_环境变量PATH/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Linux_环境变量PATH/" class="post-title-link" itemprop="url">Linux环境变量PATH</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:07:58" itemprop="dateModified" datetime="2019-07-06T17:07:58+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="环境变量-PATH"><a href="#环境变量-PATH" class="headerlink" title="环境变量$PATH"></a>环境变量$PATH</h2><p>在Linux中，执行命令时，系统会按照PATH的设置，去每个PATH定义的路径下搜索执行文件，先搜索到的文件先执行。（From：《鸟哥的LINUX私房菜》）</p>
<h2 id="改变PATH"><a href="#改变PATH" class="headerlink" title="改变PATH"></a>改变PATH</h2><h3 id="直接修改-PATH值："><a href="#直接修改-PATH值：" class="headerlink" title="直接修改$PATH值："></a>直接修改$PATH值：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH //查看当前PATH的配置路径</span><br><span class="line">export PATH=$PATH:/xxx1:/xxx2 //将需要的配置路径加入$PATH 等号两边没有空格，path之间用':'间隔</span><br></pre></td></tr></table></figure>
<ul>
<li>生效方法：立即生效</li>
<li>有效期限：临时改变，只对当前终端有效，关闭后恢复原来的PATH</li>
<li>用户局限：<strong>仅当前用户</strong></li>
</ul>
<h3 id="通过修改-bashrc文件：（-bashrc文件在根目录下）"><a href="#通过修改-bashrc文件：（-bashrc文件在根目录下）" class="headerlink" title="通过修改.bashrc文件：（.bashrc文件在根目录下）"></a>通过修改.bashrc文件：（.bashrc文件在根目录下）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc  // 编辑.bashrc文件</span><br><span class="line"></span><br><span class="line">// 在最后一行添加：</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/xxx/xxx    // /xxx/xxx为需要加入的环境变量地址，等号两边无空格</span><br></pre></td></tr></table></figure>
<ul>
<li><p>生效方法：（有一下两种）</p>
<ol>
<li><p>关闭当前终端窗口，重新打开一个新的终端窗口即可</p>
</li>
<li><p>输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>
<p>命令，立即生效。</p>
</li>
</ol>
</li>
<li><p>有效期限：永久有效</p>
</li>
<li>用户局限：<strong>仅当前用户</strong></li>
</ul>
<h3 id="通过修改profile文件：（profile文件在-etc目录下）"><a href="#通过修改profile文件：（profile文件在-etc目录下）" class="headerlink" title="通过修改profile文件：（profile文件在/etc目录下）"></a>通过修改profile文件：（profile文件在/etc目录下）</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile    // 编辑profile文件</span><br><span class="line"></span><br><span class="line">// 在最后一行添加：</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/xxx/xxx</span><br></pre></td></tr></table></figure>
<ul>
<li>生效方法：系统重启</li>
<li>有效期限：永久有效</li>
<li>用户局限：<strong>所有用户</strong></li>
</ul>
<h3 id="通过修改environment文件：（environment文件在-etc目录下）"><a href="#通过修改environment文件：（environment文件在-etc目录下）" class="headerlink" title="通过修改environment文件：（environment文件在/etc目录下）"></a>通过修改environment文件：（environment文件在/etc目录下）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/environment    //编辑environment文件</span><br><span class="line"></span><br><span class="line">在PATH=/.......中加入“:/xxx/xxx”</span><br></pre></td></tr></table></figure>
<ul>
<li>生效方法：系统重启</li>
<li>有效期限：永久有效</li>
<li>用户局限：<strong>所有用户</strong></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Ubuntu快速配置工作环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Ubuntu快速配置工作环境/" class="post-title-link" itemprop="url">Ubuntu环境</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 16:42:11" itemprop="dateModified" datetime="2019-07-06T16:42:11+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Ubuntu/" itemprop="url" rel="index"><span itemprop="name">Ubuntu</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Ubuntu工作环境快速配置"><a href="#Ubuntu工作环境快速配置" class="headerlink" title="Ubuntu工作环境快速配置"></a>Ubuntu工作环境快速配置</h1><p>首先更新一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br></pre></td></tr></table></figure>
<h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><p>详情<a href="https://blog.csdn.net/JRRRJ/article/details/81082444" target="_blank" rel="noopener">https://blog.csdn.net/JRRRJ/article/details/81082444</a></p>
<p>将阿里源添加到<strong>sources.list</strong>中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure>
<p>保存退出，然后更新。</p>
<h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><p>在「软件和更新」-「附加驱动」选项卡中进行选择</p>
<h2 id="基础软件安装"><a href="#基础软件安装" class="headerlink" title="基础软件安装"></a>基础软件安装</h2><h3 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure>
<h4 id="vim-个人配置"><a href="#vim-个人配置" class="headerlink" title="vim 个人配置"></a>vim 个人配置</h4><p>.vimrc (保存在个人百度网盘快速配置Ubuntu环境文件夹)</p>
<h3 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h3><p><a href="https://blog.csdn.net/fx_yzjy101/article/details/80243710" target="_blank" rel="noopener">https://blog.csdn.net/fx_yzjy101/article/details/80243710</a></p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>
<h3 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h3><p><a href="https://blog.csdn.net/qq_15192373/article/details/81091278" target="_blank" rel="noopener">https://blog.csdn.net/qq_15192373/article/details/81091278</a></p>
<h3 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a>ipython</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ipython3</span><br></pre></td></tr></table></figure>
<h3 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h3><p>安装详情见<a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">flask官网</a></p>
<h3 id="Typora-Markdown编辑"><a href="#Typora-Markdown编辑" class="headerlink" title="Typora(Markdown编辑)"></a>Typora(Markdown编辑)</h3><p>安装详情见<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora官网</a></p>
<h3 id="Shutter-截图软件"><a href="#Shutter-截图软件" class="headerlink" title="Shutter(截图软件)"></a>Shutter(截图软件)</h3><p>详情见<a href="https://blog.csdn.net/qq_19339041/article/details/80058892" target="_blank" rel="noopener">https://blog.csdn.net/qq_19339041/article/details/80058892</a></p>
<h3 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h3><p>先卸载LibreOffice</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge libreoffice*</span><br></pre></td></tr></table></figure>
<p>下载安装访问<a href="http://www.wps.cn/product/wpslinux/" target="_blank" rel="noopener">WPS官网</a></p>
<h3 id="MySQL-amp-amp-Redis"><a href="#MySQL-amp-amp-Redis" class="headerlink" title="MySQL &amp;&amp; Redis"></a>MySQL &amp;&amp; Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure>
<h3 id="Wechat"><a href="#Wechat" class="headerlink" title="Wechat"></a>Wechat</h3><p><a href="https://www.cnblogs.com/dotnetcrazy/p/9124658.html" target="_blank" rel="noopener">Ubuntu 18.04 安装微信（Linux通用）</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/django_web_开发错误整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/django_web_开发错误整理/" class="post-title-link" itemprop="url">django开发问题整理</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:12:50" itemprop="dateModified" datetime="2019-07-06T17:12:50+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/django/" itemprop="url" rel="index"><span itemprop="name">django</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在使用Django2-0进行Web开发过程中遇到的问题"><a href="#在使用Django2-0进行Web开发过程中遇到的问题" class="headerlink" title="在使用Django2.0进行Web开发过程中遇到的问题"></a>在使用Django2.0进行Web开发过程中遇到的问题</h1><h3 id="Django在根据models生成数据库表时报-init-missing-1-required-positional-argument-‘on-delete’"><a href="#Django在根据models生成数据库表时报-init-missing-1-required-positional-argument-‘on-delete’" class="headerlink" title="Django在根据models生成数据库表时报 _ init _()missing 1 required positional argument: ‘on_delete’"></a>Django在根据models生成数据库表时报 _ <em>init</em> _()missing 1 required positional argument: ‘on_delete’</h3><ul>
<li><p><strong>原因</strong></p>
<p>在django2.0后，定义外键和一对一关系的时候需要加on_delete选项，此参数为了避免两个表里的数据不一致问题，不然会报错：<br>TypeError: _ init _() missing 1 required positional argument: ‘on_delete’</p>
</li>
<li><p><strong>解决方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码报错</span></span><br><span class="line">user = models.OneToOneField(User)</span><br><span class="line">owner = models.ForeignKey(UserProfile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下代码正确</span></span><br><span class="line">user = models.OneToOneField(User, on_delete=models.CASCADE)</span><br><span class="line">owner = models.ForergnKey(UserProfile, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数说明</p>
<p>on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值。<br>CASCADE：此值设置，是级联删除。<br>PROTECT：此值设置，是会报完整性错误。<br>SET_NULL：此值设置，会把外键设置为null，前提是允许为null。<br>SET_DEFAULT：此值设置，会把设置为外键的默认值。<br>SET()：此值设置，会调用外面的值，可以是一个函数。<br><strong>一般情况下使用CASCADE就可以了。</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Django2-0配置Mysql数据库后执行数据迁移时报错："><a href="#Django2-0配置Mysql数据库后执行数据迁移时报错：" class="headerlink" title="Django2.0配置Mysql数据库后执行数据迁移时报错："></a>Django2.0配置Mysql数据库后执行数据迁移时报错：</h3><ul>
<li><p><strong>报错</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">django</span><span class="selector-class">.core</span><span class="selector-class">.exceptions</span><span class="selector-class">.ImproperlyConfigured</span>: <span class="selector-tag">mysqlclient</span> 1<span class="selector-class">.3</span><span class="selector-class">.3</span> <span class="selector-tag">or</span> <span class="selector-tag">newer</span> <span class="selector-tag">is</span> <span class="selector-tag">required</span>; <span class="selector-tag">you</span> <span class="selector-tag">have</span> 0<span class="selector-class">.7</span><span class="selector-class">.11</span><span class="selector-class">.None</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原因</strong></p>
<p>MySQLclient目前只支持到python3.4</p>
</li>
<li><p><strong>解决方法</strong></p>
<p>因为要使用<strong>python3.6</strong>，所以修改下面路径的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /home/utur/.<span class="built_in">local</span>/lib/python3.6/site-packages/django/db/backends/mysql</span></span><br></pre></td></tr></table></figure>
<p>将以下代码注释即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> version &lt; (<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>):</span><br><span class="line">	<span class="keyword">raise</span> ImproperlyConfigured(<span class="string">"mysqlclient 1.3.3 or newer is required; you have %s"</span> % Database.__version__)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="MySQL-django-db-utils-OperationalError-1698-“Access-denied-for-user-‘roo‘-’localhost’”-with-correct-username-and-pw"><a href="#MySQL-django-db-utils-OperationalError-1698-“Access-denied-for-user-‘roo‘-’localhost’”-with-correct-username-and-pw" class="headerlink" title="MySQL: django.db.utils.OperationalError:( 1698, “Access denied for user ‘roo‘@’localhost’”) with correct username and pw"></a>MySQL: django.db.utils.OperationalError:( 1698, “Access denied for user ‘roo‘@’localhost’”) with correct username and pw</h3><ul>
<li><p>详情见：<a href="https://stackoverflow.com/questions/41542045/mysql-django-db-utils-operationalerror-1698-access-denied-for-user-root" target="_blank" rel="noopener">https://stackoverflow.com/questions/41542045/mysql-django-db-utils-operationalerror-1698-access-denied-for-user-root</a></p>
</li>
<li><p><strong>解决方法</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user &apos;django&apos;@&apos;localhost&apos; identified by &apos;django-user-password&apos;;</span><br><span class="line">grant usage on *.* to &apos;django&apos;@&apos;localhost&apos;;</span><br><span class="line">grant all privileges on django-database-1.* to &apos;django&apos;@&apos;localhost&apos;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="AttributeError-‘str’-object-has-no-attribute-‘decode’"><a href="#AttributeError-‘str’-object-has-no-attribute-‘decode’" class="headerlink" title="AttributeError: ‘str’ object has no attribute ‘decode’"></a>AttributeError: ‘str’ object has no attribute ‘decode’</h3><ul>
<li><p><strong>报错</strong></p>
<p>执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py makemigrations</span><br></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/Django-2.2-py3.7.egg/django/db/backends/mysql/operations.py", line 146, in last_executed_query</span><br><span class="line">    query = query.decode(errors='replace')</span><br><span class="line">AttributeError: 'str' object has no attribute 'decode'</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原因</strong></p>
<p>python在bytes和str两种类型转换，所需要的函数依次是encode(),decode()</p>
</li>
<li><p><strong>解决方法</strong></p>
<p>在报错路径下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim operations.py</span><br></pre></td></tr></table></figure>
<p>找到错误代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query = query.decode(errors=<span class="string">'replace'</span>)</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query = query.encode(errors=<span class="string">'replace'</span>)</span><br><span class="line"><span class="comment"># 保存并退出</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="include-got-an-unexpected-keyword-argument-‘app-name’"><a href="#include-got-an-unexpected-keyword-argument-‘app-name’" class="headerlink" title="include() got an unexpected keyword argument ‘app_name’"></a>include() got an unexpected keyword argument ‘app_name’</h3><ul>
<li><p><strong>原因</strong></p>
<p><strong>在Django2.0版本使用url()导致，推荐使用path()</strong></p>
</li>
<li><p><strong>解决方法</strong></p>
<p>在xxx应用下的<strong>urls.py</strong>添加app_name变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url,include</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app_name = xxx</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">     <span class="comment"># 路由规则</span></span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Apache_Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Apache_Kafka/" class="post-title-link" itemprop="url">消息队列Kafka学习笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 16:50:18" itemprop="dateModified" datetime="2019-07-06T16:50:18+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p>Kafka是一款由美国领英公司（LinkedIn）开源出来的<strong>高性能消息引擎系统（Messaging system）</strong>,其核心功能是——<em>高性能的消息发送与高性能的消息消费</em>。但随着Kafka的不断演进，在Kafka 0.10.0.0版本正式推出了Kafka Streams，即流式处理组件。自此Kafka正式成为了一个流式处理框架。</p>
<hr>
<h2 id="前置知识背景"><a href="#前置知识背景" class="headerlink" title="前置知识背景"></a>前置知识背景</h2><h3 id="消息引擎系统"><a href="#消息引擎系统" class="headerlink" title="消息引擎系统"></a>消息引擎系统</h3><p>消息引擎，又叫消息队列，消息中间件等。</p>
<p>根据维基百科的定义，企业消息引擎系统（EMS）是企业发布的一组规范。公司使用这组规范实现在不同系统之间传递语义准确的消息。在实际使用场景中，消息引擎系统通常以软件接口为主要形式，实现了松耦合的异步式数据传递语义。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/消息引擎架构.png" alt="消息引擎"></p>
<hr>
<h3 id="消息引擎范型"><a href="#消息引擎范型" class="headerlink" title="消息引擎范型"></a>消息引擎范型</h3><p>根据维基百科定义，一个消息引擎范型是一个基于网络的架构范型，描述了消息引擎系统的两个不同的子部分是如何互连且交互的。如果把消息引擎系统的这两个子系统比喻成两座城市，那么传输协议就是需要铺设的沥青公路，而引擎范型决定了来往穿梭与这两座城市的路线。</p>
<p>最常见的两种消息引擎范型是<strong><em>消息队列模型</em></strong>和<strong><em>发布/订阅模型</em></strong>。</p>
<ul>
<li><p>消息队列（message queue）模型是基于队列提供消息传输服务的，多用于进程间通信以及线程间通信。该模型定义了消息队列、发送者和接收者，提供了一种点对点的消息传递方式，即发送者发送每条消息到队列的指定位置，接收者从指定位置获取消息。每条消息由一个发送者生产出来，且只被一个消费者处理。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/队列消息引擎模型.png" alt="消息队列模型"></p>
</li>
<li><p>发布/订阅模型(publish/subscribe),它有主题（topic）的概念：一个topic可以理解为逻辑语义相近的消息的容器。这种模型定义了类似于生产者/消费者这样的角色，即发布者和订阅者。发布者将消息生产出来发送到指定的topic中，所有订阅了该topic的订阅者都可以接收到该topic下的所有消息。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/发布订阅消息模型.png" alt="发布订阅"></p>
</li>
</ul>
<hr>
<h2 id="Kafka术语"><a href="#Kafka术语" class="headerlink" title="Kafka术语"></a>Kafka术语</h2><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>既然Kafka的核心功能就是消息引擎，那么对消息的设计日然是首当其冲的事情。Kafka在消息设计时特意避开了繁重的Java堆上内存分配，直接使用紧凑二进制字节数组ByteBuffer而不是独立的对象，因此至少能够访问多一倍的可用内存。</p>
<p>省去padding，java对对象保存的大开销以及可能的页缓存。</p>
<h3 id="topic和partiiton"><a href="#topic和partiiton" class="headerlink" title="topic和partiiton"></a>topic和partiiton</h3><p>从概念上来说，topic只是一个逻辑概念，代表了一类消息，也可以认为是消息被发送到的地方。通常可以使用topic来区分实际业务，比如业务A使用一个topic，业务B使用另一个topic。</p>
<p>Kafka中的topic通常都会被多个消费者订阅，出于性能的考量，Kafka并不是topic-message的两级结构，而是采取了topic-partition-message的三级结构来分散负载。从本质上来说，每个Kafka topic都由若干个partition组成。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/topic和partition.png" alt="topic和partition"></p>
<p>topic是由多个partition组成的，而Kafka的partition是不可修改的有序消息队列，也可以说是有序的消息日志。每个partition都有自己专属的partition号。用户对partition唯一能做的操作就是在消息序列的尾部追加写入消息。<strong>partition上的每条消息都会被分配一个唯一的序列号-该序列号被称为位移（offset）。位移信息可以唯一定位到某partition下的一条消息</strong></p>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>实际上，Kafka消费者也有位移（offset）的概念，但这两个offset属于不同的概念。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/消费者位移.png" alt="消费者位移"></p>
<p>每条消息在某个partition的位移是固定的，但消费该partition的消费者的位移会随着消费进度不断前移，但不能超过该分区最新一条消息的位移。</p>
<p><strong>从本质上看，Kafka中的一条消息其实就是一个&lt;topic,partition,offset&gt;三元组（tuple），通过该元组，可以在Kafka集群中找到位移对应的那条消息。</strong></p>
<h3 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h3><p>为了实现高可靠性，通过冗余机制——备份多份日志。这些备份日志在Kafka中被称为副本（replica），它们存在的唯一目的就是防止数据丢失。</p>
<p><strong>副本分为两类：领导者副本（leader replica）和追随者副本（follower replica）</strong>。follower replica是不能提供服务给客户端的，它只是被动地向领导者副本（leader replica）获取数据，一旦leader replica所在的broker宕机，Kafka会从剩余的replica中选举出新的leader继续提供服务。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/leadr-follower.png" alt="leader-follower"></p>
<h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p><strong>ISR的全称是 in-sync replica，就是与leader replica保持同步的replica集合。</strong></p>
<p>Kafka为partition动态维护一个replica集合。该集合中的所有replica保存的消息日志都与leader replica保护同步状态。<em>只有这个集合中的replica才能被选举为leader，也只有该集合中所有replica都接收到了同一条消息，Kafka才会将该消息置于“已提交”状态，即认为这条消息发送成功</em>。<strong>Kafka承诺只要这个集合中至少存在一个replica，那些”已提交“状态的消息就不会丢失。</strong></p>
<hr>
<h2 id="Kafka使用场景"><a href="#Kafka使用场景" class="headerlink" title="Kafka使用场景"></a>Kafka使用场景</h2><ul>
<li>消息传输</li>
<li>网站行为日志追踪</li>
<li>审计数据收集</li>
<li>日志收集</li>
<li>Event Sourcing</li>
<li>流式处理</li>
</ul>
<hr>
<h2 id="Kafka设计原理"><a href="#Kafka设计原理" class="headerlink" title="Kafka设计原理"></a>Kafka设计原理</h2><h3 id="broker端设计架构"><a href="#broker端设计架构" class="headerlink" title="broker端设计架构"></a>broker端设计架构</h3><p>broker是Apache Kafka最重要的组件，本质上它是一个功能载体（或服务载体），承载了绝大多数的Kafka服务。事实上，大多数的消息队列框架都有broker或已知类似的角色。一个broker通常是以服务器的形式出现的。</p>
<h4 id="消息设计"><a href="#消息设计" class="headerlink" title="消息设计"></a>消息设计</h4><ol>
<li><p><strong>消息格式</strong></p>
<p>V2版本分为<strong>消息</strong>和<strong>消息集合</strong>两个维度，不过消息集合的提法被消息批次所取代。V2版本中，它有一个专门的属于：RecordBatch。</p>
<p>V2版本消息格式</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/V2版本消息格式.png" alt="消息格式"></p>
<p>“可变长度”表示Kafka会根据具体的值来确定到底需要几字节保存。为了在序列化时降低使用的字节数，V2版本借鉴了Google ProtoBuffer中的Zig-zag编码方式，使得绝对值较小的整数占用字节数较少的字节。</p>
</li>
<li><p><strong>消息batch</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/V2版本消息batch格式.png" alt="消息batch"></p>
<ul>
<li>CRC值从消息层面被移除，放入batch这一层</li>
<li>PID、producer epoch和序列号等消息都是0.11.0.0版本为了实现幂等性producer和支持事务而一如的。</li>
</ul>
<p>通过使用mirco-batch，批次地发送消息，能大幅度地提高Kafka的吞吐量。</p>
</li>
</ol>
<hr>
<h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h4><p>Kafka是分布式的消息引擎集群环境，支持自动化的服务发现与成员管理。依赖于Apache Zookeeper实现，每当一个broker启动，它会将自己注册到Zookeeper下的一个节点。</p>
<ul>
<li><p>首先，每个broker在Zookeper下注册节点的路径是chroot/brokers/ids/&lt;broker.id&gt;。如果没有配置chroot，则路径是/broker/ids/&lt;broker.id&gt;。</p>
</li>
<li><p>其次，broker向Zookeeper中的注册消息以JSON格式保存。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"loacalhost"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">9092</span>,</span><br><span class="line">    <span class="attr">"jmx_port"</span>: <span class="number">9999</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="number">1499737197</span>,</span><br><span class="line">    <span class="attr">"endpoints"</span>: [</span><br><span class="line">        <span class="string">"CLIENT"</span>://host1:<span class="number">9092</span><span class="string">",</span></span><br><span class="line"><span class="string">        "</span>REPLICATION://HOST1:<span class="number">9093</span><span class="string">"</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    "</span>listener_security_protocol_map<span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>CLIENT<span class="string">": "</span>SSL<span class="string">",</span></span><br><span class="line"><span class="string">        "</span>REPLICATION<span class="string">": "</span>PLAINTEXT<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "</span>rack<span class="string">": "</span>dc1<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，Zookeeper临时节点的生命周期和客户端会话绑定。如果客户端会话失效，该临时节点就会自动被清除掉。Kafka正是利用Zookeeper临时节点来管理broker生命周期的。broker启动时在Zookeeper中创建对应的临时节点，同时还会创建一个监听器（listener）监听该临时节点的状态；一旦broker启动后，监听器会自动同步整个集群消息到该broker上；而一旦broker崩溃，它与Zookeeper的会话就会失效，导致临时节点被删除，监听器被触发，然后处理broker崩溃的后续事宜。这就是Kafka管理集群及其成员的主要流程。</p>
</li>
</ul>
<hr>
<h4 id="副本与ISR设计"><a href="#副本与ISR设计" class="headerlink" title="副本与ISR设计"></a>副本与ISR设计</h4><p>一个Kafka分区本质上就是一个备份日志，即利用多份相同的备份共同提供冗余机制来保持系统高可用性。这些备份在Kafka中被称为副本（replica）。</p>
<ul>
<li><p><strong>follower副本同步</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/副本位置信息.png" alt="副本位置信息"></p>
<ol>
<li><p>起始位移（base offset）：表示该副本当前所含第一条消息的位移</p>
</li>
<li><p><strong>高水印值（high watermark，HW</strong>）：副本高水印值。它保存了该副本最新一条已提交消息的位移。leader分区的HW值决定了副本中已提交消息的范围，也确定了consumer能够获取消息的消息上限。任何一个副本对象的HW值一定不大于其LEO值。Kafka对leader副本和follower副本的HW值更新机制是不同的。</p>
</li>
<li><p><strong>日志末端位移（log end offset，LEO）</strong>：副本日志中下一条待写入消息的offset。所有副本都需要维护自己的LEO信息。只有ISR中的所有副本都更新了对应的LEO之后，leader副本才会向右移动HW值表明消息写入成功。Kafka对leader副本和follower副本的LEO值更新机制也是不同的。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/副本同步流程.png" alt="副本同步流程"></p>
</li>
</ol>
</li>
<li><p><strong>水印（watermark）和leader epoch</strong></p>
<p>水印被称为高水印或高水位，通常被用在流水式处理领域，以表征元素或时间在基于时间层面上的进度。在Kafka中，水印的概念与时间无关，而与位置信息相关。严格来说，它表示的就是位置信息，即位移（offset）。</p>
<ul>
<li><p><strong>LEO更新机制</strong></p>
<ul>
<li><p><strong>follower</strong></p>
<p>follower副本不停地向leader副本所在broker发送FETCH请求，一旦获取消息，便写入自己的日志中进行备份。</p>
<p>Kafka设计了两套follower副本LEO属性：一套LEO属性保存在follower副本所在broker的缓存上；另一套LEO值保存在leader副本所在broker的缓存上。换句话说，leader副本所在broker的缓存上保存了该分区下所有follower副本的LEO属性值。</p>
<ol>
<li><p>follower副本端LEO更新</p>
<p>每当在底层日志新写入一条消息，其LEO值就会加1.</p>
</li>
<li><p>leader副本端的follower副本LEO更新</p>
<p>一旦leader接收到follower发送的FETCH请求，它首先会从自己的log中读取相应的数据，但是在给follower返回数据之前它先去更新follower的LEO。</p>
</li>
</ol>
</li>
<li><p><strong>leader</strong></p>
<p>每当在底层日志新写入一条消息，其LEO值就会加1.</p>
</li>
</ul>
</li>
<li><p><strong>HW更新机制</strong></p>
<p>前面说过，leader broker上保存了一套follower副本的LEO以及它自己的LEO。当尝试确定分区HW时，它会选出所有满足条件的副本，比较它们的LEO，并选择最小的LEO值作为HW值。</p>
</li>
<li><p><strong>图解Kafka备份原理</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/Kafka备份原理.png" alt="Kafka备份原理"></p>
</li>
<li><p><strong>基于水印机制的缺陷</strong></p>
<ul>
<li><strong>数据丢失</strong>：使用HW值来确定备份进度时其值的更新是在下一轮RPC中完成的。延迟一轮FETCH请求更新HW的值的设计使得followerHW值是异步延迟更新的，若在这个过程中leader发生变更，那么称为新leader的follower的HW值就有可能是过期的，使得clients端认为成功提交的消息被删除了。</li>
<li><strong>数据不一致/数据离散</strong>：leader端log和follower端的log数据不一致</li>
</ul>
</li>
<li><p><strong>leader epoch</strong></p>
<p><strong>上述两个问题的根本原因在于HW值被用于衡量副本备份的成功与否，以及在出现崩溃时作为日志截断的依据，但HW值的更新是异步延迟的，特别是需要额外的FETCH请求处理流程才能更新，这中间发生的任何崩溃都可能导致HW值的过期</strong></p>
<p>leader epoch，实际上是一对值(epoch，offset)。epoch表示leader的版本号，从0开始，当leader变更过1次时，epoch就会+1，而offset则对应于该epoch版本的leadre写入第一条消息的位移。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><ul>
<li><p><strong>协议设计</strong></p>
<p>所谓通信协议，就是实现client-server间或server-server间数据传输的一套规范。Kafka通信协议是基于TCP之上的二进制协议，这套协议提供的API表现为服务于不同功能的多种请求类型以及对应的相应。所有类型的请求和响应都是结构化的，有不同的初始类型构成。</p>
</li>
<li><p><strong>常见请求类型</strong></p>
<ol>
<li>PRODUCE请求</li>
<li>FETCH请求</li>
<li>METADATA请求</li>
</ol>
</li>
<li><p><strong>请求处理流程</strong></p>
<ul>
<li><p><strong>clients端</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/clients端处理流程.png" alt="cliens请求处理"></p>
</li>
<li><p><strong>broker端</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/broker端请求处理流程.png" alt="broker端请求处理"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="controller设计"><a href="#controller设计" class="headerlink" title="controller设计"></a>controller设计</h4><ul>
<li><p><strong>controller概览</strong></p>
<p>在一个Kafka集群中，某一个broker会被选举出来承担特殊的角色，即控制器。一如controller就是用来管理和协调Kafka集群的。具体来说，就是管理集群中所有分区的状态并执行相应的管理操作。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/controller架构.png" alt="controller架构"></p>
</li>
<li><p><strong>controller管理状态</strong></p>
<p>controller维护的状态分为两类：每台broker上的分区副本和每个分区的leader副本信息。从维度上看，这些状态可分为副本状态和分区状态。</p>
<ul>
<li><p><strong>副本状态机</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/副本状态机.png" alt="副本状态机"></p>
</li>
<li><p><strong>分区状态机</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/分区状态机.png" alt="分区状态机"></p>
</li>
</ul>
</li>
<li><p><strong>controller职责</strong></p>
<ol>
<li>更新集群元数据信息</li>
<li>创建topic</li>
<li>删除topic</li>
<li>分区重分配</li>
<li>preferred leader副本选举</li>
<li>topic分区扩展</li>
<li>broker加入集群</li>
<li>broker崩溃</li>
<li>受控关闭</li>
<li>controller leader选举</li>
</ol>
</li>
</ul>
<hr>
<h4 id="broker请求处理"><a href="#broker请求处理" class="headerlink" title="broker请求处理"></a>broker请求处理</h4><ul>
<li><strong>Reactor模式</strong></li>
</ul>
<p>Kafka broker处理请求的模式就是Reactor设计模式。Reactor设计模式是一种事件处理模式，旨在处理多个输入源同时发送过来的请求。Reactor模式中的服务处理器或分发器将入站请求按照多路复用的方式分发到对应的请求处理器。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/Reactor模式.png" alt="Reactor模式"></p>
<ul>
<li><p><strong>Kafka broker请求处理</strong></p>
<p>Kafka broker请求处理实现了Reactor模式。在Kafka中，每个broker都有一个acceptor线程和若干个processor线程。processor线程的数量是可以配置的。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/broker请求处理流程.png" alt="broker请求处理流程"></p>
</li>
</ul>
<hr>
<h3 id="producer端设计架构"><a href="#producer端设计架构" class="headerlink" title="producer端设计架构"></a>producer端设计架构</h3><h4 id="producer端基本数据结构"><a href="#producer端基本数据结构" class="headerlink" title="producer端基本数据结构"></a>producer端基本数据结构</h4><ul>
<li><p><strong>ProducerRecord</strong></p>
<p>一个ProducerRecord封装了一条待发送的消息（或称为记录）。</p>
<p>ProducerRecord由5个字段构成:</p>
<ol>
<li>topic：该消息所属的topic</li>
<li>partition：该消息所属的分区</li>
<li>key：消息key</li>
<li>value：消息体</li>
<li>timestamp：消息时间戳</li>
</ol>
</li>
<li><p><strong>RecordMetadata</strong></p>
<p>该数据结构表示Kafka服务器端返回给客户端的消息的元数据</p>
<ol>
<li>offset：消息在 分区日志中的位移信息</li>
<li>timesstamp：消息时间戳</li>
<li>topic/partition</li>
<li>checksum：消息CRC32码</li>
<li>serializedKeySize：序列化后消息的key字节数</li>
<li>serializedValueSize：序列化后消息value字节数</li>
</ol>
</li>
</ul>
<hr>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>如果把producer统一看成一个盒子，那么整个producer端的工作原理便如图所示。大体来说，用户首先构建待发送的消息对象ProducerRecord，然后调用KafkaProducer#send方法进行发送。KafkaProducer接收到消息后首先对其进行序列化，然后结合本地缓存的元数据信息一起发送给partitioner去确定目标分区，最后追加写入内存中的消息缓冲池。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/producer端的工作原理.png" alt="producer端的工作原理"></p>
<p>调用KafkaProducer.send执行的操作：</p>
<ol>
<li><p><strong>序列化+计算目标分区</strong></p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/producer序列化.png" alt="序列化"></p>
</li>
<li><p><strong>追加写入消息缓冲区</strong></p>
</li>
<li><p><strong>Sender线程预处理及消息发送</strong></p>
</li>
</ol>
<hr>
<h3 id="consumer端设计架构"><a href="#consumer端设计架构" class="headerlink" title="consumer端设计架构"></a>consumer端设计架构</h3><h4 id="consumer-group-状态机"><a href="#consumer-group-状态机" class="headerlink" title="consumer group 状态机"></a>consumer group 状态机</h4><p>新版本consumer依赖于broker端的组协调者coordinator来管理组内的所有consumer实例并负责把分配方案发到每个consumer上。分配方案由组内的leader consumer根据指定的分区分配策略指定的。</p>
<p>分区分配的操作在consumer端执行而非broker端的好处：</p>
<ol>
<li>便于维护与升级：如果在broker端实现，那么分配策略的变动势必要重启整个Kafka集群。生产环境中重启服务器的代价是很高的。</li>
<li>便于实现自定义策略：不同的策略由不同的逻辑实现。coordinator端代码不容易实现灵活可定制的分配逻辑</li>
<li>解耦了组管理与分区分配，coordinator负责组管理工作，而consumer程序负责分区分配。</li>
</ol>
<p>Kafka为每个consumer group定义了5个状态：</p>
<ul>
<li><strong>Empty</strong>：表明group下没有任何active consumer，但可能包含位移信息。</li>
<li><strong>PreparingRebalance</strong>：该状态表明group正在准备进行group rebalance。</li>
<li><strong>AwaitingSync</strong>：该状态表明所有成员都已经加入组并等待leader consumer发送分区分配方案。</li>
<li><strong>Stable</strong>：该状态表明group开始正常消费。此时group必须响应clients发送过来的任何请求。</li>
<li><strong>Dead</strong>：该状态表明group已经彻底废弃，group内没有任何成员并且group的所有元数据都已被删除。</li>
</ul>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/consumer group状态机.png" alt="consumer group状态机"></p>
<hr>
<h3 id="实现精确一次处理语义-exactly-once-semanties-EOS"><a href="#实现精确一次处理语义-exactly-once-semanties-EOS" class="headerlink" title="实现精确一次处理语义(exactly-once semanties, EOS)"></a>实现精确一次处理语义(exactly-once semanties, EOS)</h3><p>clients端常见的3种消息交付语义：</p>
<ol>
<li><strong>最多一次（ai most once）</strong>：消息可能丢失也可能被处理，但最多只会被处理一次</li>
<li><strong>至少一次（at last once）</strong>：消息不会丢失，但可能被多次处理</li>
<li><strong>精确一次（exactly once）</strong>：消息被处理且只会被处理一次。</li>
</ol>
<h4 id="幂等性producer（idempotent-producer）"><a href="#幂等性producer（idempotent-producer）" class="headerlink" title="幂等性producer（idempotent producer）"></a>幂等性producer（idempotent producer）</h4><p>幂等性producer是Apache Kafka 0.11.0.0版本用于实现EOS的一个利器。若一个操作执行多次的结果与只运行一次的结果是相同的，那么称该操作为幂等操作。引入幂等producer表示它的发送操作是幂等。瞬时的发送错可能导致produecer端出现重试，同一个消息被producer发送多次，但在broker端这条消息只会被写入日志一次。</p>
<p>幂等性producer的设计思路类似于TCP的工作方式。发送到broker端的每批消息都会被赋予一个序列号（sequence number）用于消息去重。但是和TCP不同的是，这个序列号不会被丢弃，相反Kafka会把它们保存在底层日志中，这样即使分区的leader副本挂掉，新选出来的leader broker也能执行消息去重工作。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/幂等性producer消息去重.png" alt="幂等性producer消息去重"></p>
<hr>
<h4 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h4><p>对事务的支持是Kafka实现EOS的第二个利器。引入事务使得clients端程序（无论是producer还是consumer）能够将一组消息放入一个原子性单元中统一处理。</p>
<p>处于事务中的这组消息能够从多个分区中消费，也可以发送到多个分区中。重要的是不论是发送还是消费，Kafka都能保证它们是原子性，即所有的写入操作幺妹全部成功，要么全部失败。</p>
<p>Kafka为实现事务要求应用程序必须提供一个唯一的id来表征事务。这个id被称为事务id，它必须在应用程序所有的会话上是唯一的。</p>
<p><img src="/home/utur/图片/picture_for_note/Apache_Kafka/跨分区事务提交与读取.png" alt="跨分区事务提交与读取"></p>
<p>PS：未完待续，后续深入学习再做补充</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/Linux内核（学习笔记）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Utur">
      <meta itemprop="description" content="木龟想做一个哈皮程序猿。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Utur的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/Linux内核（学习笔记）/" class="post-title-link" itemprop="url">深入理解Linux内核</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">2019-02-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-06 17:18:46" itemprop="dateModified" datetime="2019-07-06T17:18:46+08:00">2019-07-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux-的优势"><a href="#Linux-的优势" class="headerlink" title="Linux 的优势"></a>Linux 的优势</h2><ol>
<li>Linux是免费的。除硬件之外，无需任何花费就能安装一套玩整的Linux系统</li>
<li>Linux的所有成分都可以充分地定制。通过内核编译选项，你可以选择自己真正需要的特征来定制内核。</li>
<li>Linux可以运行在低档、便宜的硬件平台上。</li>
<li>Linux是强大的，由于充分挖掘了硬件部分的特点，使得Linux系统速度非常块，Linux的主要目标是效率</li>
<li>Linux的开发者都是非常出色的程序员。</li>
<li>Linux内核非常小，而且紧凑。</li>
<li>Linux与很多通用操作系统高度兼容。</li>
<li>Linux有很好的技术支持</li>
</ol>
<p><strong>内核控制路径（Kernel control path）</strong>表示内核处理系统调用、异常或中断所执行的指令序列。</p>
<p>最简单的情况下，CPU从第一条指令到最后一条指令顺序地执行内核控制路径。然而当下述事件之一发生时，CPU交错执行内核控制路径：</p>
<ol>
<li>运行在用户态的进程调用一个系统调用。</li>
<li>当运行一个内核控制路径时，CPU检测到一个异常（例如，访问一个不在RAM中的页）。</li>
<li>当CPU正在运行一个启用了中断的内核控制路径时，一个硬件中断发生。</li>
<li>在支持抢占式调度的内核中，CPU正在运行，而一个更高优先级的进程加入就绪队列，则中断发生。</li>
</ol>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/内核控制路径.png" alt="内核控制路径"></p>
<p><strong>同步内核路径</strong></p>
<ol>
<li><strong><em>非抢占式内核</em></strong>，当进程在内核态执行时，它不能被任意挂起，也不能被另一个进程代替。因此，在单处理器系统上，中断或异常处理程序不能修改的所有内核数据结构，内核对它们讷的访问都是安全的</li>
<li><strong><em>禁止中断</em></strong>，单处理器系统上的另一种同步机制是：在进入一个临界区之前禁止所有硬件中断，离开时再重新启动中断。</li>
<li><strong><em>信号量</em></strong>,信号量仅仅是与一个数据结构相关的计数器。所有内核线程在试图访问这个数据结构之前，都要检查这个信号量。可以把每个信号量看成一个对象，其组成如下：<ul>
<li>一个整数变量</li>
<li>一个等待进程的链表</li>
<li>两个原子方法：down()和up()</li>
</ul>
</li>
<li><strong><em>自旋锁</em></strong>,如果修改数据结构所需的时间比较段，那么，信号量可能是低效的。为了检查信号量，内核必须把进程插入到信号量链表中，然后挂起它。因为这两种操作比较费时，完成这些操作时，其他的内核控制路径可能已经释放了信号量。在这些情况下，多处理器操作系统使用了自旋锁（spin lock）。自旋锁与信号量非常相似，但没有进程链表，当一个进程发现锁被另一个进程锁着时，它就不停地“旋转”，执行一个紧凑的循环指令直到锁打开。当然，自旋锁在单处理器环境下是无效的。</li>
</ol>
<h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><p><strong>随机访问存储器（RAM）的使用</strong></p>
<p>所有的Unix操作系统都将RAM毫无疑义地划分为两部分，其中若干兆字节专门用于存放内核映像（也就是内核代码和内核静态数据结构）。RAM的其余部分通常有虚拟内存系统来处理，并且用在以下三种可能的方面：</p>
<ul>
<li>满足内核对缓冲去、描述符及其他动态内核数据结构的请求</li>
<li>满足进程对一般内存区的请求及对文件内存映射的请求</li>
<li>借助于高速缓存从磁盘及其他缓冲设备获得较好的性能</li>
</ul>
<p><strong>内核内存分配器</strong></p>
<p>内存内核分配其（Kernel Memory Allocator, KMA）是一个子系统，它试图满足系统中所有部分对内存的请求。</p>
<p>基于各种不同的算法技术，已经提出了集中KMA，包括：</p>
<ul>
<li><em>资源图分配算法（allocator）</em></li>
<li><em>2的幂次方空间链表</em></li>
<li><em>McKusick-Karels分配算法</em></li>
<li><em>伙伴（Buddy）系统</em></li>
<li><em>Mach的区域（Zone）分配算法</em></li>
<li><em>Dynix分配算法</em></li>
<li><em>Solaris的Slab分配算法</em></li>
</ul>
<p><strong>物理内存布局</strong></p>
<p>在初始化阶段，内核必须建立一个物理地址映射来指定哪些物理地址范围对内核可用而哪些不可用（或者因为它们映射硬件设备I/O的共享内存，或者因为相应的页框含有BIOS数据）。</p>
<p>内核将下列页框记为保留：</p>
<ul>
<li>在不可用的物理地址范围内的页框。</li>
<li>含有内核代码和已初始化的数据结构的页框</li>
</ul>
<p>保留页框中的页绝不嫩被动态分配或交换到磁盘上。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程链表</strong></p>
<p>Linux的进程链表是一个双向链表，进程链表把所有进程的描述符链接起来。每个task_struct结构都包含一个list_head类型的tasks字段，这个类型的prev和next字段分别指向前面和后面的task_struct元素。</p>
<p>进程链表的头是init_task描述符，它是所谓的0进程（process 0）或swapper进程的进程描述符。init_task的tasks.prev字段指向链表中最后插入的进程描述符tasks字段。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/进程链表.png" alt="进程链表"></p>
<p><strong>TASK_RUNNING状态的进程链表</strong></p>
<p>当内核寻找一个新进程在CPU上运行时，必须只考虑可运行进程（即处在TASK_RUNNING状态的进程）。</p>
<p>早期的Linux版本把所有的可运行进程都放在同一个叫作运行队列（runqueue）的链表中，由于维持链表中的进程按优先级排序开销过大，因此，早期的调度程序不得不为选择“最佳”可运行进程而扫描整个队列。</p>
<p>Linux 2.6实现的运行队列有所不同。其目的是让点读程序能在固定的时间内选出“最佳”可运行程序，与队列中可运行的进程数无关。提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先权对应一个不同的链表。这是一个通过使数据结构更复杂来改善性能的典型例子：调度程序的操作效率的确更高了，但运行队列的链表却为此而被拆分成140(0-139）个不同的队列。——空间换时间</p>
<p><strong>进程间的关系</strong></p>
<p>程序创建的进程具有父/子关系。如果一个进程创建多个子进程时，则子进程之间具有兄弟关系。</p>
<p>图3-4显示了一组进程间的亲属关系。进程P0接连创建了P1，P2，和P3。进程P3又创建了P4。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/进程间的关系.png" alt="进程间的关系"></p>
<p><strong>pidhash表及链表</strong></p>
<p>在几种情况下，内核必须能从进程的PID到处对应的进程描述符指针。</p>
<p>顺序扫描进程链表并检查进程描述符的pid字段是可行但相当低效的。为了加速查找，引入了4个散列表。需要4个散列表是因为进程描述符包含了表示不同类型pid的字段，而且每种类型的PID需要它自己的散列表。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/4种PID.png" alt="四种PID"></p>
<p>正如计算机科学的基础课程所阐述的那样，散列（hash）函数并不总能确保PID与表的索引一一对应。两个不同的PID散列（hash）到相同的表索引称为冲突（colliding）</p>
<p>Linux利用链表来处理冲突的PID：每一个表项是由冲突的进程描述符组成的双向链表。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/pidhash表及链表.png" alt="pidhash表"></p>
<p>具有链表的散列法比从PID到表索引的线性转换更优越，这是因为在任何给定的实例中，系统中的进程数总是远远小于32768（所允许的进程PID的最大数）。如果在任何给定的实例中大部分表项都不使用的话，那么把表定义为32768项会是一种存储浪费。</p>
<p>由于需要跟踪进程间的关系，PID散列表中使用的数据结构非常复杂。</p>
<p>PID散列表的数据结构解决了所有这些难题，因为他们可以为包含在一个散列表中任意PID号定义进程链表。</p>
<p><strong>等待队列</strong></p>
<p>等待队列在内核中有很多用途，尤其用在中断处理、进程同步及定时。等待队列表示一组睡眠的进程，当某一条件变为真时，由内核唤醒它们。</p>
<p>等待队列由双向链表实现，其元素包括指向进程描述符的指针。因为等待队列是由中断处理和主要内核函数修改的，因此必须对其双向链表进行保护以免对其进行同事访问，因为同事访问会导致不可预测的后果。</p>
<p>注：雷鸣般兽群问题：即唤醒多个进程只为了竞争一个资源，而这个资源只能有一个进程访问，结果是其他进程必须再次回去睡眠。</p>
<p>非互斥进程插入等待队列链表的第一个位置。互斥进程插入等待队列链表的最后一个位置。</p>
<p>因为所有的非互斥进程总是在双向链表的开始位置，而所有的互斥进程在双向链表的尾部，所以函数总是先唤醒非互斥进程然后再唤醒互斥进程，如果有进程存在的话。</p>
<p><strong>进程切换</strong></p>
<p><strong><em>硬件上下文</em></strong></p>
<p>进程恢复执行前必须转股寄存器的一组数据称为硬件上下文（hardware context)。硬件上下文是进程可执行上下文的一个子集。在Linux中，进程硬件上下文的一部分存放在TSS段，而剩余部分存放在内核太堆栈中。</p>
<p><strong><em>任务状态段(TSS)</em></strong></p>
<p>80x86体系结构包括了一个特殊的段类型，叫任务状态段（Task State Segment, TSS)来存放硬件上下文。尽管Linux并不使用硬件上下文切换，但是强制它为系统中每个不同的CPU创建一个TSS。</p>
<p><strong>thread字段</strong></p>
<p>在每次进程切换时，被替换进程的硬件上下文必须保存在别处。不能像Intel原始设计那样把它保存在TSS中，因为Linux为每个处理器而不是为每个进程使用TSS。</p>
<p>因此，每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。</p>
<p><strong>执行进程切换</strong></p>
<p>从本质上说，每个进程切换由两步组成：</p>
<ol>
<li>切换页全局目录以安装一个新的地址空间</li>
<li>切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包括CPU寄存器。</li>
</ol>
<p><strong>创建进程</strong></p>
<p>Unix操作系统紧紧依赖进程创建来满足用户的需求。</p>
<p>传统的Unix操作系统以统一的方式对待所有的进程：子进程复制父进程所拥有的资源。这种方法使进程的创建非常慢且效率低，因为子进程需要拷贝父进程的整个个、地址空间。</p>
<p>现代Unix内核通过引入三种不同的机制解决了这个问题：</p>
<ul>
<li>写时复制技术允许父子进程读相同的物理页。只要两者中有一个试图写一个物理页，内核就把这个页的内容拷贝到一个新的物理页，并把这个新的物理页分配给正在写的进程。</li>
<li>轻量级进程允许父子进程共享进程在内核的很多数据结构，如页表、打开文件表及信号处理。</li>
<li>vfork()系统调用创建的进程能共享其父进程的内存地址空间。为了防止父进程重写子进程需要的数据，阻塞父进程的执行，一直到到子进程退出或执行一个新的程序为止。</li>
</ul>
<p><strong><em>clone()、fork()及vfork()系统调用</em></strong></p>
<p>在Linux中、轻量级进程是由名为clone()的函数创建的。</p>
<p>实际上，clone()是在C语言库中定义的一个封装（wrapper）函数，它负责建立新轻量级进程的堆栈并且调用对编程者隐藏的clone()系统调用。</p>
<p>传统的fork()系统调用和vfork()系统调用在Linux中也是用clone()实现的。</p>
<p><strong>内核线程</strong></p>
<p>因为一些系统进程只运行在内核太，所以现代操作系统把它们的函数委托给内核线程（kernel thread），内核线程不受不必要的用户态上下文的拖累。</p>
<p><strong><em>进程 0</em></strong></p>
<p>所有进程的祖先叫作进程0，idle进程，或因为历史的原因叫作swapper进程，它是在Linux的初始化阶段从无到有创建的一个内核线程。这个祖先进程使用下列静态分配的数据结构（所有其他进程的数据结构都是动态分配的）：</p>
<ul>
<li>存放在init_task变量中的进程描述符，由INIT_TASK宏完成对它的初始化</li>
<li>存放在init_thread_union变量中的thread__info描述符和内核堆栈，由INIT_THREAD_INFO宏完成对它们的初始化。。</li>
<li>由进程描述符指向的下列表：<ul>
<li>init_mm</li>
<li>init_fs</li>
<li>init_files</li>
<li>init_signals</li>
<li>init_sighand</li>
</ul>
</li>
<li>主内核页全局目录存放在swapper_pg_dir中。</li>
</ul>
<p>start_kernel()函数初始化内核需要的所有数据结构，激活中断，创建另一个叫进程1的内核线程（一般叫作init进程）。新创建内核线程的PID为1，并与进程0共享每个进程所有的内核数据结构。此外，当调度程序选择到它时，init进程开始执行init（）函数。</p>
<p>在多处理器系统中，每个CPU都有一个进程0.只要打开机器电源，计算机的BIOS就启动某一个CPU，同时禁用其他CPU。运行在CPU0还是上的swapper进程初始化内核数据结构，然后激活其他的CPU，并通过copy_process()函数创建另外的swapper进程，把 0 传递给新创建的swapper进程作为它们的新PID。</p>
<p><strong><em>进程 1</em></strong></p>
<p>由进程 0 创建的内核线程执行init()函数，init()依次完成内核初始化。init()调用execve()系统调用装入可执行程序init。结果，init内核线程变为一个普通进程，且拥有自己的每进程（per-process）内核数据结构。在系统关闭之前，init进程一直存活，因为它创建和监控在操作系统外层执行的所有进程的活动。</p>
<p><strong><em>其他内核线程</em></strong></p>
<p>Linux使用很多其他内核线程。其中一些在初始化阶段创建，一直运行奥系统关闭，而其他一些在内核必须执行一个任务时“按需”创建，这种任务在内核的执行上下文中得到很好的执行。</p>
<p><strong>进程删除</strong><br>Unix允许进程查询内核以获得其父进程的PID，或者其任何子进程的执行状态。</p>
<p>为了遵循这些设计选择，不允许Unix内核在进程一终止后就丢弃包含在进程描述符字段中的数据。只有父进程发出了与被终止的进程相关的wait（）类系统调用之后，才允许这样做。这就是引入僵死状态的原因：尽管从技术上来说进程已死，但必须保存它的描述符，直到父进程得到通知。</p>
<p>如果父进程在子进程结束之前结束会发生什么情况呢？在这种情况下，系统中会到处是僵死的进程，而且它们的进程描述符永久占据这RAM。所以这必须强迫所有的孤儿进程成为init进程的子进程来解决这个问题。这样，init进程在用wait（）类系统调用检查其合法的子进程终止时，就会撤销僵死的进程。</p>
<p>对僵死进程的处理有两种可能的方式：</p>
<ol>
<li>如果父进程不需要接收来自子进程的信号，就调用do_exit()。</li>
<li>如果已经给父进程发送了一个信号，就调用wait4（）或waitpid（）系统调用。</li>
</ol>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断通常分为<em>同步（synchronous）中断</em>和<em>异步（asynchronous）中断</em>：</p>
<ul>
<li>同步中断是指当指令执行时有CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。</li>
<li>异步中断是由其他硬件设备依照CPU时钟信号随机产生的。</li>
</ul>
<p>在Intel微处理器手册中，把同步和异步中断分别称为异常（exception）和中断（interrupt）。</p>
<p><strong><em>中断</em></strong></p>
<ul>
<li>可屏蔽中断（maskable interrupt）</li>
<li>非屏蔽中断（nonmaskable interrupt）</li>
</ul>
<p><strong><em>异常</em></strong></p>
<ul>
<li>故障（fault）</li>
<li>陷阱（trap）</li>
<li>异常中止（abort）</li>
<li>编程异常（programmed exception)</li>
</ul>
<p><strong>中断描述符表</strong></p>
<p>中断描述符表（Interrupt Descriptor Table, IDT）是一个系统表，它与灭一个中断或异常向量相联系，每一个向量在表中有相应的中断或异常处理程序的入口地址。</p>
<p>IDT包含三种类型的描述符。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/门描述符的格式.png" alt="门描述符"></p>
<p>这些描述符是：</p>
<p>任务门（task_gate)</p>
<p>​    当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。</p>
<p>中断门（interrupt gate)</p>
<p>​    包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，                             处理器清IF标志，从而关闭将来会发生的可屏蔽中断。</p>
<p>陷阱门（Trap gate）</p>
<p>​    与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志。</p>
<p><strong><em>Linux利用中断门处理中断，利用陷阱门处理异常</em></strong></p>
<p><strong>中断和异常处理程序的嵌套执行</strong></p>
<p>每个中断或异常都会引起一个内核控制路径，或者说代表当前进程在内核态执行单独的指令序列。内核控制路径可以任意嵌套：一个中断处理程序可以被另一个中断处理程序“中断”，因此引起内核控制路径的嵌套执行。如图所示。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/内核控制路径嵌套执行.png" alt="内核控制路径嵌套执行"></p>
<p>允许内核控制路径嵌套执行必须付出代价，那就是中断处理程序必须永不阻塞，换句话说，中断处理程序运行期间不能发生进程切换。事实上，嵌套的内核控制路径恢复执行时需要的所有数据都存放在内核态堆栈栈中，这个栈毫无疑义的属于当前进程。</p>
<p>一个中断处理程序既可以抢占其他的中断处理程序，也可以抢占异常处理程序。相反，异常处理程序从不抢占中断处理程序。</p>
<p>基于以下两个主要原因，Linux交错执行内核控制路径：</p>
<ul>
<li>为了提高可编程中断控制器和设备控制器的吞吐量。</li>
<li>为了实现一种没有优先级的中断模型。简化了内核代码，提高了内核的可移植性。</li>
</ul>
<p><strong>IRQ在多处理器系统上的分发</strong></p>
<p>Linux遵循对称多处理模型（SMP），这意味着，内核从内本质上对任何一个CPU都不应该有</p>
<p>偏爱。因而，内核试图以轮转的方式把来自硬件设备的IRQ信号在所有CPU之间分发。因此，所有CPU服务于I/O中断的执行时间片几乎相同。</p>
<p>在系统启动的过程中，引导CPU执行setup_IO_APIC_irqs()函数来初始化I/O APIC芯片。芯片的中断重定向表的24项被填充，以便根据“最低优先级”模式把来自I/O硬件设备的所有信号都传递给系统中的每个CPU。此外，在系统启动期间，所有的CPU都执行setup_local_APIC()函数，该函数处理本地APIC的初始化。特别是，每个芯片的任务优先级寄存器（TPR）都初始化为一个固定的值，这就意味着CPU愿意处理任何类型的IRQ信号，而不管优先级。Linux内核启动后再也不修改这个值。</p>
<p>因为所有的任务优先级寄存器都包含相同的值，因此，有所CPU总是具有相同的优先级。为了突破这种约束，多APIC系统使用本地APIC仲裁优先级寄存器中的值。因为这样的值在每次中断后都自动改变，因此，IRQ信号就公平地在所有CPU之间分发。</p>
<p>简而言之，当硬件设备发生了一个中断信号时，多APIC系统就选择其中的一个CPU，并把该信号传递给相应的本地APIC，本地APIC又依次中断它的CPU。这个事件不通报给其他所有的CPU。</p>
<hr>
<h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><p>可以把内核看作是不断对请求进行响应的服务器，这些请求可能来自在CPU上执行的进程，也可能来自发出中断请求的外部设备。这个类比强调内核的各个部分并不是严格按照顺序依次执行的，而是采用交错执行的方式。因此，这些请求可能引起竞争条件,而我们必须采用适当的同步机制对这种情况进行控制。</p>
<p><strong>内核抢占</strong></p>
<p>如果进程执行内核函数时，即它在内核态运行时，允许发生内核切换（被替换的进程是正执行内核函数的进程），这个内核就是抢占的。</p>
<p>使内核可抢占的目的是减少用户态进程的分派延迟（dispatch latency），即从进程变为可执行状态到它实际开始运行之间的时间间隔。</p>
<p><strong>内核使用的各种同步技术</strong></p>
<ul>
<li><p><strong>每CPU变量</strong></p>
<p>最好的同步技术是把设计不需要同步的内核放在首位。最简单也是最最重要的同步技术包括把内核变量声明为每CPU变量（per-cpu variable)。每CPU变量主要是数据结构的数组，系统的每个CPU对应数组的一个元素。</p>
<p>一个CPU不应该访问与其它CPU对应的数组元素，另外，它可以随意读或修改它自己的元素而不用担心出现竞争条件。但是，这也意味着每CPU变量基本上只能在特殊情况下使用，也就是当它确定在系统的CPU上的数据在逻辑上是独立的时候。</p>
<p>每CPU的数组元素在主存中被排列以使每个数据结构存放在硬件高速缓存的不同行，因此，对每CPU数组的并发访问不会导致高速缓存行的窃用和失效。</p>
<p>此外，在单处理器和多处理器系统中，内核抢占都可能使每CPU变量产生竞争条件。总的原则是内核控制路径应该在禁用抢占的情况下访问每CPU变量。</p>
</li>
<li><p><strong>原子操作</strong></p>
<p>若干汇编语言指令具有“读—修改—写”类型——也就是说，它们访问内存单元两次，第一次读原值，第二次写新值。</p>
<p>避免由于“读—修改—写”指令引起的竞争条件的最容易的方法，就是确保这样的操作在芯片级是原子的。任何一个这样 的操作都必须以单个指令执行，中间不嫩中断，且避免其他的CPU访问同一存储器单元。这些很小的原子操作（atomic opreations)可以建立在其他更灵活机制的基础之上以创建临界区。    </p>
<p>操作码前缀是lock字节（0xf0）的“读—修改—写”汇编语言指令即使在多处理器系统中也是原子的。当控制大暖检测到这个前缀时，就“锁定”内存总线，直到这条指令执行完成为止。因此，当枷锁的指令执行时，其他处理器不能访问这个内存单元。</p>
</li>
<li><p><strong>优化和内存屏障</strong></p>
<p>当使用优化的编译器时，编译器可能重新安排汇编语言指令以使寄存器以最优的方式使用。此外，现代CPU通常并行地执行若干条指令，且可能重新安排内存访问。这种重新排序可以极大地加速程序的执行。</p>
<p>然而，当处理同步时，必须避免指令重新排序。如果发放在同步原语之后的一条指令在同步原语本身之前执行，事情很快就会变得失控。事实上，所有的同步原语起优化和内存屏障的作用。</p>
<p><strong>优化屏障（memory barrier）</strong>原语保证编译程序不会混淆放在原语操作之前的汇编语言指令和放在原语操作之后的汇编语言指令。在Linux中，优化屏障就是barrier（）宏，它展开为asm volatile(“:::”memory”)。volatile关键字禁止编译器把asm指令与程序中的其他指令重新组合。memory关键字强制编译器假定RAM中的所有内存单元已经被汇编语言指令修改。因此，编译器不能使用存放在CPU寄存器中的内存单元的值来优化asm指令前的代码。</p>
<p><strong>内存屏障（memory barrier）</strong>原语确保，在原语之后的操作开始执行之前，原语之前的操作已经完成。因此，内存屏障类似于防火墙，让任何汇编语言指令都不能通过。</p>
<p>Linux使用六个内存屏障原语：</p>
<ul>
<li>rm()</li>
<li>rmb()</li>
<li>wmb()</li>
<li>smp_mb()</li>
<li>smp_rmb()</li>
<li>smp_wmb()</li>
</ul>
<p>这些原语也被当做优化屏障，因为我们必须保证编译程序不在屏障前后移动汇编语言指令。内存屏障原语的实现依赖与系统的体系机构。在80x86微处理器上，如果CPU支持lfence汇编语言指令，就把rmb（）宏展开为asm volatile（”lfence”)，否则就展开为asm volatile（”lock;addl $0,0(%%esp)”:::”memory”)。</p>
</li>
<li><p><strong>自旋锁</strong></p>
<p>一种广泛使用的同步技术是加锁（locking）。当内核控制路径必须访问共享数据结构或进入临界区时，就需要为自己获取一把”锁“。</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/自旋锁.png" alt="自旋锁"></p>
<p>自旋锁（spin lock）是用来在多处理器环境中工作的一种特殊的锁。如果内核控制路径发现自旋锁”开着“，就获取锁并继续自己的执行。相反，如果内核控制路径发现锁由运行在另一个CPU上的内核控制路径”锁着“，就在周围”旋转“，反复执行一条紧凑的循环指令，直到锁被释放。</p>
<p>自旋锁的循环指令表示”忙等“。及时等待的内核控制路径无事可做（除了浪费时间），它也在CPU上保持运行。不过自旋锁通常非常方便，因为很多内核资源只锁1毫秒的时间片段。</p>
<p>一般来说，由自旋锁所保护的每个临界区都是禁止内核抢占的。在单处理器系统上，这种锁本身不起锁的作用，自旋锁原语仅仅是禁止或启用内核抢占。在自旋锁忙等期间，内核抢占还是有效的，因此，等待自旋锁释放的进程有可能被更高优先级的进程替代。</p>
<p>在Linux中，每个自旋锁都用spin_lock_t结构表示，其中包含两个字段：</p>
<p><strong>slock</strong>：该字段表示自旋锁的状态，值为1表示”未加锁“状态，而任何负数和0都表示”加锁“状态。</p>
<p><strong>break_lock</strong>：表示进程正在忙等自旋锁（只在内核支持SMP和内核抢占的情况下使用该标志）。</p>
</li>
<li><p><strong>读/写自旋锁</strong></p>
<p>读/写自旋锁的引入是为了增加内核的并发能力。只要没有内核控制路径对数据结构进行修改，读/写自旋锁就允许多个内核控制路径同时读同一数据结构。如果一个内核控制路径想对这个结构进行写操作，那么它必须首先获取读/写锁的写锁，写锁授权独占访问这个资源。当然，允许对数据结构并发读可以提高系统性能。</p>
</li>
<li><p><strong>顺序锁</strong></p>
<p>Linux2.6中引入了顺序锁（seqlock），它与读/写自旋锁非常相似，只是它为写着赋予了较高的优先级：事实上，即使在读者正在读的时候也允许写者继续运行。<em>这种策略的好处是写者永远不会等待（除非另一个写者正在写），缺点是有些时候读者不等不反复多次读相同的数据直到它获得有效的副本。</em></p>
<p>每个顺序所都是包括两个字段seqlock_t结构：一个类型为spin_lock_t的lock字段和一个整型的sequence字段，第二个字段是一个顺序计数器。**每个读者都必须在读数据前后两次读顺序计数器，并检查两次读到的值是否相同，如果不相同，说明新的写者已经开始写并增加了顺序计数器，因此暗示读者刚读到的数据是无效的。</p>
</li>
<li><p><strong>读—拷贝—更新（RCU）</strong></p>
<p>读—拷贝—更新（RCU）是为了保护在多数情况下被多个CPU读的数据结构而设计的另一种同步技术。RCU允许多个读者和写者并发执行。而且，RCU是不适用锁的，就是说，它不适用被所有CPU共享的锁或计数器，在这一点上与读/写自旋锁和顺序锁（由于高速缓存行窃用和失效而有很高的开销）相比，RCU具有更大的优势。</p>
<p>其关键思想包括限制RCU的范围：</p>
<ol>
<li>RCU只保护被动态分配并通过指针引用的数据结构</li>
<li>在被RCU保护的临界区中，任何内核控制路径都不能失眠。</li>
</ol>
</li>
<li><p><strong>信号量</strong></p>
<p>实际上，Linux提供两种信号量：</p>
<ul>
<li>内核信号量，由内核控制路径使用</li>
<li>System V IPC信号量，由用户态进程使用</li>
</ul>
<p>内核信号量类似于自旋锁，因为当锁关闭着时，它不允许内核控制路径继续进行。然而，当内核控制路径试图获取内核信号量所保护的忙资源时，相应的进程被挂起。只有在资源被释放时，进程才再次变为可运行的。因此，只有可以睡眠的的函数才能获取内核信号量，中断处理程序和可延迟函数都不能使用内核信号量。</p>
</li>
<li><p><strong>禁止本地中断</strong></p>
<p>确保一组内核语句被当做一个临界区处理的主要机制之一就是中断禁止。即使当硬件设备产生了一个IRQ信号时，中断禁止也让内核控制路径继续执行，因此，这就提供了一中有效的方式 ，确保中断处理程序访问的数据结构也受到保护。然而禁止本地中断并不保护运行在另一个CPU上的中断处理程序对数据结构的并发访问，因此，在多处理器系统上，禁止本地中断经常与自旋锁结合使用。</p>
</li>
<li><p><strong>禁止和激活可延迟函数</strong></p>
<p>禁止可延迟函数在一个CPU上执行的一种简单方式就是禁止在那个CPU上的中断。因为没有中断处理程序被激活，因此，软中断操作就不能异步地开始。</p>
</li>
<li><p>总结</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>技术</th>
<th>说明</th>
<th>使用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>每CPU变量</td>
<td>在CPU之间复制数结构</td>
<td>所有CPU</td>
</tr>
<tr>
<td>原子操作</td>
<td>对一个计数器原子地”读—修改—写“的指令</td>
<td>所有CPU</td>
</tr>
<tr>
<td>内存屏障</td>
<td>避免指令重新排序</td>
<td>本地CPU或所有CPU</td>
</tr>
<tr>
<td>自旋锁</td>
<td>加锁时忙等</td>
<td>所有CPU</td>
</tr>
<tr>
<td>信号量</td>
<td>加锁时阻塞等待（睡眠）</td>
<td>所有CPU</td>
</tr>
<tr>
<td>顺序锁</td>
<td>基于访问计数器的锁</td>
<td>所有CPU</td>
</tr>
<tr>
<td>本地中断的禁止</td>
<td>禁止单个CPU上的中断处理</td>
<td>本地CPU</td>
</tr>
<tr>
<td>本地软中断的禁止</td>
<td>禁止单个CPU上的可延迟函数处理</td>
<td>本地CPU</td>
</tr>
<tr>
<td>读—拷贝—更新（RCU)</td>
<td>通过指针而不是锁来访问共享数据结构</td>
<td>所有CPU</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="定时测量"><a href="#定时测量" class="headerlink" title="定时测量"></a>定时测量</h2><ul>
<li><p><strong>Linux计时体系结构</strong></p>
<p>Linux必定执行于定时相关的操作。例如，内核周期性地：</p>
<ul>
<li>更新自系统启动以来所经过的时间</li>
<li>更新时间和日期</li>
<li>确定当前进程在每个CPU上已运行了多长时间，如果已经超过了分配给它的时间，则抢占它。</li>
<li>更新资源使用统计数</li>
<li>检查每个软定时器的时间间隔是否已到。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>Linux与任何分时系统一样，通过一个进程到另一个进程的快速切换，达到表面上看来多个进程同时执行的神奇效果。</p>
<p>Linux的调度基于分时技术：多个进程以”时间多路服用“方式运行，因为CPU的时间被分成片”（slice）”，给每个可运行进程分配一片。如果当前运行进程的时间片或时限到期时，该进程还没有运行完毕，进程切换就可以发生。</p>
<p>传统上把进程分类为“<strong><em>I/O受限（I/O-bound）</em></strong>“或”<strong><em>CPU受限（CPU-bound）</em></strong>“。前者频繁地使用I/O设备，并花费很多时间等待I/O操作的完成；而后者则需要大量CPU时间的数据计算应用程序。</p>
<p>另一种分类法把进程分为三类：</p>
<ul>
<li><p><strong>交互式进程（interactive process）</strong></p>
<p>这些进程经常与用户进行交互，因此，要花很多时间等待键盘和鼠标操作。当接受了输入后，进程必须被很快唤醒，否则用户将发现系统反应迟钝。典型的交互式程序是命令shell、文本编辑程序及图形应用程序。</p>
</li>
<li><p><strong>批处理进程（batch process)</strong></p>
<p>这些进程不必与用户交互，因此经常在后台运行。典型的批处理进程是程序设计语言的编译程序、数据库搜索引擎及科学计算。</p>
</li>
<li><p><strong>实时进程（real-time process）</strong></p>
<p>这些进程有很强的调度需要。这样的进程绝不会被低优先级的进程阻塞，它们应该有一个很短的响应时间，更重要的是，响应时间的变化应该很小。典型的实时程序有视频和音频应用程序、机器人控制程序及从物理传感器上收集数据的程序。</p>
</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>每个Linux进程总是按照下面的调度类型被调度：</p>
<ul>
<li><p>SCHED_FIFO</p>
<p>先进先出的实时进程</p>
</li>
<li><p>SCHED_RR</p>
<p>时间片轮转的实时进程</p>
</li>
<li><p>SCHED_NORMAL</p>
<p>普通的分时进程</p>
</li>
</ul>
<h4 id="普通进程的调度"><a href="#普通进程的调度" class="headerlink" title="普通进程的调度"></a>普通进程的调度</h4><p>每个普通进程都有它自己的静态优先级，调度程序使用静态优先级来估计系统中这个进程与其他普通进程之间调度的程度。内核用从100（最高优先级）到139（最低优先级）的数表示普通进程的静态优先级。</p>
<p>基本时间片：</p>
<p><img src="/home/utur/图片/picture_for_note/Linux源码/普通进程基本时间片.png" alt="时间片"></p>
<p>与优先级低的进程相比，通常优先级较高的进程获得更长额CPU时间片。</p>
<h4 id="实时进程的调度"><a href="#实时进程的调度" class="headerlink" title="实时进程的调度"></a>实时进程的调度</h4><p>每个实时进程都与一个实时优先级相关，实时优先级是一个范围从1（最高优先级）～99（最低优先级）的值。调度程序总是让优先级高的进程运行，换句话说，实时进程运行的过程中，禁止低优先级进程的执行。与普通进程相反，实时进程总是被当成活动进程。</p>
<p>只有在下述事件之一发生时，实时进程才会被另外一个进程取代：</p>
<ul>
<li>进程被另外一个具有更高实时优先级的实时进程抢占</li>
<li>进程执行了阻塞操作并进入睡眠</li>
<li>进程停止或被杀死</li>
<li>进程通过调用系统调用sched_yield()自愿放弃CPU</li>
<li>进程是基于时间片轮转的实时进程，而且用完了它的时间片。</li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>​    </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Utur</p>
              <div class="site-description motion-element" itemprop="description">木龟想做一个哈皮程序猿。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Turtle-knight" title="GitHub &rarr; https://github.com/Turtle-knight" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:turtle.mugui@gmail.com" title="E-Mail &rarr; mailto:turtle.mugui@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://plus.google.com/木龟" title="Google &rarr; https://plus.google.com/木龟" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Utur</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
